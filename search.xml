<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Charles的使用与配置</title>
      <link href="/2020/05/29/2020-05-29-charles-de-shi-yong-yu-pei-zhi/"/>
      <url>/2020/05/29/2020-05-29-charles-de-shi-yong-yu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Charles是使用简单，也是开发过程中非常有用的工具，这里简单介绍下使用。</p><p>对于开发iOS的同学来说，如果要使用模拟器进行调试，配置非常简单。</p><p>第一步，打开Charles，勾选macOS Proxy：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530141024.png" alt="proxy"></p><p>第二步，再在help—SSL Proxying中勾选即可：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530141411.png" alt="image-20200530141352348"></p><p>而对于Android同学来说，重复第一步，然后再在Android的模拟器中配置即可。</p><h4 id="调试HTTPS"><a href="#调试HTTPS" class="headerlink" title="调试HTTPS"></a>调试HTTPS</h4><p>以上的基本操作，基本上可以满足80%的日常开发，可以很快的排除问题。生产环境，我们都是使用HTTPS来进行加密访问的。如果线上出现了错误，急需要前后端进行排查。我们可以使用真机配合 Charles，来快速的定位出问题的API。</p><p>第一步，打开Charles，然后获取mac的IP地址，当然，你也可以在网络中查看：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530144050.png" alt="image-20200530142444240"></p><p>第二步，在手机上配置好相应的代理，然后打开线上APP，进行抓包，如果设置成功，Charles会自动弹出弹窗，然后点击allow：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530145100.png" alt="image-20200530145100337"></p><p>我们查看出错的APP，发现所有的API都是unknown：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530145326.png" alt="image-20200530145326547"></p><p>第三步，注册证书：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530145430.png" alt="image-20200530145430913"></p><p>此时会跳转到钥匙串，找到Charles对应的证书，证书是红色的，很容易找到。然后双击这个证书，然后选择始终信任：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530145622.png" alt="image"></p><p>第四步，通过Proxy–&gt;SSL Proxying Settings,勾选Enable SSL Proxying, 并添加host，端口是443 这里是把所有的host都设置进去：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530145842.png" alt="image-20200530145842162"></p><p>第五步，通过help–&gt;SSLProxying–&gt; Install Charles Root Ceriticate on a Mobile Device or Remote Browser，可以获得下载提示：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530150343.png" alt="image-20200530150343535"></p><p>在iPhone上，使用Safari（必须），输入提示的网址<code>chls.pro/ssl</code>,提示下载描述文件，点击下载完成后，。然后在设置中“已下载描述文件”中安装。</p><p>第六步，在iPhone上，通用–关于本机—证书信任设置，信任证书即可。此时，你就可以看到HTTPS的数据啦。</p><h4 id="弱网调试"><a href="#弱网调试" class="headerlink" title="弱网调试"></a>弱网调试</h4><p>点击proxy—throttle settings，可以模拟网络状态差的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530154513.png" alt="image-20200530152727780"></p><p>通过配置网络的带宽，以及模拟网络的可靠性和稳定性，来模拟弱网情况。</p><h4 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h4><p>有时候，我们需要对接口进行一些操作，比如修改请求参数，编辑返回值等。那么就可以采取打断点的方式来进行调试。</p><p>第一步，选择你要调试的API，然后右击选择breakpoint。</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530154457.png" alt="image-20200530153517673"></p><p>第二步，对选中的API重复发起请求：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530154435.png" alt="image-20200530153618018"></p><p>此时，则会出现断点页面,此时还没有发网络请求，你可以在这里编辑请求参数，还有接口：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530154413.png" alt="image"></p><p>编辑完毕后，点击execute，则会发起HTTP请求，当捕获到Server返回的结果后，你还可以对结果进行编辑：</p><p><img src="https://cdn.jsdelivr.net/gh/smileasy/Picgo/img/20200530154358.png" alt="image1"></p><p>以上，就是我们开发中常用的Charles的用法。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2020/04/01/2020-04-01-fang-dou-he-jie-liu/"/>
      <url>/2020/04/01/2020-04-01-fang-dou-he-jie-liu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>防抖和节流在前端日常开发中使用的的频率相当高，在小程序还有Hybrid应用开发中也会使用到它。像<a href="https://underscorejs.bootcss.com/" target="_blank" rel="noopener">underscore</a>中就提供了这样的高阶函数。</p><p>防抖常见的使用场景有：</p><ul><li>监听scroll的滚动</li><li>搜索框输入查询</li><li>表单验证</li><li>按钮点击事件</li><li>浏览器窗口缩放（resize事件）</li></ul><h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><p>原理：事件响应函数在第一次被触发时，并不会立即执行，而是在一个计时器阈值后执行。例如我们设置的计时器的阈值是300ms，如果在这300ms内没有再次触发这个事件响应函数，那么就执行这个响应函数；如果在300ms内再次触发这个事件响应函数，那么当前的计时取消，重新开始计时。</p><p>这样，我们如果在300ms时间内大量触发同一个响应事件，最终只会执行一次函数。</p><p>使用underscore的高阶函数来实现防抖：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//使用underscore的高阶函数来实现防抖</span>container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>mouseMove<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置为true，则会立即触发一次函数执行，默认为false</span>container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>mouseMove<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们可以模仿underscore中的实现，将防抖抽取成一个<code>debounce.js</code>文件，里面这样实现即可：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout<span class="token punctuation">,</span> result<span class="token punctuation">;</span>    <span class="token keyword">var</span> debounced <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//改变内部函数的this的指向</span>        <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将实参传递给外部</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 立即执行</span>            <span class="token keyword">var</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timeout<span class="token punctuation">;</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> result <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    debounced<span class="token punctuation">.</span>cancel <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> debounced<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面，我们演示如何使用：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token selector"><span class="token id">#container</span> </span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#111</span><span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>取消防抖<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdnjs.gtimg.com/cdnjs/libs/underscore.js/1.7.0/underscore.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./debounce.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">mouseMove</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">'哈哈哈哈哈'</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 会多次触发鼠标移动事件</span>        <span class="token comment" spellcheck="true">// container.onmousemove = mouseMove;</span>        <span class="token comment" spellcheck="true">//使用underscore的高阶函数来实现防抖</span>        <span class="token comment" spellcheck="true">// container.onmousemove = _.debounce(mouseMove, 300);</span>        <span class="token comment" spellcheck="true">//设置为true，则会立即触发一次函数执行，默认为false</span>        <span class="token comment" spellcheck="true">//  container.onmousemove = _.debounce(mouseMove, 300, true);</span>         <span class="token keyword">let</span> debounced <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>mouseMove<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> debounced<span class="token punctuation">;</span>         button<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'取消防抖'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            debounced<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><blockquote><p>我们创建一个html，然后引用我们的debounce文件。对比使用underscore框架，效果一致。</p></blockquote><h3 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h3><p>原理：如果你持续触发一个响应事件，那么每隔一段时间，就会执行这个事件的回调函数。</p><p>我们可以从使用场景来区别防抖和节流。假如我们有一个很长的列表，用户在不间断（触发间隔小于300ms）的滚动。我们如果使用防抖（设置超时阈值为300ms），那么我们的事件回调只有等用户停止滚动（间隔大于300ms）后才会执行，如果用户总是在不间断的滚动，那么理论上我们的事件回调就不会执行；现在，我们希望用户在间断的滚动过程中，每隔（2000ms）一段时间，就显示当前滚动距顶部的距离，那么就需要使用节流了。</p><p>节流常见的使用场景有：</p><ul><li>DOM元素的拖拽</li><li>计算鼠标的移动距离</li><li>监听scroll的滚动</li><li>搜索框输入查询</li></ul><p>使用underscore的高阶函数来实现防抖：</p><pre class=" language-javascript"><code class="language-javascript"> container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">throttle</span><span class="token punctuation">(</span>mouseMove<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span><span class="token punctuation">{</span>             leading<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>             trailing<span class="token punctuation">:</span> <span class="token boolean">false</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>默认情况下，在underscore中，leading默认为true，表示当你触发事件时会立即执行响应回调函数；trailing默认为true，表示当你停止触发事件（此时正处于下一次2000ms的回调间隔内），会执行这最后一次的回调。需要注意的是，leading和trailing不能同时为false，否则会有bug。现象是“第一次”可以达到我们想要的同时为false的效果，“第二次”则不能达到同时为false的效果。</p></blockquote><p>节流可以有2种方式实现，一种是使用时间戳，一种是定时器，下面我们将分别实现它。</p><h4 id="使用时间戳的方式实现节流"><a href="#使用时间戳的方式实现节流" class="headerlink" title="使用时间戳的方式实现节流"></a>使用时间戳的方式实现节流</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 相当于underscore中leading: true ，trailing: false的情况</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">;</span>    <span class="token keyword">var</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> old <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="使用定时器的方式实现节流"><a href="#使用定时器的方式实现节流" class="headerlink" title="使用定时器的方式实现节流"></a>使用定时器的方式实现节流</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 相当于underscore中leading: false ，trailing: true的情况</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">,</span> timeout<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="结合定时器和时间戳来实现节流"><a href="#结合定时器和时间戳来实现节流" class="headerlink" title="结合定时器和时间戳来实现节流"></a>结合定时器和时间戳来实现节流</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 相当于underscore中leading: true ，trailing: true的情况</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">,</span> timeout<span class="token punctuation">;</span>    <span class="token keyword">var</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> old <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                old <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="仿照underscore框架实现最终版"><a href="#仿照underscore框架实现最终版" class="headerlink" title="仿照underscore框架实现最终版"></a>仿照underscore框架实现最终版</h4><p>模仿underscore,可以通过options来控制第一次是否执行和最后一次是否执行的情况：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">)</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">,</span> timeout<span class="token punctuation">;</span>    <span class="token keyword">var</span> old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>old <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> old <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 第一次会执行</span>            old <span class="token operator">=</span> now<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>trailing <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 最后一次会执行</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                old <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面，我们演示如何使用：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token selector"><span class="token id">#container</span> </span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#111</span><span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdnjs.gtimg.com/cdnjs/libs/underscore.js/1.7.0/underscore.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./throttle.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">mouseMove</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// console.log(event);</span>            <span class="token comment" spellcheck="true">// return '哈哈哈哈哈'</span>        <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//使用underscore的高阶函数来实现节流</span>        <span class="token comment" spellcheck="true">//  container.onmousemove = _.throttle(mouseMove, 2000,{</span>        <span class="token comment" spellcheck="true">//      leading: true,</span>        <span class="token comment" spellcheck="true">//      trailing: false</span>        <span class="token comment" spellcheck="true">//  });</span>        container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span>mouseMove<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>             leading<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>             trailing<span class="token punctuation">:</span> <span class="token boolean">true</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>防抖和节流应该算是对性能的优化。至于何时使用，还要结合需求场景。</p><p>我们注意到，对于搜索框输入查询，我们即可以使用防抖方案，也可以使用节流方案。但是，二者的业务需求是不同的。例如如果要支持输入“实时搜索”，那么使用节流方案就比较合适；如果，我们只是希望用户在超过一段时间后当成“输入完成”才去搜索，那么使用防抖方案是比较合适的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序蓝牙热敏打印机调试总结</title>
      <link href="/2020/02/21/2020-02-21-wei-xin-xiao-cheng-xu-lan-ya-re-min-da-yin-ji-diao-shi-zong-jie/"/>
      <url>/2020/02/21/2020-02-21-wei-xin-xiao-cheng-xu-lan-ya-re-min-da-yin-ji-diao-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">### 1.扫描设备筛选<blockquote><p>要搜索的蓝牙设备主 service 的 uuid 列表。某些蓝牙设备会广播自己的主 service 的 uuid。如果设置此参数，则只搜索广播包有对应 uuid 的主服务的蓝牙设备。建议主要通过该参数过滤掉周边不需要处理的其他蓝牙设备。</p></blockquote><h4 id="问：-主uuid是怎么查到的呢？"><a href="#问：-主uuid是怎么查到的呢？" class="headerlink" title="问： 主uuid是怎么查到的呢？"></a>问： 主uuid是怎么查到的呢？</h4><p>比如蓝牙打印机，我使用<code>18F0</code>作为筛选，可以正确筛选的到<code>Printer001</code>设备。那么<code>18F0</code>是怎么获得的呢？有什么依据呢?</p><ul><li>打印信息：</li></ul><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/EFCFA21DE907451F90F6CF3EE664D9D4/32975" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/D18749589DF348F59473034678E37906/33011" alt="image"></p><ul><li>使用LightBlue来查看信息：</li></ul><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/WEBRESOURCEea3ca81a84e56dd42b6e5a770ab9daa8/32983" alt="image"></p><blockquote><p>可以看到，在advertisServiceUUIDS中，以及APP打印的信息中，均看到了<code>18F0</code>的身影，但是我们还是不能够确认这种想法是否合理。</p></blockquote><ul><li>现在我们用<code>FEE7</code>来筛选另一个蓝牙设备来做测试：</li></ul><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/C251F4DC7DEE4FD0ABF6675BFE717779/32991" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/WEBRESOURCEd1b27e14252d38e5e2319966348ceebd/32992" alt="image"></p><blockquote><p>可以看到，FEE7依旧是取的是advertisServiceUUIDs列表中，第一个元素的，第三、第四两个字节作为筛选条件。</p></blockquote><h3 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2.建立连接"></a>2.建立连接</h3><ul><li>建立连接后，需要发现主服务和主特征值：</li></ul><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/62617F451B5B4F328C1038C4F0341395/33006" alt="image"></p><blockquote><p>可以看到，我们共发现了4个主服务。那么我们要选哪个服务呢？暂时可以理解为选和主advertisServiceUUIDs中“第一个”相同的作为发现主特征值的那个服务。</p></blockquote><ul><li>我们使用第一个服务来获取特征值：</li></ul><p><img src="https://note.youdao.com/yws/public/resource/264974b7480a5ec875f95d6a6b814cab/xmlnote/7D149ED8993641CE8FC333788BC3D963/33025" alt="image"></p><blockquote><p>获取到特征值后，我们就可以使用这个服务和这个服务对应的特征值（write 和 notify）来进行操作了（注意，write和notify需要使用他们所属的服务）。</p></blockquote><p>我们通过特征值可以发现，第三和第四字节与lightBlue上的标识相同。并且与服务的不同，也仅仅是第三和第四位不相同而已。</p>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在iOS中使用密码填充功能</title>
      <link href="/2020/01/05/2020-01-05-zai-ios-zhong-shi-yong-mi-ma-tian-chong-gong-neng/"/>
      <url>/2020/01/05/2020-01-05-zai-ios-zhong-shi-yong-mi-ma-tian-chong-gong-neng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="在iOS中使用密码填充功能"><a href="#在iOS中使用密码填充功能" class="headerlink" title="在iOS中使用密码填充功能"></a>在iOS中使用密码填充功能</h2><p>密码自动填充支持第三方 App 是 iOS 12 中包含的众多新功能之一。为了提高用户体验，越来越多的APP支持了这个功能，现在将这个特性总结一下（虽然貌似有点晚。。。）。</p><h3 id="手机设置"><a href="#手机设置" class="headerlink" title="手机设置"></a>手机设置</h3><p>首先，你需要启用密码自动填充功能。然后，进入“设置”&gt;“密码和帐户”，随后开启“自动填充密码”即可。</p><h3 id="开发者后台配置"><a href="#开发者后台配置" class="headerlink" title="开发者后台配置"></a>开发者后台配置</h3><h4 id="新建APP"><a href="#新建APP" class="headerlink" title="新建APP"></a>新建APP</h4><p>如果你是新建的APP，可以按照这个流程：</p><p><img src="https://raw.githubusercontent.com/smileasy/Picgo/master/img/20200115160110.png" alt="第一步新建"></p><p>选择APP ID，然后continue：</p><p><img src="https://raw.githubusercontent.com/smileasy/Picgo/master/img/20200115170335.png" alt="第二步"></p><p>配置APP所需的东东，然后记得勾选上我们这次需要的Associated Domains选项：<br><img src="https://raw.githubusercontent.com/smileasy/Picgo/master/img/20200115171135.png" alt></p><h4 id="原有APP"><a href="#原有APP" class="headerlink" title="原有APP"></a>原有APP</h4><p>如果是原有的APP则直接选择你需要配置的APP ID：<br><img src="https://raw.githubusercontent.com/smileasy/Picgo/master/img/20200115171448.png" alt></p><p>然后勾选Associated Domains即可：</p><p><img src="https://raw.githubusercontent.com/smileasy/Picgo/master/img/20200115170652.png" alt></p><p>当然，你也可以直接去Xcode中设置：</p><p><img src="https://raw.githubusercontent.com/smileasy/Picgo/master/img/20200115172403.png" alt></p><blockquote><p>需要注意的是，即使你使用了xcode这个方式，你仍然需要登录开发者后台，将App ID Prefix拷贝下来，以供后面生成的apple-app-site-association文件使用。</p></blockquote><p>配置后的xcode效果图：</p><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/62B9646382DE4D5992B31F04DF974646/30770" alt></p><p>内容为：</p><pre><code>webcredentials: api.hgxcs.huaguosun.com</code></pre><blockquote><p>注意：api.hgxcs.huaguosun.com为你托管文件apple-app-site-association的域名，你需要将apple-app-site-association文件放在该域名下供Apple来验证APP。并且，你的域名需要支持HTTPS。</p></blockquote><p>apple-app-site-association的内容格式如下：</p><pre><code>{    &quot;webcredentials&quot;:{        &quot;apps&quot;:[&quot;TTUAZSH44S.com.huaguoshan.steward&quot;]     }}</code></pre><blockquote><p>其中TTUAZSH44S为你的APP ID prefix，com.huaguoshan.steward为你的bundle id。</p></blockquote><p>如果你不是很确定自己的配置是否正确，可以去<a href="https://branch.io/resources/aasa-validator/" target="_blank" rel="noopener">Branch.io Apple App Site Association Validator </a>或者 <a href="https://search.developer.apple.com/appsearch-validation-tool" target="_blank" rel="noopener">Apple App Search API Validation Tool</a> 验证一下.</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>我们将分别测试注册、登录、修改密码这三个功能。页面如下：</p><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCE001235bfd1e029093aa29d8b9d29b9d7/30797" alt="image"></p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCEdc747af11f4bea4f95ebb5c2f04de8ec/30803" alt="image"></p><p>进入注册页面，也就是2个textField，当你输入账号时感觉也没什么不同，但是点击输入密码时，系统会弹出这个页面：</p><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCE5415c2965ad3d5770a7953f7ebd1a23f/30795" alt="image"></p><blockquote><p>系统会针对输入密码时做出询问：你是使用iPhone为你生成的强密码，还是选择自定义密码。如果你选择的是普通密码，那么就可以手动输入自己定义的密码，选择strong password，那么iPhone会为你自动创建密码。</p></blockquote><p>当我们点击注册按钮后，系统就会询问你是否要保存密码到iCould中。如果你选择保存密码，那么Apple会通过但是不使用存储到iCould的钥匙串中，那么下次即使你更换了其他的设备，只要是同一个iCould账号，同一款APP，登录是就会方便多了。效果见后面的登录。</p><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCE0dd5020fdabe8ab3b07d4006aaf7cf90/30793" alt="image"></p><p>OC代码实现：</p><pre><code>    passwordTextField.placeholder = @&quot;请输入密码&quot;;    accountTextField.placeholder = @&quot;请输入用户名&quot;;    if (@available(iOS 11.0, *)) {        accountTextField.textContentType = UITextContentTypeUsername;        //重点,密码框指定为UITextContentTypeNewPassword， 指定自动填充密码         passwordTextField.textContentType = UITextContentTypeNewPassword;    }    // 有人说账号的textField有时不生效，需要指定UIKeyboardTypeEmailAddress，我测试并没遇到这个问题    accountTextField.keyboardType = UIKeyboardTypeEmailAddress;    passwordTextField.secureTextEntry = YES;</code></pre><blockquote><p>swift的设置是一样的，我是直接在storyboard中设置的，就不上代码了。</p></blockquote><p>ios12之上的版本，你还可以指定生成密码的规则，你还可以使用官方的<a href="https://developer.apple.com/password-rules/" target="_blank" rel="noopener">密码生成规则工具</a> ：</p><pre><code>// ios12 passwordTextField.passwordRules = [UITextInputPasswordRules passwordRulesWithDescriptor:@&quot;required: lower; required: upper; required: digit; required: [-]; required: [@]; required: [+]; minlength: 40;&quot;];</code></pre><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>我们先使用注册功能，注册3个账号，账号为110，119,120。当我们来到登录页面，会出现提示：</p><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCE13da8adfd5c80c421e47d512014bcee7/30837" alt="image"></p><p>点击右边的小钥匙，可以看到在APP下你存储的所有密码：</p><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCE093a5988218e0b6f8665acd9431b8b9d/30839" alt="image"></p><p>OC代码实现：</p><pre><code>    passwordTextField.placeholder = @&quot;请输入密码&quot;;    accountTextField.placeholder = @&quot;请输入用户名&quot;;    if (@available(iOS 11.0, *)) {        //重点，passwordTextField的类型指定为UITextContentTypePassword        accountTextField.textContentType = UITextContentTypeUsername;         passwordTextField.textContentType = UITextContentTypePassword;    }    passwordTextField.secureTextEntry = YES;</code></pre><h4 id="更换密码和发送验证码"><a href="#更换密码和发送验证码" class="headerlink" title="更换密码和发送验证码"></a>更换密码和发送验证码</h4><p><img src="https://note.youdao.com/yws/public/resource/341b16659e3d19ec5c73a3ef6e4e8a9d/xmlnote/WEBRESOURCE63923f07db6d2c98cff297f417afdf4e/30917" alt="image"></p><blockquote><p>点击弹出的密码，就会自动填充到验证码框。</p></blockquote><p>OC代码实现：</p><pre><code>accountTextField.textContentType = UITextContentTypeUsername;passwordTextField.textContentType = UITextContentTypeNewPassword;smsCodeTextField.textContentType = UITextContentTypeOneTimeCode;</code></pre><p>网页实现，我还没有实验，可以参考<a href="https://developer.apple.com/documentation/security/password_autofill/enabling_password_autofill_on_an_html_input_element?language=objc" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><p><a href="https://developer.apple.com/videos/play/wwdc2017/206" target="_blank" rel="noopener">WWDC2017</a></p></li><li><p><a href="https://developer.apple.com/videos/play/wwdc2018/204" target="_blank" rel="noopener">WWDC2018</a></p></li><li><p><a href="https://juejin.im/post/5dee55e06fb9a0163f77bf38" target="_blank" rel="noopener">iOS Password AutoFill</a></p></li><li><p><a href="https://xiaovv.me/2018/03/25/iOS11-Password-AutoFill-for-Apps/" target="_blank" rel="noopener">iOS 11 新特性：App 密码自动填充</a></p></li><li><p><a href="https://www.jianshu.com/p/7e812c43b08f" target="_blank" rel="noopener">WWDC18 iOS 自动生成强密码和自动填充验证码/密码</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化uni-app更新策略思路</title>
      <link href="/2019/12/18/2019-12-18-you-hua-uni-app-geng-xin-ce-lue-si-lu/"/>
      <url>/2019/12/18/2019-12-18-you-hua-uni-app-geng-xin-ce-lue-si-lu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="口语描述"><a href="#口语描述" class="headerlink" title="口语描述"></a>口语描述</h3><ul><li>全量更新： 全量更新是指发APP包更新，对应的iOS是指发IPA包到appstore，Android发apk包到商城。</li><li>增量更新： 指uni-app提供的热更新生成的wgt文件，可以下载完自动安装，然后重启APP即可完成更新（iOS开发者泪奔ing）。</li><li>基座： Hybrid框架的打包都是依赖于框架自身的编译环境的。uni-app则是HBuilderX这款IDE。由于HBuilderX的不定时更新（可以看到会修复很多bug），造成了我们发增量包时编译环境的不同。所以，我的原则是，如果发新的增量包，需要保持编译环境一致，不然就需要发全量更新包。</li></ul><h3 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h3><p>原来的更新策略<a href="https://smileasy.github.io/2019/08/27/2019-08-27-shi-yong-uni-app-shi-xian-yun-da-bao-he-re-geng-xin/">是这样的</a>，用户登录成功后跳转到home主页，然后在<code>onShow</code>方法中做更新检测：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">onShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isNew<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// isNew 默认false</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isNewVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取最新版本</span>        <span class="token function">isNewVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$api<span class="token punctuation">.</span><span class="token function">getNewVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>is_newest<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//后台告诉我们是新版本，那么将标识符isNew置为true</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>isNew <span class="token operator">=</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//有新版本，分为增量更新和全量更新</span>                    <span class="token comment" spellcheck="true">// #ifdef APP-PLUS</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>is_update_now<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//增量更新</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>down_link <span class="token operator">!==</span> <span class="token string">'none'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkUpdate</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>down_link<span class="token punctuation">)</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//全量更新</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>uni<span class="token punctuation">.</span><span class="token function">getSystemInfoSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>platform <span class="token operator">==</span> <span class="token string">'ios'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//iOS，提示用户去APP store下载最新</span>                            tip<span class="token punctuation">.</span><span class="token function">showModal</span><span class="token punctuation">(</span><span class="token string">'请前往App Store下载最新版本'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            tip<span class="token punctuation">.</span><span class="token function">showModal</span><span class="token punctuation">(</span><span class="token string">'发现新版本'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//Android，跳转到fir上用户手动点击下载</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    plus<span class="token punctuation">.</span>webview<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'https://fir.im/hgxgjzs'</span><span class="token punctuation">)</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span><span class="token punctuation">)</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// #endif</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 下载增量包</span>        <span class="token function">checkUpdate</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>            plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">showWaiting</span><span class="token punctuation">(</span><span class="token string">'下载更新...'</span><span class="token punctuation">)</span>            plus<span class="token punctuation">.</span>downloader                <span class="token punctuation">.</span><span class="token function">createDownload</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span> filename<span class="token punctuation">:</span> <span class="token string">'_doc/update/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>d<span class="token punctuation">,</span> status<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">installWgt</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>filename<span class="token punctuation">)</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'下载更新失败!'</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">closeWaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 安装增量包</span>        <span class="token function">installWgt</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>            plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">showWaiting</span><span class="token punctuation">(</span><span class="token string">'安装资源文件中...'</span><span class="token punctuation">)</span>            plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span>                path<span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">closeWaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'应用资源更新完成!'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">closeWaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'资源更新失败,原因:'</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>message<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>上面的更新策略代码有不完善的地方，需要改进。为帮助理解，现在结合用户使用场景进行描述。</p><p>众所周知，Hybrid框架在Android设备上的体验一直不是很让人满意，表现最明显的就是卡顿现象。在产品交付后，Android用户会遇到一些机型造成的页面崩溃，比如选择日期造成的崩溃和打开网页造成的崩溃：</p><p>​    <img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/WEBRESOURCEdf43588d5b036ba3b94d8b3a58261be9/30162" alt="日期选择器崩溃"></p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/WEBRESOURCEc3a49a6e7d2fc07fa3d3678cee2a5627/30164" alt="打开网页崩溃"></p><p>一般出现这种问题，我们都需要更新基座来尝试解决，也就是需要发新的全量包（apk 和ipa）,让用户从版本A升级到版本B。我们再发增量包时，希望用户从B升级到C。</p><pre><code>用户使用版本A--&gt;新更新基座版本B--&gt;新增量包版本C</code></pre><p>不过，这只是理想场景。如果用户使用A版本发生了崩溃，而未及时升级到B版本的新基座，而我们此时已经发了增量包版本C。按照现在的代码更新逻辑，用户则直接跳过B 版本，直接从A版本更新到C。这样，如果用户仍旧反馈出现页面崩溃，而告诉我们他当前的版本号已经是C版本，作为开发者，就无法得知用户究竟是否更新过基座B。</p><h3 id="优化更新策略"><a href="#优化更新策略" class="headerlink" title="优化更新策略"></a>优化更新策略</h3><p>为了避免用户跳过基座的情况出现，新的更新策略加入了基座版本的设定，如果用户想要从A版本更新到C版本，那么就判断用户当前使用的版本是否是指定的基座版本，是的话则直接为用户进行增量更新，不是则需要用户先更新基座版本（也就是全量更新），在为其做增量更新。</p><p>代码实现如下：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token function">onShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>hasCheckedVersion<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//默认hasCheckedVersion为false</span>            <span class="token comment" spellcheck="true">//没有检测过版本，则需要检测版本</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//针对Android用户的返回键，防止更新过程中点击返回按钮，造成下载APK失败</span>    <span class="token function">onBackPress</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//值为 true 时，才表示不执行默认的返回，自行处理此时的业务逻辑</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowBack    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token function">checkVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//检测版本号</span>            <span class="token comment" spellcheck="true">// #ifdef APP-PLUS</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$api<span class="token punctuation">.</span><span class="token function">getNewVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//是最新版本，标记为已检测，下次onshow不需要重复请求后台进行检测</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>hasCheckedVersion <span class="token operator">=</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 非最新版本，且此时用户的基座满足要求， 直接进行在线更新</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">readyForUpdate</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>url<span class="token punctuation">)</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 非最新版本，但是此时用户的基座不满足要求，需要先下载APK/IPA</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>uni<span class="token punctuation">.</span><span class="token function">getSystemInfoSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>platform <span class="token operator">==</span> <span class="token string">'ios'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        tip<span class="token punctuation">.</span><span class="token function">showModal</span><span class="token punctuation">(</span><span class="token string">'发现了新版本\n即将前往App Store更新'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                            <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token string">'itms-apps://itunes.apple.com/cn/app/id1478581650?mt=8'</span>                            plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">openURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        tip<span class="token punctuation">.</span><span class="token function">showModal</span><span class="token punctuation">(</span><span class="token string">'发现新版本 建议您立即更新'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>callback <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                            tip<span class="token punctuation">.</span><span class="token function">showLoading</span><span class="token punctuation">(</span><span class="token string">'正在更新 预估耗时1分钟...'</span><span class="token punctuation">)</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateForAndroidAPK</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>url<span class="token punctuation">)</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// #endif</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 准备下载最新的增量更新包</span>        <span class="token function">readyForUpdate</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>allowBack <span class="token operator">=</span> <span class="token boolean">false</span>            plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">showWaiting</span><span class="token punctuation">(</span><span class="token string">'正在为您更新资源...'</span><span class="token punctuation">)</span>            plus<span class="token punctuation">.</span>downloader                <span class="token punctuation">.</span><span class="token function">createDownload</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span> filename<span class="token punctuation">:</span> <span class="token string">'_doc/update/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>d<span class="token punctuation">,</span> status<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>allowBack <span class="token operator">=</span> <span class="token boolean">true</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">installWgt</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>filename<span class="token punctuation">)</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'下载更新失败!'</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">closeWaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 安装增量包</span>        <span class="token function">installWgt</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>            plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">showWaiting</span><span class="token punctuation">(</span><span class="token string">'正在为您安装新的资源...'</span><span class="token punctuation">)</span>            plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span>                path<span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">closeWaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'应用资源更新完成!'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">closeWaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'资源更新失败,原因:'</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>message<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//为Android用户自动下载APK</span>        <span class="token function">updateForAndroidAPK</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>allowBack <span class="token operator">=</span> <span class="token boolean">false</span>            plus<span class="token punctuation">.</span>downloader                <span class="token punctuation">.</span><span class="token function">createDownload</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>d<span class="token punctuation">,</span> status<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    tip<span class="token punctuation">.</span><span class="token function">hideLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>allowBack <span class="token operator">=</span> <span class="token boolean">true</span>                        plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>filename<span class="token punctuation">)</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        plus<span class="token punctuation">.</span>nativeUI<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'下载更新失败!'</span><span class="token punctuation">)</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>allowBack <span class="token operator">=</span> <span class="token boolean">true</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span></code></pre><p>除了优化了更新策略，还为Android的“呆萌用户”解决了不知道怎么下载apk包这个世纪难题，为iOS用户解决了在APP store查找不到APP这个“奇异bug”。</p>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app中wach和computed的使用总结</title>
      <link href="/2019/12/13/2019-12-13-uni-app-zhong-wach-he-computed-de-shi-yong-zong-jie/"/>
      <url>/2019/12/13/2019-12-13-uni-app-zhong-wach-he-computed-de-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">最近做uni-app的项目,适配微信小程序.由于现在微信小程序出台了新的登录授权规范,根据规范和业务需求,首页共有3种展示状态:①未登录,②登录并且有全部权限,③登录有部分权限.该小程序的首页为购物车页面,业务相对复杂,考虑到状态的管理,使用了Vuex插件和watch的相关配合,现在将采坑记录下来.<h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h3><p>我们使用<a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">计算属性computed</a>的场景还是很常见的.计算属性在处理一些复杂逻辑时是很有用的.相对于methods,效果上两个都是一样的,两者可以相互替换使用.但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。所以我们为了性能,可以优先考虑使用computed.现在假设我们有个”很复杂”的逻辑,现在将js代码展示出来:</p><pre><code>&lt;script&gt;    export default {        computed: {            title() {                return this.$config.indexTitle            },            desc() {                return `我被调用了${this.invokeCount}次`            }        },        watch: {            title(newValue, oldValue) {                this.setTitle()            },        },        data() {            return {                invokeCount: 0,            }        },        onLoad() {        },        methods: {            setTitle() {                this.invokeCount +=  1             },            gotoChangeTitle() {                this.title = Date.now()            }        }    }&lt;/script&gt;</code></pre><p>title值为一个计算属性的get,我们同时watch了这个title,每次title值发生了切换,那么desc字段就自动加1.点击事件为gotoChangeTitle.</p><p>但是,此时如果触发gotoChangeTitle事件,则会发生报错:</p><pre><code>VM423:1 [Vue warn]: Computed property &quot;title&quot; was assigned to but it has no setter.(found in pages/index/index)</code></pre><p>原因是我们直接更改了title,但是title是计算属性字段,我此时只是实现了title的get方法,没有实现set方法,如果直接更改title则会报没有setter的错误.</p><p>解决点击事件报错:</p><pre><code>gotoChangeTitle() {                //直接更改赋值，此处的值为我们声明的全局变量                this.$config.indexTitle = `啦啦啦${Date.now()}`            }</code></pre><blockquote><p>这样,虽然点击触发gotoChangeTitle没有报错,并且也确实更改了this.$config.indexTitle的值,但是却没有跟新页面,原因是我们并没有在data()中声明可以被”绑定”到view中的字段.</p></blockquote><p>解决办法:我们需要在data中创建一个字段叫做indexTitle, indexTitle既是”绑定”给页面,也是相当于computed的”中间值”</p><pre><code>&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;image class=&quot;logo&quot; src=&quot;/static/logo.png&quot;&gt;&lt;/image&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{ title }}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{ desc }}&lt;/text&gt;        &lt;/view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;gotoChangeTitle&quot;&gt;本页面更新title&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default {    computed: {        title:{            get() {                // 使用data中的indexTitle                return this.indexTitle            },            set (value) {                // 更改title后，也需要将indexTitle和全局值做更改                this.indexTitle = value                this.$config.indexTitle = value            }        },        desc() {            return `我被调用了${this.invokeCount}次`        }    },    watch: {        title(newValue, oldValue) {            this.setTitle()        },    },    data() {        return {            invokeCount: 0,            indexTitle: this.$config.indexTitle        }    },    onLoad() {    },    methods: {        setTitle() {            this.invokeCount +=  1        },        gotoChangeTitle() {            //此时，我们不再操作data中的indexTitle，而是操作computed中的title属性            this.title = `啦啦啦${Date.now()}`        }    }}&lt;/script&gt;</code></pre><h3 id="使用全局变量进行状态管理"><a href="#使用全局变量进行状态管理" class="headerlink" title="使用全局变量进行状态管理"></a>使用全局变量进行状态管理</h3><p>如果业务简单,可以考虑不使用vuex.而只是使用全局变量.但是如果使用全局变量的话,为了及时更新状态,你在同一个页面时,如果一个值得状态发生了改变,你需要更新本页面的多处状态,可以考虑使用watch来监听数据的改变.关于watch的使用,我会在下面讲到.如果是多个页面,那么你的状态更新为了保证及时和正确性,需要放在onshow()方法里面,每次执行onshow方法时重新赋值,为了避免不必要的性能开销,可以配合computed来使用.</p><p>现在,我们有2个页面index和home,两者都需要使用一个全局变量indexTitle,两个测试页面的代码基本一致,为了读者的易读,就把两个页面的完整代码粘贴出来:</p><pre><code>&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;view class=&quot;text-area&quot;&gt;&lt;text class=&quot;title&quot;&gt;我是index页面&lt;/text&gt;&lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{ title }}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{ desc }}&lt;/text&gt;        &lt;/view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;gotoChangeTitle&quot;&gt;index页面更新title&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default {    computed: {        title:{            get() {                // 使用data中的indexTitle                return this.indexTitle            },            set (value) {                // 更改title后，也需要将indexTitle和全局值做更改                this.indexTitle = value                this.$config.indexTitle = value            }        },        desc() {            return `我被调用了${this.invokeCount}次`        }    },    watch: {        title(newValue, oldValue) {            console.log(&#39;index----watch---title被调用了&#39;)            this.setTitle()        },    },    data() {        return {            invokeCount: 0,            indexTitle: &#39;&#39;        }    },    onLoad() {    },    onShow() {        console.log(&#39;onShow被调用了&#39;)        this.title = this.$config.indexTitle    },    methods: {        setTitle() {            this.invokeCount +=  1        },        gotoChangeTitle() {            //此时，我们不再操作data中的indexTitle，而是操作computed中的title属性            this.title = `啦啦啦${Date.now()}`        }    }}&lt;/script&gt;&lt;style&gt;.content {    display: flex;    flex-direction: column;    align-items: center;    justify-content: center;}.text-area {    display: flex;    justify-content: center;}.title {    font-size: 36rpx;    color: #8f8f94;}&lt;/style&gt;</code></pre><pre><code>&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;view class=&quot;text-area&quot;&gt;&lt;text class=&quot;title&quot;&gt;我是home页面&lt;/text&gt;&lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{ title }}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{ desc }}&lt;/text&gt;        &lt;/view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;gotoChangeTitle&quot;&gt;home页面更新title&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default {    computed: {        title: {            get() {                // 使用data中的indexTitle                return this.indexTitle            },            set(value) {                // 更改title后，也需要将indexTitle和全局值做更改                this.indexTitle = value                this.$config.indexTitle = value            }        },        desc() {            return `我被调用了${this.invokeCount}次`        }    },    watch: {        title(newValue, oldValue) {            this.setTitle()        }    },    data() {        return {            invokeCount: 0,            indexTitle: &#39;&#39;        }    },    onLoad() {    },    onShow() {        this.title = this.$config.indexTitle    },    methods: {        setTitle() {            this.invokeCount += 1        },        gotoChangeTitle() {            //此时，我们不再操作data中的indexTitle，而是操作computed中的title属性            this.title = `啦啦啦${Date.now()}`        }    }}&lt;/script&gt;&lt;style&gt;.content {    display: flex;    flex-direction: column;    align-items: center;    justify-content: center;}.text-area {    display: flex;    justify-content: center;}.title {    font-size: 36rpx;    color: #8f8f94;}&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift中Realm和objectbox的使用总结</title>
      <link href="/2019/11/23/2019-11-23-swift-zhong-realm-he-objectbox-de-shi-yong-zong-jie/"/>
      <url>/2019/11/23/2019-11-23-swift-zhong-realm-he-objectbox-de-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="objectBox"><a href="#objectBox" class="headerlink" title="objectBox"></a>objectBox</h2><p>objectbox的优点请看官方的介绍。objectBox有各个语言版本。之前做Android项目的时候接触过objectBox的Java版本和Kotlin版本，处于“一招鲜吃遍天”的无耻想法，就一直关注着swift版本。终于，在19年的9月底更新了1.0版本。现在更新到1.1.1版本。现在就跟着<a href="https://swift.objectbox.io/install" target="_blank" rel="noopener">官方文档</a>尝试下swift的版本。</p><p>今天在测试使用objectbox过程中，我遇到了一个问题如下图,当时死磕认为是自己xcode的swift版本与objectbox-swift版本之间的问题。原因是objectbox最新版本使用的swift版本为swift5.1+，但是在xcode的build setting中没有单独罗列出5.1的版本，只有一个大版本5，当时就怀疑是自己没有配置好，还傻傻的给人家提了个issue（哈哈哈~）：</p><p><img src="https://note.youdao.com/yws/public/resource/b3da4a5ccb160d519b7bfc579842626c/xmlnote/WEBRESOURCEc7fefdd45c061eac5036433ea3ca73c8/29047" alt="error"></p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>首先，我们要排除是swift版本问题。既然xcode并没有细分出swift5.1，那么我们就使用命令行来查看：</p><pre><code>xcrun swift -version    //查看swift版本</code></pre><p>看来不是swift版本问题：</p><pre><code>~ » xcrun swift -version                                leg@liuerguaideMac-miniApple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9)Target: x86_64-apple-darwin19.0.0</code></pre><p>然后，经过stackoverflow，我怀疑是cocoapods的问题，然后开始尝试：</p><pre><code>sudo gem install cocoapods-deintegrate cocoapods-clean   //安装依赖</code></pre><pre><code>~/Desktop/DLL/MyDesktop/iOS/DataBaseTest(master*) » sudo gem install cocoapods-deintegrate cocoapods-cleanPassword:Successfully installed cocoapods-deintegrate-1.0.4Parsing documentation for cocoapods-deintegrate-1.0.4Done installing documentation for cocoapods-deintegrate after 0 secondsFetching cocoapods-clean-0.0.1.gemSuccessfully installed cocoapods-clean-0.0.1Parsing documentation for cocoapods-clean-0.0.1Installing ri documentation for cocoapods-clean-0.0.1Done installing documentation for cocoapods-clean after 0 seconds2 gems installed</code></pre><p>删除cocoapods的依赖库：</p><pre><code>pod deintegratepod clean</code></pre><p>最后再重新安装：</p><pre><code>pod install</code></pre><p>通过重新安装objectbox的依赖，问题得到解决。</p><h3 id="ObjectBox-swift的使用"><a href="#ObjectBox-swift的使用" class="headerlink" title="ObjectBox-swift的使用"></a>ObjectBox-swift的使用</h3><p>安装:</p><pre><code>pod &#39;ObjectBox&#39;pod install --repo-updatePods/ObjectBox/setup.rb</code></pre><p>在xcode中，在Building Seeting中将Enable Bitcode更改为NO。</p><p>objectbox的简单使用：</p><pre class=" language-swift"><code class="language-swift">    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">insertByBox</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> textFBox<span class="token punctuation">.</span>text<span class="token operator">?</span><span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        spinner<span class="token punctuation">.</span><span class="token function">startAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970        <span class="token keyword">let</span> <span class="token builtin">count</span> <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>textFBox<span class="token punctuation">.</span>text<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">!</span>        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span>group<span class="token punctuation">:</span> group<span class="token punctuation">,</span> execute<span class="token punctuation">:</span> <span class="token builtin">DispatchWorkItem</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>block<span class="token punctuation">:</span> <span class="token punctuation">{</span>            autoreleasepool <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//批量插入操作</span>                <span class="token keyword">let</span> productEnities<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">ProductEntity</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ProductEntity</span> <span class="token keyword">in</span>                    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">initProudcutEnityData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token keyword">try</span><span class="token operator">!</span> <span class="token keyword">self</span><span class="token punctuation">.</span>store<span class="token operator">?</span><span class="token punctuation">.</span>runInTransaction <span class="token punctuation">{</span>                    <span class="token keyword">let</span> productEnityBox <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>store<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token builtin">ProductEntity</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span>                    <span class="token keyword">try</span><span class="token operator">?</span> productEnityBox<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>productEnities<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>spinner<span class="token punctuation">.</span><span class="token function">stopAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970            <span class="token keyword">self</span><span class="token punctuation">.</span>descBox<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"插入耗时:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">readByBox</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        spinner<span class="token punctuation">.</span><span class="token function">startAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span>group<span class="token punctuation">:</span> group<span class="token punctuation">,</span> execute<span class="token punctuation">:</span> <span class="token builtin">DispatchWorkItem</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>block<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> productEnityBox <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>store<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token builtin">ProductEntity</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> productEnityBox<span class="token operator">?</span><span class="token punctuation">.</span>query <span class="token punctuation">{</span>                <span class="token builtin">ProductEntity</span><span class="token punctuation">.</span>prdouctPrice<span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token string">"1000"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token keyword">let</span> result <span class="token operator">=</span> result <span class="token punctuation">{</span>                <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span>                <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token operator">?</span><span class="token punctuation">.</span>description <span class="token keyword">as</span> <span class="token builtin">Any</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>spinner<span class="token punctuation">.</span><span class="token function">stopAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970            <span class="token keyword">self</span><span class="token punctuation">.</span>descBox<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"读取耗时:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">clearBox</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        spinner<span class="token punctuation">.</span><span class="token function">startAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span>group<span class="token punctuation">:</span> group<span class="token punctuation">,</span> execute<span class="token punctuation">:</span> <span class="token builtin">DispatchWorkItem</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>block<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> productEnityBox <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>store<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token builtin">ProductEntity</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> <span class="token number">_</span> <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> productEnityBox<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>spinner<span class="token punctuation">.</span><span class="token function">stopAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970            <span class="token keyword">self</span><span class="token punctuation">.</span>descBox<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"清空耗时:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">initProudcutEnityData</span><span class="token punctuation">(</span><span class="token number">_</span> index<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ProductEntity</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token function">ProductEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        product<span class="token punctuation">.</span>prdouctName <span class="token operator">=</span> <span class="token string">"香蕉"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>        product<span class="token punctuation">.</span>prdouctID <span class="token operator">=</span> <span class="token string">"1"</span>        product<span class="token punctuation">.</span>prdouctDes <span class="token operator">=</span> <span class="token string">"来自菲律宾的香蕉"</span>        product<span class="token punctuation">.</span>prdouctPrice <span class="token operator">=</span> <span class="token function">NSString</span><span class="token punctuation">(</span>format<span class="token punctuation">:</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">String</span>        product<span class="token punctuation">.</span>prdouctUom <span class="token operator">=</span> <span class="token string">"KG"</span>        product<span class="token punctuation">.</span>prdouctCategory <span class="token operator">=</span> <span class="token string">"进口"</span>        <span class="token keyword">return</span> product    <span class="token punctuation">}</span></code></pre><h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><p><a href="https://realm.io/" target="_blank" rel="noopener">Realm</a>同样是一个跨平台的移动数据库引擎，支持swift、Java、Object-C、JavaScript三个常见语言，具体特性请移步到官网查看。</p><h3 id="cocoapods安装"><a href="#cocoapods安装" class="headerlink" title="cocoapods安装"></a>cocoapods安装</h3><pre><code>pod &#39;RealmSwift&#39;</code></pre><p>为了调试方便，你可以安装官方推荐的调试工具<a href="https://realm.io/products/realm-studio/" target="_blank" rel="noopener">Realm Studio</a>。</p><h3 id="常用类介绍"><a href="#常用类介绍" class="headerlink" title="常用类介绍"></a>常用类介绍</h3><h4 id="Realms"><a href="#Realms" class="headerlink" title="Realms"></a>Realms</h4><p>一个Realm就是一个数据库容器的实例。我们可以简单的初始化一个实例对象：</p><pre><code>let realm = try! Realm()try! realm.write {    realm.add(myDog)}</code></pre><blockquote><p>使用Realm()这种方式初始化，默认会在Document文件夹下创建一个名叫default.realm的文件。所以，你在多个地方使用Realm()这种方式初始化来获取实例，实际上是操作的同一个数据库实例。</p></blockquote><p>但是，如果你要做本地持久化的时候如果考虑用户切换的情况的话，就需要手动配置下：</p><pre><code>func setDefaultRealmForUser(username: String) {    var config = Realm.Configuration()    config.fileURL = config.fileURL!.deletingLastPathComponent().appendingPathComponent(&quot;\(username).realm&quot;)    Realm.Configuration.defaultConfiguration = config}</code></pre><p>你还可以控制Realm的版本，存储位置，是否可写入等：</p><pre><code>let config = Realm.Configuration(    // 获取Bundle    fileURL: Bundle.main.url(forResource: &quot;MyBundledData&quot;, withExtension: &quot;realm&quot;),    // 配置只可以读取，不能写入的权限    readOnly: true)let realm = try! Realm(configuration: config)// 只能做读取的操作let results = realm.objects(Dog.self).filter(&quot;age &gt; 5&quot;)</code></pre><p>如果你只是希望在本次APP启动后，将数据临时存储到内存中，那么你可以使用以下方式：</p><pre><code>let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: &quot;MyInMemoryRealm&quot;))</code></pre><blockquote><p>在内存中使用Realm除了不会保存数据到本地外，Realm其他的功能均可以正常使用。如果你的数据不需要在本地持久化，那么可以选择这种在内存中临时使用的方式。但是，由于数据作用域的问题，你需要使用强引用来保证Realm实例的存在，否则Realm有可能被销毁掉，从而导致数据的丢失。</p></blockquote><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>像其他的I/O操作一样，常见Realm实例时有可能会因为资源受限而失败。不过不需要过多担心，实际上这种实例化失败只会发生在第一次你实例化时，所以你可以使用swift的异常处理机制：</p><pre><code>do {    let realm = try Realm()} catch let error as NSError {    // 处理错误}</code></pre><h3 id="压缩Realm文件"><a href="#压缩Realm文件" class="headerlink" title="压缩Realm文件"></a>压缩Realm文件</h3><p>Realm存储其文件所占的大小总是要比你想要存储的对象的实际大小要大，原因在于其内部的实现机制，你可以看<a href="https://realm.io/docs/swift/latest/#threading" target="_blank" rel="noopener">官方文档</a>对于线程相关的解释。为了避免对系统的额外开销,Realm很少在运行时对其文件进行压缩,取而代之的方式是它们以特定的大小增量增长，新数据被写入被跟踪文件内的未使用空间中。这样就可能出现在Realm文件中存在很大一部分未使用空间的情况.为了解决这种情况,你可以通过配置,选择在第一次打开Realm的时候进行压缩:</p><pre><code>let config = Realm.Configuration(shouldCompactOnLaunch: { totalBytes, usedBytes in    // totalBytes refers to the size of the file on disk in bytes (data + free space)    // usedBytes refers to the number of bytes used by data in the file    // Compact if the file is over 100MB in size and less than 50% &#39;used&#39;    let oneHundredMB = 100 * 1024 * 1024    return (totalBytes &gt; oneHundredMB) &amp;&amp; (Double(usedBytes) / Double(totalBytes)) &lt; 0.5})do {    // Realm is compacted on the first open if the configuration block conditions were met.    let realm = try Realm(configuration: config)} catch {    // handle error compacting or opening Realm}</code></pre><blockquote><p>注意:压缩操作的工作方式是读取Realm文件的全部内容，将其重写到其他位置的新文件中，然后替换原始文件。如果文件中的数据量巨大，这可能是一项开销很大的操作。并且，如果另一个进程正在访问Realm，即使满足配置的条件，也将跳过压缩。这是因为在访问Realm时无法安全地执行压缩。</p></blockquote><p>realm的简单使用：</p><pre class=" language-swift"><code class="language-swift">    <span class="token keyword">func</span> <span class="token function">initProudcutData</span><span class="token punctuation">(</span><span class="token number">_</span> index<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Product</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token function">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        product<span class="token punctuation">.</span>prdouctName <span class="token operator">=</span> <span class="token string">"香蕉"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>        product<span class="token punctuation">.</span>prdouctID <span class="token operator">=</span> <span class="token string">"1"</span>        product<span class="token punctuation">.</span>prdouctDes <span class="token operator">=</span> <span class="token string">"来自菲律宾的香蕉"</span>        product<span class="token punctuation">.</span>prdouctPrice <span class="token operator">=</span> <span class="token function">NSString</span><span class="token punctuation">(</span>format<span class="token punctuation">:</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">String</span>        product<span class="token punctuation">.</span>prdouctUom <span class="token operator">=</span> <span class="token string">"KG"</span>        product<span class="token punctuation">.</span>prdouctCategory <span class="token operator">=</span> <span class="token string">"进口"</span>        <span class="token keyword">return</span> product    <span class="token punctuation">}</span>    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">clearData</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        spinner<span class="token punctuation">.</span><span class="token function">startAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span>group<span class="token punctuation">:</span> group<span class="token punctuation">,</span> execute<span class="token punctuation">:</span> <span class="token builtin">DispatchWorkItem</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>block<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> realm <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">!</span> <span class="token function">Realm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">try</span><span class="token operator">!</span> realm<span class="token punctuation">.</span>write <span class="token punctuation">{</span>                realm<span class="token punctuation">.</span><span class="token function">deleteAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>spinner<span class="token punctuation">.</span><span class="token function">stopAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970            <span class="token keyword">self</span><span class="token punctuation">.</span>desc<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"清空耗时:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">insertData</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> textF<span class="token punctuation">.</span>text<span class="token operator">?</span><span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        spinner<span class="token punctuation">.</span><span class="token function">startAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970        <span class="token keyword">let</span> <span class="token builtin">count</span> <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>textF<span class="token punctuation">.</span>text<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">!</span>        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span>group<span class="token punctuation">:</span> group<span class="token punctuation">,</span> execute<span class="token punctuation">:</span> <span class="token builtin">DispatchWorkItem</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>block<span class="token punctuation">:</span> <span class="token punctuation">{</span>            autoreleasepool <span class="token punctuation">{</span>                <span class="token keyword">var</span> productArray<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Product</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>                    productArray<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">initProudcutData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>                <span class="token keyword">let</span> realm <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">!</span> <span class="token function">Realm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                realm<span class="token punctuation">.</span><span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                realm<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>productArray<span class="token punctuation">)</span>                <span class="token keyword">try</span><span class="token operator">!</span> realm<span class="token punctuation">.</span><span class="token function">commitWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>spinner<span class="token punctuation">.</span><span class="token function">stopAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970            <span class="token keyword">self</span><span class="token punctuation">.</span>desc<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"插入耗时:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">readData</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        spinner<span class="token punctuation">.</span><span class="token function">startAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token function">global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span>group<span class="token punctuation">:</span> group<span class="token punctuation">,</span> execute<span class="token punctuation">:</span> <span class="token builtin">DispatchWorkItem</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>block<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> realm <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">!</span> <span class="token function">Realm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> result <span class="token operator">=</span> realm<span class="token punctuation">.</span><span class="token function">objects</span><span class="token punctuation">(</span><span class="token builtin">Product</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token string">"prdouctPrice='1000'"</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token builtin">first</span><span class="token operator">?</span><span class="token punctuation">.</span>description <span class="token keyword">as</span> <span class="token builtin">Any</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>spinner<span class="token punctuation">.</span><span class="token function">stopAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeIntervalSince1970            <span class="token keyword">self</span><span class="token punctuation">.</span>desc<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"读取耗时:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>这个是<a href="https://github.com/smileasy/Realm-ObjectBox.git" target="_blank" rel="noopener">Demo</a>的下载地址。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> 总结提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在uni-app中自定义组件与插件</title>
      <link href="/2019/11/21/2019-11-21-zai-uni-app-zhong-zi-ding-yi-cha-jian/"/>
      <url>/2019/11/21/2019-11-21-zai-uni-app-zhong-zi-ding-yi-cha-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在Vue的开发中，我们为了使代码能有更好的复用性，在开发阶段将具有相似业务的模块功能抽取成<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a>。而对于<a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">插件</a>而言，则是通常用来为 Vue 添加全局功能。像我们使用的<a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">vue-router</a>,就是一个插件。为了演示组件和插件的用法，我会在uni-app中自定义一个Toast来演示开发流程。</p><p>我们知道，在uni-app中已经封装了toast的插件：</p><pre><code>uni.showToast({                    title: &#39;我是一个Toast！&#39;                });</code></pre><h4 id="将toast封装成一个组件"><a href="#将toast封装成一个组件" class="headerlink" title="将toast封装成一个组件"></a>将toast封装成一个组件</h4><p>我们创建一个叫做LXToast的vue文件,然后设置显示的内容message，超时时间timeOut和是否展示的show。这里，我们为了实现props的“双向绑定”，我们在父组件中使用了.sync修饰符，在子组件中通过<code>this.$emit(&#39;update:show&#39;, false)</code>的方式来更改父组件的状态：</p><pre><code>&lt;template v-if=&quot;isShowing&quot;&gt;    &lt;view class=&quot;toast&quot;&gt;        &lt;view class=&quot;content&quot;&gt;{{message}}&lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: &#39;LXToast&#39;,        props: {            message: {                type: String,                default: &#39;&#39;            },            timeOut: {                type: Number,                default: 2000             },            show: {                type: Boolean,                default: false            }        },        computed: {            isShowing() {                return this.show            }        },        created() {            setTimeout(() =&gt; {                this.$emit(&#39;update:show&#39;, false)            }, this.timeOut)        }    }&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;    .toast {        &gt;.content {            position: fixed;            top: 50%;            left: 50%;            transform: translate(-50%, -50%);            padding: 10upx 12upx;            background-color: rgba($color: #000000, $alpha: 0.7);            border-radius: 4upx;            color: #FFFFFF;            font: 100upx;        }    }&lt;/style&gt;</code></pre><p>然后我们在模块中使用这个组件。首先，我们需要先引入这个组件，然后设置相关的属性，这里我们点击hello文字，就可以弹出toast（其他的代码乃是创建项目生成的，请读者不要产生迷惑）：</p><pre><code>&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;image class=&quot;logo&quot; src=&quot;/static/logo.png&quot;&gt;&lt;/image&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot; @click=&quot;clickTitle&quot;&gt;{{title}}&lt;/text&gt;        &lt;/view&gt;        &lt;LXToast         v-if=&#39;show&#39;        :message=&#39;77777777777&#39;        :show.sync=&#39;show&#39;        :timeOut=&#39;timeOut&#39;&gt;&lt;/LXToast&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import LXToast from &#39;../../components/common/LXToast/LXToast.vue&#39;;    export default {        data() {            return {                title: &#39;Hello&#39;,                show: false,                timeOut: 1000            }        },        components: {//引入组件            LXToast        },        onLoad() {        },        methods: {            clickTitle() {                this.show = true             }        }    }&lt;/script&gt;&lt;style&gt;    .content {        display: flex;        flex-direction: column;        align-items: center;        justify-content: center;    }    .logo {        height: 200rpx;        width: 200rpx;        margin-top: 200rpx;        margin-left: auto;        margin-right: auto;        margin-bottom: 50rpx;    }    .text-area {        display: flex;        justify-content: center;    }    .title {        font-size: 36rpx;        color: #8f8f94;    }&lt;/style&gt;</code></pre><blockquote><p>上面演示的就是我们定义一个组件的基本流程。为了使子组件展示我们需要的内容，我们需要在组件中通过【：属性】的方式将值传递给子组件。同时呢，我们呢还需要子组件可以更改父组件的状态（通常我们不建议这么做），使用了sync语法糖的方式。</p></blockquote><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在uni-app中使用Vuex</title>
      <link href="/2019/10/17/2019-10-17-zai-uni-app-zhong-shi-yong-vuex/"/>
      <url>/2019/10/17/2019-10-17-zai-uni-app-zhong-shi-yong-vuex/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="引入vuex"><a href="#引入vuex" class="headerlink" title="引入vuex"></a>引入vuex</h4><p>uni-app已经内置了vuex，我们可以直接引入使用。<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a></p><h3 id="state的使用"><a href="#state的使用" class="headerlink" title="state的使用"></a>state的使用</h3><p>我们按照大型项目中的实际需求，将不同模块的状态管理划分为不同的module。例如我们有2个模块home和user，将home和user模块引入到index中（此处只是分步骤讲解，可以直接下载Demo）。</p><p>此时我们在home模块中定义state：</p><pre><code>    state: {        homeCount: 123,        homeName: &#39;刘德华&#39;    }</code></pre><p>我们想要在场景中获取内容：</p><pre><code>//普通方式获取模块home中的homeName的内容console.log(this.$store.state.home.homeName)</code></pre><p>通过辅助函数mapState获取（同时还可以重新命名变量）：</p><pre><code>            ...mapState( {                    // 映射 this.myCount 为 this.$store.state.home.homeCount                    myCount: state =&gt; state.home.homeCount,                    myName: state =&gt; state.home.homeName                }),</code></pre><h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><p>Getters可以认为是 store 的计算属性。我的理解是相当于computed的角色。</p><p>此时我们在home模块中定义getters：</p><pre><code>    getters: { //（可以认为是 store 的计算属性）        homeCountPower: state =&gt; state.homeCount * state.homeCount,        homeNameDesc: state =&gt; state.homeName + &#39;长得真帅啊&#39;,    },</code></pre><p>我们想要在场景中获取内容：</p><pre><code>// 获取getters的内容 console.log(this.$store.getters.homeNameDesc) //error:注意此处不能通过.home.getters，而是直接.getters // console.log(this.$store.home.getters.homeNameDesc)</code></pre><p>通过辅助函数mapGetters获取（同时还可以重新命名变量）：</p><pre><code>            ...mapGetters(                 {                    countPower: &#39;homeCountPower&#39;,                    nameDesc: &#39;homeNameDesc&#39;                }            ),</code></pre><p>当然，我们也可以不通过getters来在对应的模块来组织内容，我们可以根据实际需要，直接在computed中来更改内容也是可以的：</p><pre><code>        computed: {            homeCount() {                return this.$store.state.home.homeCount + &#39;KG&#39;            },            }</code></pre><p> getters中的函数是可以相互调用的：</p><pre><code>    getters: { //（可以认为是 store 的计算属性）        homeCountPower: state =&gt; state.homeCount * state.homeCount,        homeNameDesc: state =&gt; state.homeName + &#39;长得真帅啊&#39;,        homeInfo: (state, getters) =&gt; {            //假如是复杂的处理逻辑，可以用上面的简便写法            return &#39;明星&#39; + getters.homeNameDesc + &#39;!!!!!!!&#39;        }     },</code></pre><p>在主页中使用homeInfo：</p><pre><code>//如果不更改getters中原有的名字，可以直接传一个数组            ...mapGetters(                 [&#39;homeInfo&#39;]            ),</code></pre><p> getters中的函数也是可以传递参数的。假如现在我需要动态给homeCount进行更改，需要这要做：</p><pre><code>        editHomeCount: (state) =&gt; {//动态更改homeCount            return (data) =&gt; {                return state.homeCount + data             }        } </code></pre><pre><code>            //如果不更改getters中原有的名字，可以直接传一个数组            ...mapGetters(                 [&#39;homeInfo&#39;, &#39;editHomeCount&#39;]            ),</code></pre><pre><code>        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{homeInfo}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{editHomeCount(1000)}}&lt;/text&gt;        &lt;/view&gt;</code></pre><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。言下之意就是我们规范的修改store中的变量只能通过commit的 方式。</p><pre><code>    mutations: {        [ADD](state, num) {            state.homeCount += num        },        [MIN](state, num) {            state.homeCount -= num        }    },</code></pre><blockquote><p>ADD 和MIN是通过export导出的常量。根据ES6的语法，来替代函数名称。</p></blockquote><p>使用辅助函数mapMutations： </p><pre><code>            //方式1：直接使用            ...mapMutations(                [ADD, MIN],            ),            //方式2： 重新命名            ...mapMutations( {                addAmount: ADD,                minAmount: MIN            }),</code></pre><p>此时我们呢用2个按钮来定义点击事件：</p><pre><code>&lt;button type=&quot;primary&quot; @click=&quot;add(1000)&quot;&gt;增加&lt;/button&gt;&lt;button type=&quot;primary&quot; @click=&quot;min(2000)&quot;&gt;减小&lt;/button&gt;</code></pre><p>我们有3种方式来调用mutations的函数：</p><pre><code>            add(data) {                //方式1：                this.ADD(data)                //方式2：                // this.addAmount(data)                //方式3：直接通过commit方式提交                // this.$store.commit(ADD, data)            },            min(data) {                this.MIN(data)                // this.minAmount(data)                // this.$store.commit(MIN, data)            },</code></pre><p>如果我们传给mutations中函数的参数比较复杂呢？我们在state中增加一个数组：</p><pre><code>        homeGoods: [{                goodsId: 100,                goodsName: &#39;番茄&#39;,                goodsPrice: 22            },            {                goodsId: 100,                goodsName: &#39;土豆&#39;,                goodsPrice: 44            }        ]</code></pre><p>mutations中增加一个添加商品的函数：</p><pre><code>        addGoods(state, playload) {//增加一个商品            //方式1和2的方式：            // state.homeGoods.push(playload)            //方式3：            state.homeGoods.push(playload.data)        }</code></pre><pre><code>&lt;button type=&quot;primary&quot; @click=&quot;addMoreGoods&quot;&gt;增加一个商品&lt;/button&gt;            addMoreGoods() {                let goods = {                    goodsId: 100,                    goodsName: &#39;榴莲&#39;,                    goodsPrice: 150                }                //方式1：                // this.addGoods(goods)                //方式2：                // this.$store.commit(&#39;addGoods&#39;, goods)                //方式3：（需要更改mutations中的取参数的方式）                this.$store.commit({                    type: &#39;addGoods&#39;,                    data: goods                 })                console.log(this.$store.state.home.homeGoods)            },</code></pre><h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><blockquote><p>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。</p></blockquote><p>action是用来针对异步操作的。有的人会把网络请求在action中实现，然后在页面中直接调用。页面的代码会减少很多。</p><pre><code>    actions: {        requestListData(context) {            let goods = {                goodsId: 120,                goodsName: &#39;西瓜&#39;,                goodsPrice: 66            }            // 模拟异步操作            setTimeout(() =&gt; {                context.commit({                    type: &#39;addGoods&#39;,                    data: goods                 })            },2000)        }    }</code></pre><p>在页面中使用：</p><pre><code>&lt;button type=&quot;primary&quot; @click=&quot;asyncAddMoreGoods&quot;&gt;异步增加一个商品&lt;/button&gt;            ...mapActions({                requestData: &#39;requestListData&#39;            }),            asyncAddMoreGoods() {                //方式1：                // this.requestData()                // 方式2:                this.$store.dispatch(&#39;requestListData&#39;)            },</code></pre><p>有的时候需要异步增加结果回调，我们可以这样：</p><pre><code>actions: {            requestHomeInfo(context,playload) {            // 模拟异步操作            setTimeout(() =&gt; {                context.commit(&#39;addOneGoods&#39;,playload.data)                playload.callback(&#39;添加成功了。。&#39;)            },2000)        }}</code></pre><p>在页面中使用callback回调：</p><pre><code>&lt;button type=&quot;primary&quot; @click=&quot;asyncCallback&quot;&gt;异步增加商品回调&lt;/button&gt;            asyncCallback() {                //直接使用方式2进行测试：                let goods = {                    goodsId: 199,                    goodsName: &#39;圣女果&#39;,                    goodsPrice: 177                }                this.$store.dispatch(&#39;requestHomeInfo&#39;, {                    data: goods,                    callback: (res) =&gt; {                        console.log(res)                    }                })            },</code></pre><p>使用promise来实现：</p><pre><code>actions: {            requestPromiseInfo(context, playload) {            return new Promise((resolve, reject) =&gt; {                // 模拟异步操作                setTimeout(() =&gt; {                    context.commit(&#39;addOneGoods&#39;,playload)                    resolve(&#39;Promise添加成功了...&#39;)                },2000)            })        }}</code></pre><pre><code>            asyncPromise() {                //直接使用方式2进行测试：                let goods = {                    goodsId: 911,                    goodsName: &#39;酸奶&#39;,                    goodsPrice: 199                }                this.$store.                        dispatch(&#39;requestPromiseInfo&#39;, goods)                        .then(res =&gt; {                            console.log(res)                        })             },</code></pre><h3 id="在uni-APP中使用Vuex案例"><a href="#在uni-APP中使用Vuex案例" class="headerlink" title="在uni-APP中使用Vuex案例"></a>在uni-APP中使用Vuex案例</h3><h4 id="home-js"><a href="#home-js" class="headerlink" title="home.js"></a>home.js</h4><pre><code>//home.jsimport {    ADD,    MIN} from &#39;../common/const.js&#39;export default {    state: {        homeCount: 123,        homeName: &#39;刘德华&#39;,        homeGoods: [{                goodsId: 100,                goodsName: &#39;番茄&#39;,                goodsPrice: 22            },            {                goodsId: 100,                goodsName: &#39;土豆&#39;,                goodsPrice: 44            }        ]    },    getters: { //（可以认为是 store 的计算属性）        homeCountPower: state =&gt; state.homeCount * state.homeCount,        homeNameDesc: state =&gt; state.homeName + &#39;长得真帅啊&#39;,        homeInfo: (state, getters) =&gt; {            //假如这是复杂的处理逻辑，简单的处理可以用上面的简便写法            return &#39;明星&#39; + getters.homeNameDesc + &#39;!!!!!!!&#39;        },        editHomeCount: (state) =&gt; {//动态更改homeCount            return (data) =&gt; {                return state.homeCount + data             }        }     },    mutations: {        [ADD](state, num) {            state.homeCount += num        },        [MIN](state, num) {            state.homeCount -= num        },        addGoods(state, playload) {//增加一个商品            //方式1和2的方式：            // state.homeGoods.push(playload)            //方式3：            state.homeGoods.push(playload.data)        },        addOneGoods(state, playload) {//增加一个商品            state.homeGoods.push(playload)        },    },    actions: {        requestListData(context) {            let goods = {                goodsId: 120,                goodsName: &#39;西瓜&#39;,                goodsPrice: 66            }            // 模拟异步操作            setTimeout(() =&gt; {                context.commit({                    type: &#39;addGoods&#39;,                    data: goods                 })            },2000)        },        requestHomeInfo(context,playload) {            // 模拟异步操作            setTimeout(() =&gt; {                context.commit(&#39;addOneGoods&#39;,playload.data)                playload.callback(&#39;添加成功了。。&#39;)            },2000)        },        requestPromiseInfo(context, playload) {            return new Promise((resolve, reject) =&gt; {                // 模拟异步操作                setTimeout(() =&gt; {                    context.commit(&#39;addOneGoods&#39;,playload)                    resolve(&#39;Promise添加成功了...&#39;)                },2000)            })        }    }}</code></pre><h4 id="user-js"><a href="#user-js" class="headerlink" title="user.js"></a>user.js</h4><pre><code>import {    USER_NAME,    USER_AGE} from &#39;../common/const.js&#39;export default {    state: {        userAge: 18,        userName: &#39;渣渣辉&#39;    },    getters: {        userAge: state =&gt; state.userAge + &#39;岁！&#39;,        userName: state =&gt; state.userName + &#39;贪玩蓝月！&#39;,    },    mutations: {        [USER_NAME](state, name) {            state.userName = name        },        [USER_AGE](state, age) {            state.userAge = age        }    },    actions: {    }}</code></pre><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import home from&#39;./home.js&#39;import user from&#39;./user.js&#39;Vue.use(Vuex)// home使用了命名空间const store = new Vuex.Store({    modules:{        home,        user     }})export default store</code></pre><h4 id="创建好对应的文件后，我们需要到uni-APP的main文件中进行挂载："><a href="#创建好对应的文件后，我们需要到uni-APP的main文件中进行挂载：" class="headerlink" title="创建好对应的文件后，我们需要到uni-APP的main文件中进行挂载："></a>创建好对应的文件后，我们需要到uni-APP的main文件中进行挂载：</h4><pre><code>iimport Vue from &#39;vue&#39;import App from &#39;./App&#39;// 1.导入import store from &#39;./store&#39;Vue.config.productionTip = falseApp.mpType = &#39;app&#39;const app = new Vue({    ...App,    store})app.$mount()</code></pre><h4 id="在我们需要的vue文件中使用："><a href="#在我们需要的vue文件中使用：" class="headerlink" title="在我们需要的vue文件中使用："></a>在我们需要的vue文件中使用：</h4><blockquote><p>vuex为我们提供了mapState mapMutations mapGetters mapActions等辅助函数。可以根据自己的实际情况来决定是否使用。我将分别演示使用与否的情况。</p></blockquote><p>index.vue</p><pre><code>&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;block v-for=&quot;item in homeGoodsList &quot; :key=&#39;item.goodsId&#39;&gt;                &lt;view&gt;                    &lt;text class=&quot;title&quot;&gt;{{item.goodsId}}&lt;/text&gt;                    &lt;text class=&quot;title&quot;&gt;{{item.goodsName}}&lt;/text&gt;                    &lt;text class=&quot;title&quot;&gt;{{item.goodsPrice}}&lt;/text&gt;                &lt;/view&gt;            &lt;/block&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{myName}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{myCount}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{nameDesc}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{countPower}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{homeInfo}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{editHomeCount(1000)}}&lt;/text&gt;        &lt;/view&gt;        &lt;!-- ***************************************** --&gt;        &lt;view class=&quot;text-area-user&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userName}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area-user&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userAge}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area-user&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userName1}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area-user&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userAge1}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-content&quot;&gt;            &lt;view&gt;                &lt;button type=&quot;primary&quot; @click=&quot;add(1000)&quot;&gt;增加&lt;/button&gt;                &lt;button type=&quot;primary&quot; @click=&quot;min(2000)&quot;&gt;减小&lt;/button&gt;                &lt;button type=&quot;primary&quot; @click=&quot;addMoreGoods&quot;&gt;增加一个商品&lt;/button&gt;                &lt;button type=&quot;primary&quot; @click=&quot;asyncAddMoreGoods&quot;&gt;异步增加一个商品&lt;/button&gt;                &lt;button type=&quot;primary&quot; @click=&quot;asyncCallback&quot;&gt;异步callback增加商品回调&lt;/button&gt;                &lt;button type=&quot;primary&quot; @click=&quot;asyncPromise&quot;&gt;异步promise增加商品回调&lt;/button&gt;                &lt;button type=&quot;warn&quot; @click=&quot;gotoUser&quot;&gt;跳转&lt;/button&gt;                &lt;button type=&quot;warn&quot; @click=&quot;changeName&quot;&gt;改变名字&lt;/button&gt;                &lt;button type=&quot;warn&quot; @click=&quot;changeAge&quot;&gt;改变年龄&lt;/button&gt;            &lt;/view&gt;        &lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import {        ADD,        MIN,        USER_NAME,        USER_AGE    } from &#39;../../common/const.js&#39;;    import {        mapState,        mapMutations,        mapGetters,        mapActions    } from &#39;vuex&#39;;    export default {        data() {            return {            }        },        computed: {            homeCount() {                return this.$store.state.home.homeCount + &#39;KG&#39;            },            ...mapGetters({                countPower: &#39;homeCountPower&#39;,                nameDesc: &#39;homeNameDesc&#39;,            }),            //如果不更改getters中原有的名字，可以直接传一个数组            ...mapGetters(                [&#39;homeInfo&#39;, &#39;editHomeCount&#39;]            ),            ...mapState({                // 映射 this.count 为 this.$store.state.home.homeCount                myCount: state =&gt; state.home.homeCount,                myName: state =&gt; state.home.homeName,                homeGoodsList: state =&gt; state.home.homeGoods            }),            //不使用命名空间的user            userAge() {                return this.$store.state.user.userAge            },            userName() {                return this.$store.state.user.userName            },            userAge1() {                return this.$store.getters.userAge            },            userName1() {                return this.$store.getters.userName            }        },        onLoad() {            //普通方式获取模块home中的homeName的内容            console.log(this.$store.state.home.homeName)            // 获取getters的内容            console.log(this.$store.getters.homeNameDesc)            //error:注意此处不能通过.home.getters，而是直接.getters            // console.log(this.$store.home.getters.homeNameDesc)            // console.log(this.$store.state.user.userAge)            // console.log(this.$store.getters.userName)            // console.log(this.$store.getters.userAge)        },        methods: {            //将this.addAmount(data) 映射为 this.$store.commit(ADD, data)            //将this.minAmount(data) 映射为 this.$store.commit(MIN, data)            //同理，mapActions也可以如此使用            //注： 如果调用名一致，则可以直接使用数组，而不是对象：            //方式1：直接使用            ...mapMutations(                [ADD, MIN],            ),            //方式2： 重新命名            ...mapMutations({                addAmount: ADD,                minAmount: MIN            }),            ...mapMutations(                [&#39;addGoods&#39;]            ),            ...mapActions({                requestData: &#39;requestListData&#39;            }),            asyncPromise() {                //直接使用方式2进行测试：                let goods = {                    goodsId: 911,                    goodsName: &#39;酸奶&#39;,                    goodsPrice: 199                }                this.$store.                        dispatch(&#39;requestPromiseInfo&#39;, goods)                        .then(res =&gt; {                            console.log(res)                        })             },            asyncCallback() {                //直接使用方式2进行测试：                let goods = {                    goodsId: 199,                    goodsName: &#39;圣女果&#39;,                    goodsPrice: 177                }                this.$store.dispatch(&#39;requestHomeInfo&#39;, {                    data: goods,                    callback: (res) =&gt; {                        console.log(res)                    }                })            },            asyncAddMoreGoods() {                //方式1：                // this.requestData()                // 方式2:                this.$store.dispatch(&#39;requestListData&#39;)            },            addMoreGoods() {                let goods = {                    goodsId: 100,                    goodsName: &#39;榴莲&#39;,                    goodsPrice: 150                }                //方式1：                // this.addGoods(goods)                //方式2：                // this.$store.commit(&#39;addGoods&#39;, goods)                //方式3：（需要更改mutations中的取参数的方式）                this.$store.commit({                    type: &#39;addGoods&#39;,                    data: goods                })                console.log(this.$store.state.home.homeGoods)            },            add(data) {                //方式1：                this.ADD(data)                //方式2：                // this.addAmount(data)                //方式3：直接通过commit方式提交                // this.$store.commit(ADD, data)            },            min(data) {                this.MIN(data)                // this.minAmount(data)                // this.$store.commit(MIN, data)            },            gotoUser() {                uni.navigateTo({                    url: &#39;../user/user&#39;,                    success: res =&gt; {},                    fail: () =&gt; {},                    complete: () =&gt; {}                });            },            ...mapMutations({                setUserAge: USER_AGE,                setUserName: USER_NAME            }),            changeAge() {                this.setUserAge(33)            },            changeName() {                this.setUserName(&#39;张家辉&#39;)            }        }    }&lt;/script&gt;&lt;style&gt;    .content {        display: flex;        flex-direction: column;        align-items: center;        justify-content: center;    }    .logo {        height: 200rpx;        width: 200rpx;        margin-top: 200rpx;        margin-left: auto;        margin-right: auto;        margin-bottom: 50rpx;    }    .text-area {        display: flex;        justify-content: center;    }    .text-area-user {        display: flex;        justify-content: center;        background-color: #F0AD4E;    }    .title {        font-size: 36rpx;        color: #8f8f94;    }    .text-content {        width: 100vw;        background: #007AFF;        height: 300upx;    }&lt;/style&gt;</code></pre><p>user.vue</p><pre><code>&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userName}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userAge}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userName1}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-area&quot;&gt;            &lt;text class=&quot;title&quot;&gt;{{userAge1}}&lt;/text&gt;        &lt;/view&gt;        &lt;view class=&quot;text-content&quot;&gt;            &lt;view&gt;                &lt;button type=&quot;warn&quot; @click=&quot;gotoBack&quot;&gt;返回上一页&lt;/button&gt;                &lt;button type=&quot;warn&quot; @click=&quot;changeUserName&quot;&gt;改变名字&lt;/button&gt;                &lt;button type=&quot;warn&quot; @click=&quot;changeUserAge&quot;&gt;改变年龄&lt;/button&gt;            &lt;/view&gt;        &lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import {        USER_NAME,        USER_AGE    } from &#39;../../common/const.js&#39;;    import {        mapState,        mapMutations,        mapGetters,        mapActions    } from &#39;vuex&#39;;    export default {        data() {            return {}        },        computed: {            ...mapState({                userAge1: state =&gt; state.user.userAge + &#39;哈哈哈哈&#39;,                userName1: state =&gt; state.user.userName + &#39;真可爱啊啊啊&#39;            }),            ...mapGetters([                 // 把 `this.userAge` 映射为 `this.$store.getters.userAge`                &quot;userAge&quot;,                &quot;userName&quot;            ])        },        onLoad() {            // 想要获取getters的内容，但是home是使用命名空间来获取的，所以暂时不知道怎么获取            // console.log(this.$store.getters)            console.log(this.$store.state.user.userAge)            console.log(this.$store.state.user.userName)        },        methods: {            ...mapMutations(                [                    USER_NAME, USER_AGE                ]),                changeUserName() {                    this.USER_NAME(&#39;zhangjiahui&#39;)                },                changeUserAge() {                    this.USER_AGE(77)                },                gotoBack() {                    uni.navigateBack({                        delta: 1                    });                }        }    }&lt;/script&gt;&lt;style&gt;    .content {        display: flex;        flex-direction: column;        align-items: center;        justify-content: center;    }    .logo {        height: 200rpx;        width: 200rpx;        margin-top: 200rpx;        margin-left: auto;        margin-right: auto;        margin-bottom: 50rpx;    }    .text-area {        display: flex;        justify-content: center;    }    .title {        font-size: 36rpx;        color: #8f8f94;    }    .text-content {        width: 100vw;        background: #007AFF;        height: 300upx;    }&lt;/style&gt;</code></pre><p><a href="https://github.com/smileasy/vuexDemo" target="_blank" rel="noopener">Demo链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在uni-app中使用微信登录总结</title>
      <link href="/2019/09/01/2019-09-01-zai-uni-app-zhong-shi-yong-wei-xin-deng-lu-zong-jie/"/>
      <url>/2019/09/01/2019-09-01-zai-uni-app-zhong-shi-yong-wei-xin-deng-lu-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="在uni-app中使用微信登录总结"><a href="#在uni-app中使用微信登录总结" class="headerlink" title="在uni-app中使用微信登录总结"></a>在uni-app中使用微信登录总结</h2><p>最近开发了一款使用uni-app框架的小程序，名字叫“花果鲜inside”（因为是针对公司业务的小程序，注册后需要后台审核，所以只能游客浏览哈）。现将开发问题中涉及到的微信授权登录业务总结一下.</p><h3 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h3><p>首先，我们先上<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html" target="_blank" rel="noopener">小程序登录</a>的官方示例图：</p><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg" alt="官方登录流程时序图"></p><blockquote><p>如果你看起这个登录时序图有些懵逼，那么就看我结合业务的实现吧。</p></blockquote><h4 id="登录业务实现"><a href="#登录业务实现" class="headerlink" title="登录业务实现"></a>登录业务实现</h4><p>散配小程序从管家APP中剥离出购物车、订单和我的三个模块。三个模块均设有登录入口。用户启动小程序，从<code>login.vue</code>中触发登录逻辑(部分代码)：</p><pre><code>onLoad(e) {        tip.showLoading()        if (e !== {} &amp;&amp; e.autoLogin ===  &#39;false&#39;) {            //用户点击登录按钮，触发的onload,需要展示登录页面            this.authorizationLogin()        } else {            // 小程序启动的业务处理入口            const storageUserInfo = tool.getUserInfo()            if (storageUserInfo) {                const res = JSON.parse(storageUserInfo)                this.setLoginData(res)                this.$config.open_id = res.open_id            } else {                tip.hideLoading()                this.$store.commit(&#39;setLoginStatus&#39;, false)                this.$router.switchTab(&#39;/pages/order/order&#39;)            }        }    },</code></pre><blockquote><p>考虑到存在用户从不同页面触发login.vue的onload和小程序启动时调用onload两种情况，使用autoLogin来做区别。</p></blockquote><p>用户如果通过点击事件触发，则需要这样传参：</p><pre><code>this.$router.push(&#39;/pages/login/login&#39;, { autoLogin: false })</code></pre><h5 id="启动小程序登录场景"><a href="#启动小程序登录场景" class="headerlink" title="启动小程序登录场景"></a>启动小程序登录场景</h5><p>判断本地是否存储有用户的信息，有的话则会在setLoginData方法中配置全局config对象，并在该方法中请求token。注意，token对后台而言是区分用户是否处于登录的唯一标识。获取成功后，则跳转到首页，完成登录业务流程。</p><p>如果本地没有存储有用户的信息，则直接跳转到首页。如果需要登录，则需要用户后续通过主动点击模块的登录按钮来触发登录业务。</p><h5 id="用户点击登录按钮"><a href="#用户点击登录按钮" class="headerlink" title="用户点击登录按钮"></a>用户点击登录按钮</h5><p>用户从三个模块点击登录时，会 调用<code>login.vue</code>的onload中的authorizationLogin方法，通过authorizationLogin来实现登录业务。</p><p>首先，我们去获取用户信息,我采取的是先调用<code>uni.login</code>，后通过<code>uni.getSetting</code>来判断用户是否权限的方式。当然，你也可以先通过<code>uni.getSetting</code>判断权限后调用<code>uni.login</code>。</p><pre><code>        authorizationLogin() {            uni.login({                provider: &#39;weixin&#39;,                success: res =&gt; {                    this.code = res.code                    uni.getSetting({                        success: (result) =&gt; {                            tip.hideLoading()                            if (result.authSetting[&#39;scope.userInfo&#39;]) {                                this.getWxUserInfo()                            } else {                                this.needAuth = true                            }                        },                        fail: () =&gt; {                            this.needAuth = true                        }                    })                }            })        },</code></pre><blockquote><p>由于拉取用户信息需要用户授权，并且只能通过button来触发获取，所以需要通过<code>uni.getSetting</code>来判断。</p></blockquote><p>授权按钮：</p><pre><code>&lt;button open-type=&quot;getUserInfo&quot; @getuserinfo=&quot;getuserinfoCallback&quot; class=&quot;auth&quot; v-if=&quot;needAuth&quot;&gt;授权登录&lt;/button&gt;</code></pre><p>正常场景，拿到用户信息，调用readyWxAuth方法，该方法会请求自己后台的接口：</p><pre><code>        // 后台做判断        readyWxAuth(res) {            this.$api                .readyWxAuth({                    code: this.code,                    userInfo: JSON.stringify(res.userInfo)                })                .then(res =&gt; {                    tip.hideLoading()                    this.open_id = res.open_id                    this.$config.open_id = res.open_id                    if (res.user_info === undefined) {                        //说明是新的用户，弹出登录框，绑定用户                        this.canAutoLogin = false                    } else {                        //不是新用户，存储用户信息，设置全局变量                        tool.saveUserInfo(res)                        this.setLoginData(res)                    }                })        }</code></pre><blockquote><p>需要将我们通过uni.login拿到的code和通过用户授权的信息传给自己的后台，后台判断该用户是否为新用户，是新用户（res.user_info === undefined）的话，执行注册相关的逻辑，注册成功，则后续可以执行登录操作。不是的话，将后台返回的信息存储到本地，设置全局信息config，完成登录业务。</p></blockquote><p>如果你看的不是很明白，那么我就将登录页面代码给大家粘贴出来：</p><pre><code>&lt;template&gt;    &lt;view class=&quot;container&quot;&gt;        &lt;div class=&quot;login_page&quot; v-if=&quot;!canAutoLogin&quot;&gt;            &lt;view class=&quot;content&quot;&gt;                &lt;view class=&quot;item&quot;&gt;                    &lt;text class=&quot;title&quot;&gt;账号&lt;/text&gt;                    &lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;account&quot; /&gt;                &lt;/view&gt;                &lt;view class=&quot;item&quot;&gt;                    &lt;text class=&quot;title&quot;&gt;密码&lt;/text&gt;                    &lt;input class=&quot;input&quot; type=&quot;text&quot; password placeholder=&quot;请输入密码&quot; v-model=&quot;password&quot; /&gt;                &lt;/view&gt;            &lt;/view&gt;            &lt;view class=&quot;login&quot; @click=&quot;login&quot;&gt;登录&lt;/view&gt;            &lt;view class=&quot;option&quot;&gt;                &lt;navigator class=&quot;change-password&quot; url=&quot;/pages/login/register&quot;&gt;注册&lt;/navigator&gt;                &lt;navigator class=&quot;change-password&quot; url=&quot;/pages/login/changePassword&quot;&gt;忘记密码?&lt;/navigator&gt;            &lt;/view&gt;            &lt;view class=&quot;version&quot;&gt;当前版本:{{ version }}&lt;/view&gt;        &lt;/div&gt;        &lt;button open-type=&quot;getUserInfo&quot; @getuserinfo=&quot;getuserinfoCallback&quot; class=&quot;auth&quot; v-if=&quot;needAuth&quot;&gt;授权登录&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import tip from &#39;../../util/tips.js&#39;import tool from &#39;../../util/tool.js&#39;import md5 from &#39;../../util/md5.min.js&#39;import { RECENT_SELECTED_STORE } from &#39;../../util/storage.js&#39;export default {    data() {        return {            account: &#39;&#39;,            password: &#39;&#39;,            version: &#39;&#39;,            open_id: &#39;&#39;,            code: &#39;&#39;,            canAutoLogin: true, // wx启动后，检测能否自动登录（默认可以），如果不能自动登录，则需要显示展示订货首页            needAuth: false //如果登录过期，则需要置为true，显示授权登录按钮        }    },    onLoad(e) {        this.$config.needRefresh = true        tip.showLoading()        if (e !== {} &amp;&amp; e.autoLogin ===  &#39;false&#39;) {            //用户点击登录按钮，触发的onload,需要展示登录页面            this.authorizationLogin()        } else {            // 小程序启动的业务处理入口            const storageUserInfo = tool.getUserInfo()            if (storageUserInfo) {                const res = JSON.parse(storageUserInfo)                this.setLoginData(res)                this.$config.open_id = res.open_id            } else {                tip.hideLoading()                this.$store.commit(&#39;setLoginStatus&#39;, false)                this.$router.switchTab(&#39;/pages/order/order&#39;)            }        }    },    methods: {        getuserinfoCallback(e) {            this.needAuth = false            if (e.detail.userInfo === undefined) { //授权拒绝                this.needAuth = true            } else {                this.readyWxAuth(e.detail)            }        },        authorizationLogin() {            uni.login({                provider: &#39;weixin&#39;,                success: res =&gt; {                    this.code = res.code                    uni.getSetting({                        success: (result) =&gt; {                            tip.hideLoading()                            //判断是否有权限去直接拉取用户信息                            if (result.authSetting[&#39;scope.userInfo&#39;]) {                                this.getWxUserInfo()                            } else {                            //没有权限，则需要显示一个固定格式的button，点击让用户授权                                this.needAuth = true                            }                        },                        fail: () =&gt; {                            this.needAuth = true                        }                    })                }            })        },        getWxUserInfo() {            tip.showLoading()            this.needAuth = false            //获取用户信息            uni.getUserInfo({                provider: &#39;weixin&#39;,                withCredentials: true,                success: res =&gt; {                    this.readyWxAuth(res)                },                fail: error =&gt; {                    tip.hideLoading()                }            })        },        // 此时，才涉及到你与自己后台的交互判断        readyWxAuth(res) {            this.$api                .readyWxAuth({                    code: this.code,                    userInfo: JSON.stringify(res.userInfo)                })                .then(res =&gt; {                    tip.hideLoading()                    this.open_id = res.open_id                    this.$config.open_id = res.open_id                    if (res.user_info === undefined) {                        //说明是新的用户，弹出登录框，绑定用户                        this.canAutoLogin = false                    } else {                        //不是新用户，存储用户信息，设置全局变量                        tool.saveUserInfo(res)                        this.setLoginData(res)                    }                })        },        setLoginData(res) {            const userInfo = res.user_info            const store = res.store            this.$config.store_name = store.name            this.$config.wxHeadImage = userInfo.wxInfo.avatarUrl            this.$config.sign = res.sign            this._setStoreInfo(store)            this.$config.staff_role_gid = userInfo.FK_role_gid            this.$config.staff_name = userInfo.username            this.getToken(userInfo.gid, this.$config.store_gid, res.sign)        },        login() {            if (this.account === &#39;&#39;) {                tip.showToast(&#39;账号不能为空&#39;)                return            }            if (this.password === &#39;&#39;) {                tip.showToast(&#39;密码不能为空&#39;)                return            }            this.$api                .login({                    number: this.account,                    password: md5(this.password),                    open_id: this.open_id,                    isLoading: true                })                .then(res =&gt; {                    res.user_info.self_login_password = md5(this.password)                    res.open_id = this.$config.open_id                     //登录拿到的res中不包含open_id,所以需要自己手动存进res                    tool.saveUserInfo(res)                    this.setLoginData(res)                })                .catch(err =&gt; {                    tip.showModal(err, false)                })        },        getToken(staff_gid, store_gid, sign) {            let data = {                FK_staff_gid: staff_gid,                FK_store_gid: store_gid,                sign: sign            }            // 保存用户gid            this.$config.staff_gid = staff_gid            this.$api                .getToken(data)                .then(res =&gt; {                    // 保存token                    this.$config.token = &#39;Bearer &#39; + res                    tip.hideLoading()                    this.$store.commit(&#39;setLoginStatus&#39;, true)                    this.$config.needRefresh = true                    this.$router.switchTab(&#39;/pages/order/order&#39;)                })                .catch(err =&gt; {                    tip.hideLoading()                    tip.showToast(err)                    this.clearUserInfo()                 })        },        clearUserInfo() {            this.$store.commit(&#39;setLoginStatus&#39;, false)            tool.removeProductCache()            this.$store.commit(&#39;initProduct&#39;, [])            tool.delUserInfo()            this.$config.store_name = &#39;&#39;            this.$config.sign = &#39;&#39;            this.$config.staff_role_gid = &#39;&#39;            this.$config.token = &#39;&#39;            this.$config.authArray = []            this.needAuth = true            this.$config.needRefresh = true        },        // 设置门店信息        _setStoreInfo(store) {            const recent_selected_store = tool.getStorageSync(RECENT_SELECTED_STORE)            if (recent_selected_store) {                let tempStore = recent_selected_store[0]                if (tempStore.FK_branch_type_gid) {                    store = tempStore                }            }            this.$config.store_name = store.name            this.$config.store_gid = store.gid            this.$config.store_branch_gid = store.FK_branch_type_gid        }    }}&lt;/script&gt;</code></pre><blockquote><p>总结：登录页面比较简单，思路也比较固定。小程序启动后，先判断是否存储有用户信息，有的话就直接登录；没有的话就需要小程序来登录了。使用小程序登录，需要先判断用户有没有授权让你获取用户信息，有的话去拉取用户信息，然后与自己的后台做交互。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用uni-app实现云打包和热更新</title>
      <link href="/2019/08/27/2019-08-27-shi-yong-uni-app-shi-xian-yun-da-bao-he-re-geng-xin/"/>
      <url>/2019/08/27/2019-08-27-shi-yong-uni-app-shi-xian-yun-da-bao-he-re-geng-xin/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="使用uni-app实现云打包和热更新"><a href="#使用uni-app实现云打包和热更新" class="headerlink" title="使用uni-app实现云打包和热更新"></a>使用uni-app实现云打包和热更新</h2><h3 id="云打包"><a href="#云打包" class="headerlink" title="云打包"></a>云打包</h3><p>启动HBuilderX，然后点击“运行”–&gt;“原生APP-云打包”，弹出如下页面：</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/46DBE81EEF43448AAF1D23FB14F50C5A/29515" alt="image"></p><blockquote><p>如果你要同时发布Android和iOS，那么需要都需要配置其内容。需要注意的是，一般我们都需要将广告联盟给取消掉。</p></blockquote><p>我使用的开发工具为mac。现在假设你也是使用mac作为开发工具，同时也已经有了Android和iOS相关的证书文件，如果没有，可以按照上面的提示，一步步的配置。</p><h4 id="配置Android"><a href="#配置Android" class="headerlink" title="配置Android"></a>配置Android</h4><p>选中你的jks证书，填上证书的别名和私钥密码，完成入下图：</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/697240B23EB249A3B1E02D96A9E5B4FC/29517" alt="Android配置"></p><h4 id="配置iOS"><a href="#配置iOS" class="headerlink" title="配置iOS"></a>配置iOS</h4><p>选中你本地的发布证书（.p12）及对应的发布描述文件（.mobileprovision），配置后如下图：</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/8449C45C646F44AE88372BFEC19EA4F4/29519" alt="iOS"></p><h4 id="修改包名"><a href="#修改包名" class="headerlink" title="修改包名"></a>修改包名</h4><p>还有关键一步，修改包名，则大功告成！下面分别是修改Android和iOS的APP包名：</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/272C8FAB43EC47B1B40EF666F667DAB2/29522" alt="修改Android包名"></p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/7E397E9AD0504E4899196357F1DC49A7/29521" alt="修改iOS包名"></p><p>最后点击打包耐心等待即可.得到apk和ipa包后，将apk上传到对应的Android市场，iOS则需要上传到appstore，此处不做演示。</p><h3 id="uni-app热更新"><a href="#uni-app热更新" class="headerlink" title="uni-app热更新"></a>uni-app热更新</h3><p>热更新不像发布那样复杂,不过首先，你需要更新 manifest.json 中的版本号和版本名称配置。比如之前是 4.3.0，那么新版本应该是 4.3.1 或 4.4.0 这样。应用版本号之前是600，现在可以是601.总之，每次发布版本时两者都必须大于上一次的值.</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/6B207A8C81EC497AAF6266DA632048D6/29528" alt="image"></p><p>然后点击发行中的资源升级包：</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/825B1259B4D441699D1C027C5DDA04A7/29524" alt="image"></p><p>选择你要生成的.wgt文件路径：</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/A60E76269F344F059C0A1F77D1E761B6/29526" alt="image"></p><p>然后等待控制台的输出，导出成功后就得到了对应的.wgt文件。得到文件后，可以将文件存放在服务器，我这边是把资源包放到了七牛。然后与后台约定检测升级的接口，每次程序启动则请求接口，做检测更新即可。</p><p><img src="https://note.youdao.com/yws/public/resource/c934ad270787ffca1d2db279abd6bb75/xmlnote/5E7D217740BD4739A98A90CAF228D25F/29530" alt="image"></p><p>下面是检测热更新资源操作和更新APP包的业务逻辑：</p><pre><code>onShow() {            if (!this.isNew) { //isNew:标识APP启动才会检测，切换页面再次调用onShow不做检测                this.isNewVersion()            }        },                    // 获取最新版本            isNewVersion() {                // 调用检测自己的检测接口                this.$api.getNewVersion().then(res =&gt; {                    if (res.is_newest) { //没有最新版本                        this.isNew = true                     } else { //有最新版本                        // #ifdef APP-PLUS                        if (res.is_update_now) {  //最新版本是热更新资源                            if (res.down_link !== &#39;none&#39;) {                                //下载热更新资源                                this.checkUpdate(res.down_link)                            }                        } else { //最新版本是新版本的安装包，则需要去appstore或者应用商店下载新包。                            if (uni.getSystemInfoSync().platform == &quot;ios&quot;) {                                tip.showModal(&#39;请前往App Store下载最新版本&#39;, false)                            } else {                                tip.showModal(&#39;发现新版本&#39;, false).then(res =&gt; {                                    if (res) {                                        plus.webview.open(&#39;https://fir.im/XXXXXXXXXXXXX&#39;)                                    }                                })                            }                        }                        // #endif                    }                })            },            // 下载最新资源包            checkUpdate(url) {                plus.nativeUI.showWaiting(&#39;下载更新...&#39;)                plus.downloader.createDownload(url, {filename:&#39;_doc/update/&#39;}, (d, status) =&gt; {                    if (status === 200) {                        this.installWgt(d.filename)                    } else {                        plus.nativeUI.alert(&#39;下载更新失败!&#39;)                    }                    plus.nativeUI.closeWaiting()                }).start()            },            // 更新应用资源包            installWgt(path) {                plus.nativeUI.showWaiting(&#39;安装资源文件中...&#39;)                plus.runtime.install(path, {}, () =&gt; {                    plus.nativeUI.closeWaiting()                    plus.nativeUI.alert(&#39;应用资源更新完成!&#39;, () =&gt; {                        plus.runtime.restart()                    })                }, (e) =&gt; {                    plus.nativeUI.closeWaiting()                    plus.nativeUI.alert(&#39;资源更新失败,原因:&#39; + e.message)                })            },</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise的总结与使用</title>
      <link href="/2019/08/16/2019-08-16-promise-de-zong-jie-yu-shi-yong/"/>
      <url>/2019/08/16/2019-08-16-promise-de-zong-jie-yu-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="promise的使用总结"><a href="#promise的使用总结" class="headerlink" title="promise的使用总结"></a>promise的使用总结</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise的详细语法请参考MDN</a> 我们知道，一个promise有3种状态：pending（初始状态，既不是成功，也不是失败状态）、fulfilled（意味着操作成功完成）、rejected（味着操作失败）。</p><pre><code>new Promise( function(resolve, reject) {...} /* executor */  );</code></pre><h4 id="fullfilled完成状态"><a href="#fullfilled完成状态" class="headerlink" title="fullfilled完成状态"></a>fullfilled完成状态</h4><p>调用resolve函数会将promise的状态改为fullfilled完成状态：</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {  setTimeout(()=&gt; {    resolve(&#39;我被调用了&#39;)  },200)})promise.then((result) =&gt; {  console.log(result)}).catch(error =&gt; {  console.log(error)}).finally(() =&gt; {  console.log(&#39;我最终才会被执行&#39;);})//我被调用了//我最终才会被执行</code></pre><p>我们还可以使用Promise的静态方法<code>Promise.resolve(value)</code>来返回一个Promise：</p><pre><code>let promise = Promise.resolve(&#39;我是resolve&#39;);promise.then(result =&gt; {  console.log(result)})//我是resolve//也可以是链式的写法Promise.resolve(&quot;Success&quot;).then(function(value) {  console.log(value); // &quot;Success&quot;});</code></pre><h4 id="resolve另一个promise"><a href="#resolve另一个promise" class="headerlink" title="resolve另一个promise"></a>resolve另一个promise</h4><pre><code>let original = Promise.resolve(313);let cast = Promise.resolve(original);cast.then(value =&gt; {  console.log(&#39;value: &#39; + value);});console.log(&#39;original === cast ? &#39; + (original === cast));//打印顺序如下，这里有一个同步异步先后执行的区别//original === cast ? true//value: 313</code></pre><blockquote><p>日志顺序颠倒其实是由于异步地调用then 方法.至于then()方法，在后面我们会说到。</p></blockquote><h4 id="rejected失败状态"><a href="#rejected失败状态" class="headerlink" title="rejected失败状态"></a>rejected失败状态</h4><p>调用reject函数会将promise的状态改为rejected失败状态：</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {  setTimeout(()=&gt; {    reject(&#39;我被调用了&#39;)  },200)})promise.then((result) =&gt; {  console.log(result)}).catch(error =&gt; {  console.log(&#39;我发生了错误&#39;)  console.log(error)}).finally(() =&gt; {  console.log(&#39;我最终才会被执行&#39;);})//我发生了错误// 我被调用了// 我最终才会被执行</code></pre><p>同样的，我们还可以使用Promise的静态方法<code>Promise.reject(reason)</code>来返回一个被拒绝的Promise对象：</p><pre><code>Promise.reject(&#39;糟糕!发生了错误&#39;).then(res =&gt; {  console.log(&#39;我不会被调用&#39;);}, reason =&gt; {  console.log(&#39;我被调用了:&#39;, reason);})//我被调用了: 糟糕!发生了错误</code></pre><h3 id="then-方法的使用"><a href="#then-方法的使用" class="headerlink" title="then()方法的使用"></a>then()方法的使用</h3><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功情况resolve和失败情况reject的回调函数,它的语法如下:</p><pre><code>p.then(onFulfilled[, onRejected]);p.then(value =&gt; {  // fulfillment}, reason =&gt; {  // rejection});</code></pre><p>成功状态：</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {  setTimeout(()=&gt; {    resolve(&#39;我是成功的回调&#39;)  },200)})promise.then((res) =&gt; {  console.log(res) //我是成功的回调}, (error) =&gt; {  console.log(error) })</code></pre><p>失败状态：</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {  setTimeout(()=&gt; {    reject(&#39;我是失败的回调&#39;)  },200)})promise.then((res) =&gt; {  console.log(res) }, (error) =&gt; {  console.log(error) //我是失败的回调})</code></pre><p>then的回调时机：</p><pre><code>const resolvedProm = Promise.resolve(313);let thenProm = resolvedProm.then(value =&gt; {  console.log(&quot;当前线程循环结束前调用: &quot; + value);  return value;});console.log(&#39;调用了:&#39;, thenProm);setTimeout(() =&gt; {  console.log(&#39;setTimeout的回调:&#39;,thenProm);});/** * 调用了: Promise {&lt;pending&gt;} * 当前线程循环结束前调用: 313 * setTimeout的回调: Promise {&lt;resolved&gt;: 313} */</code></pre><h4 id="then方法的链式调用"><a href="#then方法的链式调用" class="headerlink" title="then方法的链式调用"></a>then方法的链式调用</h4><p>then 方法返回一个 Promise 对象，那么这就可以使用链式调用了:</p><pre><code>Promise.resolve(&#39;first&#39;).then(result =&gt; {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {      result += &#39;----&gt;second&#39;      resolve(result)    }, 2000)  })}).then(result =&gt; {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {      result += &#39;----&gt;third&#39;      resolve(result)    }, 2000)  })}).then(result =&gt; {  console.log(&#39;最终的结果是:&#39;,result); //最终的结果是: first----&gt;second----&gt;third})</code></pre><p>当一个值只是从一个 then 内部返回时，它将等价地返回 Promise.resolve(&lt;由被调用的处理程序返回的值&gt;):</p><pre><code>Promise.resolve(&#39;first&#39;).then(result =&gt; {  return result +  &#39;----&gt;second&#39;;}).then(result =&gt; {  return result + &#39;----&gt;third&#39;;}).then(result =&gt; {  console.log(&#39;最终的结果是:&#39;, result); });console.log(&#39;调用了&#39;);/** * 调用了 * 最终的结果是: first----&gt;second----&gt;third */</code></pre><p>注意下面的打印顺序，’哈哈哈,我也调用了: 2’是最后被调用的：</p><pre><code>const p2 = new Promise((resolve, reject) =&gt; {  resolve(1)});p2.then(function(value) {  console.log(&#39;调用了:&#39;, value);  return value + 1;}).then(function(value) {  console.log(&#39;哈哈哈,我也调用了:&#39;, value);});p2.then(function(value) {  console.log(&#39;哦哦哦,看来我也调用了:&#39;, value);});p2.then(function(value) {  console.log(&#39;啊啊啊,我也调用了:&#39;, value);});/** * 调用了: 1 * 哦哦哦,看来我也调用了: 1 * 啊啊啊,我也调用了: 1 * 哈哈哈,我也调用了: 2 */</code></pre><p>在catch回调之后，还能继续then的回调：</p><pre><code>Promise.resolve()  .then(() =&gt; {    // 使 .then() 返回一个 rejected promise    throw new Error(&#39;发生了一个错误!&#39;);  })  .catch(error =&gt; {    console.error(&#39;onRejected被回调了: &#39; + error.message);  })  .then(() =&gt; {    console.log(&quot;即便reject被回调了,我还是能被调用...&quot;);  });/** *  onRejected被回调了: 发生了一个错误! *  即便reject被回调了,我还是能被调用... */</code></pre><h3 id="Promise-all-iterable-方法"><a href="#Promise-all-iterable-方法" class="headerlink" title="Promise.all(iterable)方法"></a>Promise.all(iterable)方法</h3><blockquote><p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数可以是promise对象，也可以是普通的值，我们可以封装iterable为一个数组。如果iterable中包含promise对象，并且 promise有一个失败（rejected），此实例的回调就会失败（reject），失败原因的是第一个失败 promise 的结果。</p></blockquote><p>全部都是promise对象：</p><pre><code>var promise1 = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(&#39;我是promise1, 我被调用了&#39;)  },2000)})var promise2 = Promise.resolve(&#39;我是promise2, 我被调用了&#39;)var promise3 = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(&#39;我是promise3, 我被调用了&#39;)  },1200)})var promise4 = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(&#39;我是promise4, 我被调用了&#39;)  },4000)})Promise.all([promise1, promise2, promise3, promise4]).then(result =&gt; {  console.log(result)})// [&quot;我是promise1, 我被调用了&quot;, &quot;我是promise2, 我被调用了&quot;, &quot;我是promise3, 我被调用了&quot;, &quot;我是promise4, 我被调用了&quot;]</code></pre><p>数组中可以传入非promise数据：</p><p>tips：如果参数中包含非 promise 值，这些值将被忽略，但仍然会被放在返回数组中（如果 promise 完成的话）</p><pre><code>let promise1 = Promise.resolve(&#39;我是promise1, 我被调用了&#39;)let name = &#39;LXX&#39;let age = 18Promise.all([promise1, name, age]).then(result =&gt; {  console.log(result)})// [&quot;我是promise1, 我被调用了&quot;, &quot;LXX&quot;, 18]</code></pre><blockquote><p>注意：返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。<br>如果传入的 promise 中有失败（rejected）：</p></blockquote><pre><code>let promise1 = Promise.resolve(&#39;我是promise1, 我被调用了&#39;)let name = &#39;LXX&#39;let age = 18let promise2 = Promise.resolve(&#39;我是promise2, 我被调用了&#39;)let promise3 = Promise.reject(&#39;我是promise3, 我被拒绝了&#39;)let promise4 = Promise.resolve(&#39;我是promise4, 我被调用了&#39;)Promise.all([promise1, name, age, promise2, promise3, promise4]).then(result =&gt; {  console.log(result)})// Uncaught (in promise) 我是promise3, 我被拒绝了</code></pre><blockquote><p>如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成</p></blockquote><h5 id="异步性："><a href="#异步性：" class="headerlink" title="异步性："></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">异步性</a>：</h5><pre><code>let promise1 = Promise.resolve(&#39;我是promise1, 我被调用了&#39;)let promise2 = Promise.resolve(&#39;我是promise2, 我被调用了&#39;)let p = Promise.all([promise1, promise2])console.log(&#39;我的状态是:&#39;);console.log(p);p.then((result) =&gt; {  console.log(&#39;我在then的回调:&#39;);  console.log(result)  console.log(p);})setTimeout(() =&gt; {  console.log(&#39;我在setTimeout的回调:&#39;);  console.log(p);})console.log(&#39;我被执行了&#39;);//我的状态是://Promise {&lt;pending&gt;}//我被执行了//我在then的回调://(2) [&quot;我是promise1, 我被调用了&quot;, &quot;我是promise2, 我被调用了&quot;]//Promise {&lt;resolved&gt;: Array(2)}//我在setTimeout的回调://Promise {&lt;resolved&gt;: Array(2)}</code></pre><pre><code>let promise1 = Promise.resolve(&#39;我是promise1, 我被调用了&#39;)let promise2 = Promise.resolve(&#39;我是promise2, 我被调用了&#39;)let p = Promise.all([promise1, promise2])console.log(&#39;我的状态是:&#39;);console.log(p);setTimeout(() =&gt; {  console.log(&#39;我在setTimeout的回调:&#39;);  console.log(p);})p.then((result) =&gt; {  console.log(&#39;我在then的回调:&#39;);  console.log(result)  console.log(p);})console.log(&#39;我被执行了&#39;);//我的状态是://Promise {&lt;pending&gt;}//我被执行了//我在then的回调://(2) [&quot;我是promise1, 我被调用了&quot;, &quot;我是promise2, 我被调用了&quot;]//Promise {&lt;resolved&gt;: Array(2)}//我在setTimeout的回调://Promise {&lt;resolved&gt;: Array(2)}</code></pre><blockquote><p>由于我们传入的是resolve的promise数组，所以会触发promise.all。我们发现，无论setTimeout是在p.then前还是后面，都是最后调用。</p></blockquote><h4 id="Promise-race-iterable-的用法"><a href="#Promise-race-iterable-的用法" class="headerlink" title="Promise.race(iterable)的用法"></a>Promise.race(iterable)的用法</h4><p>race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</p><pre><code>var p1 = new Promise(function(resolve, reject) {     setTimeout(resolve, 500, &quot;one&quot;); });var p2 = new Promise(function(resolve, reject) {     setTimeout(resolve, 100, &quot;two&quot;); });Promise.race([p1, p2]).then(function(value) {  console.log(value); // &quot;two&quot;  // 两个都完成，但 p2 更快});var p3 = new Promise(function(resolve, reject) {     setTimeout(resolve, 100, &quot;three&quot;);});var p4 = new Promise(function(resolve, reject) {     setTimeout(reject, 500, &quot;four&quot;); });Promise.race([p3, p4]).then(function(value) {  console.log(value); // &quot;three&quot;  // p3 更快，所以它完成了              }, function(reason) {  // 未被调用});var p5 = new Promise(function(resolve, reject) {     setTimeout(resolve, 500, &quot;five&quot;); });var p6 = new Promise(function(resolve, reject) {     setTimeout(reject, 100, &quot;six&quot;);});Promise.race([p5, p6]).then(function(value) {  // 未被调用             }, function(reason) {  console.log(reason); // &quot;six&quot;  // p6 更快，所以它失败了});</code></pre><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h4 id="使用Promise-all的场景举例"><a href="#使用Promise-all的场景举例" class="headerlink" title="使用Promise.all的场景举例"></a>使用<code>Promise.all</code>的场景举例</h4><p>在uni-app中，有一个复杂的页面，需要多个接口返回数据，我们希望在多个接口数据未全部返回数据时使用loading，全部成功后结束loading。多个接口中如果有一个返回异常报错，则提示用户数据异常。这种场景下，我们就可以使用promise了。</p><p><img src="https://note.youdao.com/yws/public/resource/b3da4a5ccb160d519b7bfc579842626c/xmlnote/F794B4A64C0B4AA5879DC7287E45781C/28939" alt="image"></p><blockquote><p>如上图，我们需要同时请求多个接口，接口之间并没有数据依赖，那么就可以使用Promise.all了。</p></blockquote><p>下面是简化后的代码：</p><pre><code>        onLoad() { //uni-app生命周期函数            this.requestData()        },        methods: {            // 刷新页面数据            requestData() {                tip.showLoading()                //将多个请求接口添加到数组中                const promises = [this.getRealSales(), this.getMessage(), this.getVideo(), this.getTemplate(), this.getTask(), this                    .getUomMap()                ]                Promise.all(promises)                    .then(res =&gt; {})                    .catch(err =&gt; {})                    .finally(() =&gt; {                        tip.hideLoading()                    })            },            //共需要请求6个接口，此处只取出一个接口做说明            getRealSales() {// 获取实时销售数据                return this.$api                    .getRealSales()                    .then(res =&gt; {                        this.real_sales = tool.filterObjProp(res, [&#39;sales_amount&#39;, &#39;passenger_flow&#39;, &#39;each_profit&#39;])                    })                    .catch(err =&gt; tip.showToast(err))            },        }</code></pre><blockquote><p>你可以选择在拿到全部接口数据后统一做处理，也可以分别在每个接口返回后做处理，然后Promise.all中只是有一个空实现。</p></blockquote><h3 id="使用await操作符"><a href="#使用await操作符" class="headerlink" title="使用await操作符"></a>使用<code>await</code>操作符</h3><p>await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。</p><pre><code>function test1 () {  return new Promise(resolve =&gt; {    setTimeout(() =&gt; {      console.log(&#39;4s后,test1请求到了数据&#39;);      resolve(123)    }, 4000)  })}function test2 (data) {  return new Promise(resolve =&gt; {    setTimeout(() =&gt; {      console.log(&#39;2s后,test2请求到了数据&#39;);      resolve(data * 1000)    }, 2000)  })}async function requestData () {  try {    console.log(&#39;我开始执行了&#39;);    let response = await this.test1()    response = await this.test2(response)    console.log(response);  } catch (e) {    throw e  } finally {    console.log(&#39;我最后才会被执行&#39;);  }}requestData()/** * 我开始执行了 * 4s后,test1请求到了数据 * 2s后,test2请求到了数据 * 123000 * 我最后才会被执行 */</code></pre><blockquote><p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。所以，如果接口直接有依赖关系，那么就可以使用await这种方式了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序总结提高</title>
      <link href="/2019/07/01/2019-07-01-wei-xin-xiao-cheng-xu-zong-jie-ti-gao/"/>
      <url>/2019/07/01/2019-07-01-wei-xin-xiao-cheng-xu-zong-jie-ti-gao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="微信小程序总结提高"><a href="#微信小程序总结提高" class="headerlink" title="微信小程序总结提高"></a>微信小程序总结提高</h2><p>现如今,微信小程序的开发越来越受欢迎,最近一段时间先后开发和维护了几个微信小程序,既有原生的,也有使用框架开发的.我现在维护的项目使用的框架有mpvue(现在已经迁移到uni-app)上,uni-app框架,Taro框架.虽然各有优缺点,但是开发思想和流程大体相似.最近决定对这些框架进行逐个整理,笔记会在以后逐渐更新出来.</p><h3 id="微信小程序界面的渲染流程"><a href="#微信小程序界面的渲染流程" class="headerlink" title="微信小程序界面的渲染流程"></a>微信小程序界面的渲染流程</h3><p>我们知道,微信小程序的宿主环境就是微信客户端,之前遇到很多开发中的bug,都是会在下一个或几个微信APP更新后得到解决.所以,有时候,你遇到了一些难以调试的bug,不如先去微信社区里瞅瞅,很有可能很多人都遇到了这个问题,一般普遍的问题,微信官方都会做出解释和解决bug的日程.</p><p>为了运行微信小程序,微信APP为小程序提供了”双线程模型”.page的wxml和wxss两个模块运行于渲染层,渲染层使用webview线程渲染(小程序有多个页面,会使用多个webview线程);page的js脚本文件运行于逻辑层,逻辑层使用JSCore来运行js脚本.这两个线程都会经由微信APP进行中转交互.</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础使用</title>
      <link href="/2019/03/11/2019-03-11-react-ji-chu-shi-yong/"/>
      <url>/2019/03/11/2019-03-11-react-ji-chu-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="使用-React-做一个-TodoList"><a href="#使用-React-做一个-TodoList" class="headerlink" title="使用 React 做一个 TodoList"></a>使用 React 做一个 TodoList</h4><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>React<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16/umd/react.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@16/umd/react-dom.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcdn.net/ajax/libs/babel-standalone/7.0.0-beta.3/babel.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/babel<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>      state <span class="token operator">=</span> <span class="token punctuation">{</span> todos<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'吃饭'</span><span class="token punctuation">,</span> <span class="token string">'睡觉'</span><span class="token punctuation">,</span> <span class="token string">'敲代码'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>      addTodos <span class="token operator">=</span> <span class="token punctuation">(</span>thing<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>todos<span class="token punctuation">]</span>        todos<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>thing<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>todos<span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span> todos <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state        <span class="token keyword">return</span> <span class="token punctuation">(</span>          <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span>h1<span class="token operator">></span>Simple Todo<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>            <span class="token operator">&lt;</span>Add count<span class="token operator">=</span><span class="token punctuation">{</span>todos<span class="token punctuation">.</span>length<span class="token punctuation">}</span> addTodos<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>addTodos<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span>Lists todos<span class="token operator">=</span><span class="token punctuation">{</span>todos<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Add</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>      add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token punctuation">{</span>addTodos<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props        <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>todoInput<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">addTodos</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>todoInput<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">''</span>      <span class="token punctuation">}</span>      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props        <span class="token keyword">return</span> <span class="token punctuation">(</span>          <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>todoInput <span class="token operator">=</span> input<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>add<span class="token punctuation">}</span><span class="token operator">></span>Add#<span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Lists</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>todos<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props        <span class="token keyword">return</span> <span class="token punctuation">(</span>          <span class="token operator">&lt;</span>div<span class="token operator">></span>               <span class="token operator">&lt;</span>ul<span class="token operator">></span>                <span class="token punctuation">{</span>todos<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                  <span class="token keyword">return</span><span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>              <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> React.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift基础总结</title>
      <link href="/2019/03/01/2019-03-01-rxswift-ji-chu-zong-jie/"/>
      <url>/2019/03/01/2019-03-01-rxswift-ji-chu-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="1-创建可观察对象Observable"><a href="#1-创建可观察对象Observable" class="headerlink" title="1.创建可观察对象Observable"></a>1.创建可观察对象Observable</h3><p>下面都是创建可观察对象的方式：</p><pre><code>enum MyError: Error {    case errorA    case errorB}</code></pre><pre><code>//创建可观察对象let _ = Observable&lt;String&gt;.just(&quot;liuxingxing&quot;)        let _ = Observable&lt;Int&gt;.of(1,2,3,4)        let _ = Observable&lt;Bool&gt;.from([true, false, true])        let _ = Observable&lt;Double&gt;.empty()        let _ = Observable&lt;Float&gt;.never() //never表示该观察对象永远不会发出event事件， 也不会终止        let _ = Observable&lt;Int&gt;.error(MyError.errorA)        let _ = Observable&lt;Int&gt;.range(start: 1, count: 6) // 1,2,3,4,5,6        let _ = Observable&lt;Int&gt;.repeatElement(333) //重复发出元素的event 不会停止        let _ = Observable&lt;Int&gt;.generate(initialState: 0, condition: { (num) -&gt; Bool in            return num &lt;= 10        }) { (num) -&gt; Int in           return num + 2        } //0, 2,4,6,8,10        let _ = Observable.generate(initialState: 10, condition: {$0 &gt;= 0}, iterate: {$0 - 2}) // 10,8,6,4,2,0        let _ = Observable&lt;String&gt;.create { (observer) -&gt; Disposable in            observer.onNext(&quot;hahahaha&quot;)            observer.onCompleted()            //每一个订阅行为都会有一个Disposables类型的返回值            return Disposables.create {            }        }        var isOdd = true        let factory = Observable&lt;String&gt;.deferred { () -&gt; Observable&lt;String&gt; in            isOdd = !isOdd            if isOdd {                return Observable&lt;String&gt;.of(&quot;1&quot;, &quot;2&quot;)            }            return Observable&lt;String&gt;.of(&quot;1a&quot;, &quot;2b&quot;)        }        factory.subscribe {event in            print(event)        }        factory.subscribe {event in            print(event)        }        let ob = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)        ob.subscribe {event in            print(&quot;每隔1秒产生一个元素：&quot;,event)        }        let ob1 = Observable&lt;Int&gt;.timer(5, scheduler: MainScheduler.instance)        ob1.subscribe { event in            print(&quot;经过5s后产生的唯一元素：&quot;,event)        }        let ob2 = Observable&lt;Int&gt;.timer(5, period: 1, scheduler: MainScheduler.instance)        ob2.subscribe { event in            print(&quot;经过5s后,每隔1s产生一个元素：&quot;,event)      }</code></pre><h3 id="2-订阅可观察对象Observable"><a href="#2-订阅可观察对象Observable" class="headerlink" title="2.订阅可观察对象Observable"></a>2.订阅可观察对象Observable</h3><pre><code>        // 第一种写法        let ob = Observable&lt;Int&gt;.of(1,2,3,4,5)        ob.subscribe {event in           switch event {            case .next(let element):                print(element)            case .error(let error):                print(error)            case .completed:                print(&quot;completed&quot;)            }        }        // 第二种写法        ob.subscribe(onNext: { (num) in            print(num)        }, onError: { (error) in            print(error)        }, onCompleted: {            print(&quot;onCompleted&quot;)        }, onDisposed: {            print(&quot;disposed&quot;)        })</code></pre><h4 id="Disposable"><a href="#Disposable" class="headerlink" title="Disposable"></a>Disposable</h4><p>每当Observeable被订阅时，都会返回一个Disposable实例，当调用Disposable的dispose，就相当于取消订阅。在不需要再接收事件时，建议取消订阅，释放资源。有3种常见方式取消订阅。</p><pre><code>        let observable = Observable&lt;Int&gt;.create { (observer) -&gt; Disposable in            observer.onNext(123)            return Disposables.create()        }       let disposable = observable.subscribe { (event) in            switch event {            case .next(let element):                print(element)            case .error(let error):                print(error)            case .completed:                print(&quot;completed&quot;)            }        }        // 如果在某个时刻，你不再需要订阅了，可以调用以下方法来取消订阅        disposable.dispose()        //如果订阅后立即取消订阅，可以这样实现：        observable.subscribe { (event) in            switch event {            case .next(let element):                print(element)            case .error(let error):                print(error)            case .completed:                print(&quot;completed&quot;)            }        }.dispose()        // 通过DisposeBag来销毁,当bag销毁（deinit）时，会自动        // 调用Disposable实例的dispose        let disposeBag = DisposeBag()        observable.subscribe { (event) in        }.disposed(by: disposeBag)        //第三种，监听自身销毁takeUntil        let _ = observable.takeUntil(self.rx.deallocated).map{&quot;\($0)&quot;}        .bind(to: timerLabel.rx.text)</code></pre><p>do方法会在每一次subscribe函数调用之前调用，是监听事件生命周期的函数：</p><pre><code>        let ob = Observable&lt;Int&gt;.of(1,2,3,4,5)        // do方法会在每一次subscribe函数调用z之前调用，是监听事件生命周期的函数        ob.do(onNext: { (num) in            print(&quot;----&gt;\(num)&quot;)        }, onError: { (error) in            print(error)        }, onCompleted: {            print(&quot;-----&gt;onCompleted&quot;)        }, onSubscribe: {            print(&quot;----&gt;onSubscribe&quot;)        }, onSubscribed: {            print(&quot;----&gt;onSubscribed&quot;)        }, onDispose: {            print(&quot;----&gt;onDispose&quot;)        }).subscribe(onNext: { (num) in            print(num)        }, onError: { (error) in            print(error)        }, onCompleted: {            print(&quot;onCompleted&quot;)        }, onDisposed: {            print(&quot;disposed&quot;)        })    }</code></pre><p> 示例1：</p><pre><code>        //创建可观察对象        _ = Observable.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)        let evenObservable = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).map { Int($0) }            .filter { $0 % 2 == 0 }        //订阅这个可观察对象        _ = evenObservable.subscribe { (event) in            print(&quot;this event: \(event)&quot;)        }</code></pre><pre><code>this event: next(2)this event: next(4)this event: next(6)this event: next(8)this event: next(10)this event: completed</code></pre><p> 使用<code>skip</code>忽略前两个事件：</p><pre><code>        //创建可观察对象        _ = Observable.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)        let evenObservable = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).map { Int($0) }            .filter { $0 % 2 == 0 }        //订阅这个可观察对象        _ = evenObservable.skip(2).subscribe { (event) in            print(&quot;this event: \(event)&quot;)        }</code></pre><pre><code>this event: next(6)this event: next(8)this event: next(10)this event: completed</code></pre><h3 id="3-事件的状态与绑定"><a href="#3-事件的状态与绑定" class="headerlink" title="3.事件的状态与绑定"></a>3.事件的状态与绑定</h3><p>事件状态的改变：</p><pre><code>        let evenObservable = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).map { Int($0) }            .filter { $0 % 2 == 0 }        //订阅这个可观察对象        _ = evenObservable.subscribe(            onNext: {event in print(event )},            onError: { print(&quot;error: \($0)&quot;) },             onCompleted: {  print(&quot;completed&quot; ) },             onDisposed: {print(&quot;disposed&quot; ) }        )</code></pre><pre><code>246810completeddisposed</code></pre><h4 id="通过bind方式来进行事件绑定："><a href="#通过bind方式来进行事件绑定：" class="headerlink" title="通过bind方式来进行事件绑定："></a>通过bind方式来进行事件绑定：</h4><pre><code>    func startTimer() {        let observer: AnyObserver&lt;String&gt;  = AnyObserver { (event) in            switch event {            case .next(let text):                print(text)                break            default:                break            }        }        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)        observable.map {&quot;当前值为\($0)&quot;}.skip(1).bind(to: observer).disposed(by: disposeBag)    }// 也可以绑定一个UI控件</code></pre><h4 id="通过Binder进行事件绑定"><a href="#通过Binder进行事件绑定" class="headerlink" title="通过Binder进行事件绑定:"></a>通过Binder进行事件绑定:</h4><pre><code>    func startTimer() {        let observer: Binder&lt;String&gt; = Binder(self) { (_, text) in            print(text)        }        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)        observable.map {&quot;当前值为\($0)&quot;}.skip(1).bind(to: observer).disposed(by: disposeBag)    }      let binder = Binder&lt;String&gt;.init(timerLabel) { (label, value) in            label.text = value        }        Observable.just(&quot;123&quot;).bind(to: binder).dispose()        //也可以通过下面的方式        Observable.just(&quot;abc&quot;).subscribe(binder).dispose()</code></pre><h5 id="实现一个label的循环展示与隐藏"><a href="#实现一个label的循环展示与隐藏" class="headerlink" title="实现一个label的循环展示与隐藏"></a>实现一个label的循环展示与隐藏</h5><pre><code>        //我们可以通过以下代码实现一个label的循环展示与隐藏        let observerable = Observable&lt;Int&gt;.timer(.seconds(2), period: .seconds(1), scheduler: MainScheduler.instance)        let binder = Binder&lt;Bool&gt;.init(timerLabel) { (label, value) in            label.isHidden = value        }        observerable.map{ $0 % 2 == 0 }.bind(to: binder).disposed(by: bag)</code></pre><p>我们也可以通过扩展来更简单的实现这个功能：</p><pre><code>// 添加扩展extension Reactive where Base: UILabel {    var hidden: Binder&lt;Bool&gt; {        return Binder&lt;Bool&gt;(base) { label, value in            label.isHidden = value        }    }}// 使用        let observerable = Observable&lt;Int&gt;.timer(.seconds(2), period: .seconds(1), scheduler: MainScheduler.instance)        observerable.map{ $0 % 2 == 0 }.bind(to: timerLabel.rx.hidden).disposed(by: bag)</code></pre><p>实现一个简单的tableview（此tableview不需要设置代理）：</p><pre><code>    let bag =  DisposeBag()    let persons = Observable.just([Person(name: &quot;lxx&quot;, age: 234),Person(name: &quot;lxx32&quot;, age: 234),Person(name: &quot;lddxx&quot;, age: 234),Person(name: &quot;lxggx&quot;, age: 234)])        persons.bind(to: tableView.rx.items(cellIdentifier: &quot;cell&quot;)) { row, person, cell in            cell.textLabel?.text = person.name            cell.detailTextLabel?.text = &quot;\(person.age)&quot;        }.disposed(by: bag)        // 第一种点击事件//        tableView.rx.itemSelected.subscribe({ path in//            print(path)//        }).disposed(by: bag)        // 第二种点击事件        tableView.rx.modelSelected(Person.self).subscribe(onNext: { (person) in            print(person.name)            }).disposed(by: bag)</code></pre><p>监听一个按钮的点击</p><pre><code>// 方式1：button.rx.controlEvent(.touchUpInside).subscribe(onNext: {            print(&quot;被点击了&quot;)            }).disposed(by: bag)            // 方式2：                button.rx.tap.subscribe(onNext: {                    print(&quot;被点击了&quot;)                    }).disposed(by: bag)</code></pre><h4 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h4><pre><code>  let observer = AnyObserver&lt;Int&gt;.init { (event) in        }        Observable.just(1).subscribe(observer).dispose()</code></pre><h3 id="4、针对无限发送的事件做销毁"><a href="#4、针对无限发送的事件做销毁" class="headerlink" title="4、针对无限发送的事件做销毁"></a>4、针对无限发送的事件做销毁</h3><pre><code>        //5秒钟后销毁        let disposable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance).subscribe(                onNext: {event in print(event )},                onDisposed: {print(&quot;disposed&quot; ) }        )        delay(5) {            disposable.dispose()        }</code></pre><pre><code>    func delay(_ delay: Double, closure: @escaping () -&gt; ()) {        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {            closure()        }    }</code></pre><pre><code>01234disposed</code></pre><h3 id="5、DisposeBag来销毁对象"><a href="#5、DisposeBag来销毁对象" class="headerlink" title="5、DisposeBag来销毁对象"></a>5、DisposeBag来销毁对象</h3><pre><code>        //5秒钟后销毁        var bag = DisposeBag()        Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance).subscribe(                onNext: {event in print(event )},                onDisposed: {print(&quot;disposed&quot; ) }        ).disposed(by: bag)        delay(5) {            //通过创建新的bag,使原来bag绑定的对象便会销毁            bag = DisposeBag()        }</code></pre><h3 id="6、手动创建可观察对象"><a href="#6、手动创建可观察对象" class="headerlink" title="6、手动创建可观察对象"></a>6、手动创建可观察对象</h3><pre><code>   enum CustomError: Error {        case somethingError    }    func test4() {        let customObservable = Observable&lt;Int&gt;.create { (observer) -&gt; Disposable in            observer.onNext(10)            observer.onNext(11)            observer.onNext(12)            observer.onError(CustomError.somethingError)            observer.onCompleted()            return Disposables.create()        }        let bag = DisposeBag()        customObservable.subscribe(            onNext: { print($0)},            onCompleted: {  print(&quot;completed&quot; ) },            onDisposed: {print(&quot;disposed&quot; ) }            ).disposed(by: bag)    }</code></pre><ul><li>成功打印：</li></ul><pre><code>101112completeddisposed</code></pre><ul><li>失败打印（不会再打印completed了）：</li></ul><pre><code>101112Unhandled error happened: somethingError subscription called from:disposed</code></pre><h3 id="7、使用do（注意：do使用的是onDispose）"><a href="#7、使用do（注意：do使用的是onDispose）" class="headerlink" title="7、使用do（注意：do使用的是onDispose）"></a>7、使用do（注意：do使用的是onDispose）</h3><pre><code>    func test4() {        let customObservable = Observable&lt;Int&gt;.create { (observer) -&gt; Disposable in            observer.onNext(10)            observer.onNext(11)            observer.onNext(12)            observer.onCompleted()            return Disposables.create()        }        let bag = DisposeBag()        customObservable.do(            onNext: { print(&quot;intercepted:\($0)&quot;) },            onCompleted: {  print(&quot;intercepted:completed&quot;) },            onDispose: {print(&quot;intercepted: disposed&quot; ) }            )            .subscribe(            onNext: { print($0)},            onCompleted: {  print(&quot;completed&quot; ) },            onDisposed: {print(&quot;disposed&quot; ) }            ).disposed(by: bag)    }</code></pre><pre><code>intercepted:1010intercepted:1111intercepted:1212intercepted:completedcompleteddisposedintercepted: disposed</code></pre><h3 id="8、debug"><a href="#8、debug" class="headerlink" title="8、debug"></a>8、debug</h3><pre><code>    func test4() {        let customObservable = Observable&lt;Int&gt;.create { (observer) -&gt; Disposable in            observer.onNext(10)            observer.onNext(11)            observer.onNext(12)            observer.onCompleted()            return Disposables.create()        }        let bag = DisposeBag()        customObservable.debug().subscribe(            onNext: { print($0)},            onCompleted: {  print(&quot;completed&quot; ) },            onDisposed: {print(&quot;disposed&quot; ) }            ).disposed(by: bag)    }</code></pre><pre><code>2019-03-01 10:25:29.252: ViewController.swift:187 (test4()) -&gt; subscribed2019-03-01 10:25:29.261: ViewController.swift:187 (test4()) -&gt; Event next(10)102019-03-01 10:25:29.261: ViewController.swift:187 (test4()) -&gt; Event next(11)112019-03-01 10:25:29.261: ViewController.swift:187 (test4()) -&gt; Event next(12)122019-03-01 10:25:29.262: ViewController.swift:187 (test4()) -&gt; Event completedcompleteddisposed</code></pre><h3 id="9-PublishSubject"><a href="#9-PublishSubject" class="headerlink" title="9. PublishSubject"></a>9. PublishSubject</h3><p>PublishSubject即是订阅者，又是观察者：</p><pre><code>        //初始化发送者        let subject = PublishSubject&lt;String&gt;()        //订阅者需要在发送消息前订阅，不然是接收不到订阅前发送的消息的        let scribe1 = subject.subscribe({str in            print(&quot;scribe1 - what happend: \(str)&quot;)        })        //发送一个消息        subject.onNext(&quot;episode1 updated &quot;)        //订阅者被销毁了        scribe1.dispose()        let scribe2 = subject.subscribe({str in            print(&quot;scribe2 - what happend: \(str)&quot;)        })        //发送一个消息        subject.onNext(&quot;episode2 updated &quot;)        subject.onNext(&quot;episode3 updated &quot;)        //订阅者被销毁了        scribe2.dispose()</code></pre><p> 打印结果：</p><pre><code>scribe1 - what happend: next(episode1 updated )scribe2 - what happend: next(episode2 updated )scribe2 - what happend: next(episode3 updated )</code></pre><p>如果还是不很清楚，那么我们结合示意图，来完整演示一下：</p><p><img src="https://note.youdao.com/yws/public/resource/b3da4a5ccb160d519b7bfc579842626c/xmlnote/ACC75440C3B54F718CE1DBCEB7E96017/29010" alt="image"></p><pre><code>    func test5() {        //初始化        let subject = PublishSubject&lt;String&gt;()        //没有订阅，发送事件是接收不到的        subject.onNext(&quot;我是一个事件，但是我不能被接收到。。。&quot;)        //先订阅        subject.subscribe(onNext: { (str) in            print(&quot;我是一号订阅者：&quot;,str)        }, onError: { (error) in            print(error)        }, onCompleted: {            print(&quot;我是一号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是一号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)        //然后发送事件        subject.onNext(&quot;我是一个事件&quot;)        //可以多次订阅        subject.subscribe(onNext: { (str) in            print(&quot;我是二号订阅者：&quot;,str)        }, onError: { (error) in            print(error)        }, onCompleted: {            print(&quot;我是二号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是二号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)        //再次发送一个事件        subject.onNext(&quot;哈哈哈哈，我也是一个事件&quot;)        //更改为完成状态        subject.onCompleted()        //完成后就没法再接收事件了        subject.onNext(&quot;完成后，我不能被接受到&quot;)        //这时候订阅，只能接收到完成的状态        subject.subscribe(onNext: { (str) in            print(&quot;我是三号订阅者：&quot;,str)        }, onError: { (error) in            print(error)        }, onCompleted: {            print(&quot;我是三号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是三号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)    }</code></pre><p>打印结果：</p><pre><code>我是一号订阅者： 我是一个事件我是一号订阅者： 哈哈哈哈，我也是一个事件我是二号订阅者： 哈哈哈哈，我也是一个事件我是一号订阅者：onCompleted我是一号订阅者：onDisposed我是二号订阅者：onCompleted我是二号订阅者：onDisposed我是三号订阅者：onCompleted我是三号订阅者：onDisposed</code></pre><h3 id="10-BehaviorSubject"><a href="#10-BehaviorSubject" class="headerlink" title="10. BehaviorSubject"></a>10. BehaviorSubject</h3><p>BehaviorSubject需要一个初始化值。与PublishSubject不同的是，BehaviorSubject可以接受到最后一条历史值（也就是订阅之前发送的事件）。</p><pre><code>        //初始化发送者        let subject = BehaviorSubject&lt;String&gt;(value: &quot;RxSwift step by step&quot;)        //当没有事件的话，订阅者可以接收到发送者发送的默认值        let scribe1 = subject.subscribe({str in            print(&quot;scribe1 - what happend: \(str)&quot;)        })        //发送一个消息        subject.onNext(&quot;episode1 updated &quot;)        //订阅者被销毁了        scribe1.dispose()        let scribe2 = subject.subscribe({str in            print(&quot;scribe2 - what happend: \(str)&quot;)        })        //发送一个消息        subject.onNext(&quot;episode2 updated &quot;)        subject.onNext(&quot;episode3 updated &quot;)        //订阅者被销毁了        scribe2.dispose()</code></pre><p>打印结果：</p><pre><code>scribe1 - what happend: next(RxSwift step by step)scribe1 - what happend: next(episode1 updated )scribe2 - what happend: next(episode1 updated )scribe2 - what happend: next(episode2 updated )scribe2 - what happend: next(episode3 updated )</code></pre><blockquote><p>注意第三条的打印： scribe2 - what happend: next(episode1 updated ) 当scribe2订阅事件的时候，发送者已经有历史事件了，所以会被scribe2接收到最后一条 （最后一条 最后一条）历史事件</p></blockquote><p>如果产生错误事件：</p><pre><code>   func test6() {        let subject = BehaviorSubject&lt;String&gt;(value: &quot;我是默认事件&quot;)        //如果没有事件，则会接收默认事件        subject.subscribe(onNext: { (str) in            print(&quot;我是一号订阅者：&quot;,str)        }, onError: { (error) in            print(&quot;我是一号订阅者：&quot;,error)        }, onCompleted: {            print(&quot;我是一号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是一号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)        subject.onNext(&quot;我是一个事件&quot;)        subject.onError(NSError(domain: &quot;---&quot;, code: 0, userInfo: [&quot;msg&quot;: &quot;哈哈哈我发送了错误&quot;]))        subject.subscribe(onNext: { (str) in            print(&quot;我是二号订阅者：&quot;,str)        }, onError: { (error) in            print(&quot;我是二号订阅者：&quot;,error)        }, onCompleted: {            print(&quot;我是二号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是二号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)    }</code></pre><p>打印结果：</p><pre><code>我是一号订阅者： 我是默认事件我是一号订阅者： 我是一个事件我是一号订阅者： Error Domain=--- Code=0 &quot;(null)&quot; UserInfo={msg=哈哈哈我发送了错误}我是一号订阅者：onDisposed我是二号订阅者： Error Domain=--- Code=0 &quot;(null)&quot; UserInfo={msg=哈哈哈我发送了错误}我是二号订阅者：onDisposed</code></pre><h3 id="11-ReplaySubject（可以指定历史事件的个数）"><a href="#11-ReplaySubject（可以指定历史事件的个数）" class="headerlink" title="11. ReplaySubject（可以指定历史事件的个数）"></a>11. ReplaySubject（可以指定历史事件的个数）</h3><pre><code>    func test() {        //初始化发送者,并指定l可以接收到历史事件的个数        let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)        //当没有事件的话，订阅者可以接收到发送者发送的默认值        let scribe1 = subject.subscribe({str in            print(&quot;scribe1 - what happend: \(str)&quot;)        })        //发送一个消息        subject.onNext(&quot;episode1 updated &quot;)        //发送一个消息        subject.onNext(&quot;episode1 updated------- &quot;)        //订阅者被销毁了        scribe1.dispose()        let scribe2 = subject.subscribe({str in            print(&quot;scribe2 - what happend: \(str)&quot;)        })        //发送一个消息        subject.onNext(&quot;episode2 updated &quot;)        subject.onNext(&quot;episode3 updated &quot;)        //订阅者被销毁了        scribe2.dispose()    }</code></pre><p>如果是1，打印结果如下：</p><pre><code>scribe1 - what happend: next(episode1 updated )scribe1 - what happend: next(episode1 updated------- )scribe2 - what happend: next(episode1 updated------- )scribe2 - what happend: next(episode2 updated )scribe2 - what happend: next(episode3 updated )</code></pre><p> 如果是2，打印结果如下：</p><pre><code>scribe1 - what happend: next(episode1 updated )scribe1 - what happend: next(episode1 updated------- )scribe2 - what happend: next(episode1 updated )scribe2 - what happend: next(episode1 updated------- )scribe2 - what happend: next(episode2 updated )scribe2 - what happend: next(episode3 updated )</code></pre><blockquote><p>缓冲区是2时，scribe2可以接受到订阅前的2条历史数据（第3、4条的打印信息）</p></blockquote><p>如果不太清楚，那么就再简单点：</p><pre><code>    func test7() {        let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 3)        subject.onNext(&quot;我是第一个事件&quot;)        subject.onNext(&quot;我是第二个事件&quot;)        subject.onNext(&quot;我是第三个事件&quot;)        subject.onNext(&quot;我是第四个事件&quot;)        //如果没有事件，则会接收默认事件        subject.subscribe(onNext: { (str) in            print(&quot;我是一号订阅者：&quot;,str)        }, onError: { (error) in            print(&quot;我是一号订阅者：&quot;,error)        }, onCompleted: {            print(&quot;我是一号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是一号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)        subject.onNext(&quot;我是五个事件&quot;)        subject.subscribe(onNext: { (str) in            print(&quot;我是二号订阅者：&quot;,str)        }, onError: { (error) in            print(&quot;我是二号订阅者：&quot;,error)        }, onCompleted: {            print(&quot;我是二号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是二号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)    }</code></pre><p>打印结果：</p><pre><code>我是一号订阅者： 我是第二个事件我是一号订阅者： 我是第三个事件我是一号订阅者： 我是第四个事件我是一号订阅者： 我是五个事件我是二号订阅者： 我是第三个事件我是二号订阅者： 我是第四个事件我是二号订阅者： 我是五个事件</code></pre><blockquote><p>打印结果说明：我们缓存了3个历史事件，所以只能缓存“最近”的三个事件。一号订阅者订阅前已经产生了4条事件，那么它只能接收到第二三四个事件。此时，在发送一个事件五，一号订阅者正常接收；添加二号订阅者，对于二号订阅者，历史事件是三四五，所以只能接收到三四五事件。</p></blockquote><h3 id="12-Variable"><a href="#12-Variable" class="headerlink" title="12.Variable"></a>12.Variable</h3><pre><code>    func test() {        let stringVariable = Variable(&quot;Episode1&quot;)        let sub1 = stringVariable.asObservable().subscribe({            print(&quot;sub1: \($0)&quot;)        })        //简单写法        print(&quot;easy print:&quot; + stringVariable.value)        //我们还可以修改值，相当于重新发送事件(onNext)        stringVariable.value = &quot;new data&quot;        print(&quot;easy print----:&quot; + stringVariable.value)    }</code></pre><ul><li>打印结果：</li></ul><pre><code>ℹ️ [DEPRECATED] `Variable` is planned for future deprecation. Please consider `BehaviorRelay` as a replacement. Read more at: https://git.io/vNqvxsub1: next(Episode1)easy print:Episode1sub1: next(new data)easy print----:new datasub1: completed</code></pre><p>简单实现：</p><pre><code>    func test8() {        let subject = Variable&lt;String&gt;(&quot;我是默认值&quot;)        subject.asObservable().subscribe(onNext: { (str) in            print(&quot;我是一号订阅者：&quot;,str)        }, onError: { (error) in            print(&quot;我是一号订阅者：&quot;,error)        }, onCompleted: {            print(&quot;我是一号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是一号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)        subject.value = &quot;我是一个新的值111&quot;        subject.value = &quot;我是一个新的值222&quot;        subject.value = &quot;我是一个新的值333&quot;        subject.asObservable().subscribe(onNext: { (str) in            print(&quot;我是二号订阅者：&quot;,str)        }, onError: { (error) in            print(&quot;我是二号订阅者：&quot;,error)        }, onCompleted: {            print(&quot;我是二号订阅者：onCompleted&quot;)        }, onDisposed: {            print(&quot;我是二号订阅者：onDisposed&quot;)        }).disposed(by: disposeBag)    }</code></pre><p>打印结果：</p><pre><code>ℹ️ [DEPRECATED] `Variable` is planned for future deprecation. Please consider `BehaviorRelay` as a replacement. Read more at: https://git.io/vNqvx我是一号订阅者： 我是默认值我是一号订阅者： 我是一个新的值111我是一号订阅者： 我是一个新的值222我是一号订阅者： 我是一个新的值333我是二号订阅者： 我是一个新的值333我是一号订阅者：onCompleted我是一号订阅者：onDisposed我是二号订阅者：onCompleted我是二号订阅者：onDisposed</code></pre><blockquote><p>打印说明：一号订阅者会接收到默认事件，当更改subject的值时，相当于发送了一个next事件，所以一号订阅者可以接收到；二号订阅者可以接受到最后一条历史事件，所以可以接收到“我是一个新的值333”</p></blockquote><hr><h3 id="UI扩展"><a href="#UI扩展" class="headerlink" title="UI扩展"></a>UI扩展</h3><p>我们可以使用2种方式的扩展，一种常规的，一种rx风格的：</p><pre><code>extension UILabel {    //方式1的扩展    public var fontSize: Binder&lt;CGFloat&gt; {        return Binder(self) { (label, fontSize) in            label.font = UIFont.systemFont(ofSize: fontSize)        }    }}extension Reactive where Base: UILabel {    //方式2的扩展    public var rxFontSize: Binder&lt;CGFloat&gt; {        return Binder(self.base) { (label, fontSize) in            label.font = UIFont.systemFont(ofSize: fontSize)        }    }}</code></pre><p>使用的风格：</p><pre><code>func test4() {        //方式1的使用        let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance)        observable.map{CGFloat($0)}.bind(to: myLabel.fontSize).disposed(by: disposeBag)        //方式2的使用        let observable2 = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)        observable2.map{CGFloat($0) * 10}.bind(to: myLabel.rx.rxFontSize).disposed(by: disposeBag)    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift中的开发技巧总结(二)</title>
      <link href="/2019/01/07/2019-01-07-swift-zhong-de-kai-fa-ji-qiao-zong-jie-er/"/>
      <url>/2019/01/07/2019-01-07-swift-zhong-de-kai-fa-ji-qiao-zong-jie-er/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="autoclosure的使用"><a href="#autoclosure的使用" class="headerlink" title="@autoclosure的使用"></a>@autoclosure的使用</h2><h4 id="定义一个尾随闭包"><a href="#定义一个尾随闭包" class="headerlink" title="定义一个尾随闭包"></a>定义一个尾随闭包</h4><pre><code>func logIfTrue(_ predicate: () -&gt; Bool) {    //不要写 predicate,一定要加上()    if predicate() {        print(&quot;true&quot;)    } else {        print(&quot;false&quot;)    }}</code></pre><h4 id="调用时显示的样式"><a href="#调用时显示的样式" class="headerlink" title="调用时显示的样式:"></a>调用时显示的样式:</h4><p><img src="https://upload-images.jianshu.io/upload_images/1773276-9058131234c8cf81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="可以使用这些种写法调用"><a href="#可以使用这些种写法调用" class="headerlink" title="可以使用这些种写法调用:"></a>可以使用这些种写法调用:</h4><pre><code>        logIfTrue { () -&gt; Bool in            return 5 &gt; 6        }        logIfTrue { () -&gt; Bool in            6 &gt; 10        }        logIfTrue {            return 7 &gt; 1        }        logIfTrue {            7 &gt; 1        }</code></pre><blockquote><p>虽然<code>logIfTrue { 7 &gt; 1 }</code>这样写十分的简单明了,但是使用{}还是让人有些困惑.</p></blockquote><h4 id="使用-autoclosure来声明闭包"><a href="#使用-autoclosure来声明闭包" class="headerlink" title="使用@autoclosure来声明闭包:"></a>使用@autoclosure来声明闭包:</h4><pre><code>//仅仅是作为对比,命名不够规范func _logIfTrue(_ predicate: @autoclosure () -&gt; Bool) {    //不要写 predicate,别忘了()    if predicate() {        print(&quot;true&quot;)    } else {        print(&quot;false&quot;)    }}</code></pre><h4 id="调用的提示"><a href="#调用的提示" class="headerlink" title="调用的提示:"></a>调用的提示:</h4><p><img src="https://upload-images.jianshu.io/upload_images/1773276-55a009591d268412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h4><pre><code>//貌似只能这么写        _logIfTrue (7 &gt; 1)</code></pre><blockquote><p>注意: @autoclosure只支持<code>() -&gt; T</code>,并不支持带有输入参数的写法.</p></blockquote><h2 id="逃离闭包-escaping-的使用"><a href="#逃离闭包-escaping-的使用" class="headerlink" title="逃离闭包@escaping 的使用"></a>逃离闭包<code>@escaping</code> 的使用</h2><pre><code>    func doWork(block: () -&gt; ()) {        block()    }</code></pre><blockquote><p>注意:在这种闭包中,block参数中的内容会在dowork返回前调用,也就是block的调用是同步行为.</p></blockquote><h4 id="如果我们开启了异步-让block在dowork返回后被调用-那么就需要-escaping来表明这个闭包会”逃逸”出该方法的"><a href="#如果我们开启了异步-让block在dowork返回后被调用-那么就需要-escaping来表明这个闭包会”逃逸”出该方法的" class="headerlink" title="如果我们开启了异步,让block在dowork返回后被调用,那么就需要@escaping来表明这个闭包会”逃逸”出该方法的:"></a>如果我们开启了异步,让block在dowork返回后被调用,那么就需要<code>@escaping</code>来表明这个闭包会”逃逸”出该方法的:</h4><p><img src="https://upload-images.jianshu.io/upload_images/1773276-333b2eb6c608e836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>    func doWorkAsync(block: @escaping () -&gt; ()) {        DispatchQueue.main.async {            block()        }    }</code></pre><blockquote><p>注意: 我们知道,闭包是可以捕获变量的.在dowork中没有逃逸行为的闭包,原因是因为闭包的作用域不会超过函数本身,所以我们不必担心在闭包内持有self.而接受<code>@escaping</code>的闭包则不同,由于需要确保闭包内的成员依旧有效,因此当我们在闭包内引用了self及其成员的时候,swift便会强制要求我们写出self.</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1773276-613e31ad217a4dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>class User {    var name = &quot;lxx&quot;    func doWork(block: () -&gt; ()) {        block()    }    func doWorkAsync(block: @escaping () -&gt; ()) {        DispatchQueue.main.async {            block()        }    }    func method1() {        doWork {            print(name)        }        name = &quot;dll&quot;    }    func method2() {        doWorkAsync {            print(self.name)        }        name = &quot;lmy&quot;    }}</code></pre><p>调用:</p><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        User().method1()///lxx        User().method2()///lmy    }</code></pre><h4 id="如果我们不希望在闭包中持有self-则可以使用-weak-self-来声明表达式"><a href="#如果我们不希望在闭包中持有self-则可以使用-weak-self-来声明表达式" class="headerlink" title="如果我们不希望在闭包中持有self,则可以使用[weak self]来声明表达式:"></a>如果我们不希望在闭包中持有self,则可以使用<code>[weak self]</code>来声明表达式:</h4><p><img src="https://upload-images.jianshu.io/upload_images/1773276-8e1bf1693b3e3e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>    func method3() {        doWorkAsync {            [weak self] in            print(self?.name ?? &quot;nil&quot;)        }    }</code></pre><h4 id="注意此处的调用结果为”nil”"><a href="#注意此处的调用结果为”nil”" class="headerlink" title="注意此处的调用结果为”nil”"></a>注意此处的调用结果为”nil”</h4><pre><code> User().method3()///nil</code></pre><h4 id="在协议中的使用"><a href="#在协议中的使用" class="headerlink" title="在协议中的使用:"></a>在协议中的使用:</h4><pre><code>protocol P {    func work(block: @escaping () -&gt; ())}class User: P {    // 协议方法也需要使用@escaping    func work(block:  @escaping () -&gt; ()) {    }}</code></pre><h2 id="swift-成员变量的声明"><a href="#swift-成员变量的声明" class="headerlink" title="swift 成员变量的声明"></a>swift 成员变量的声明</h2><p><img src="https://upload-images.jianshu.io/upload_images/1773276-9dce5240f2efa973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>共有两种解决办法:</p><pre><code>class User {    //因为是let,意味着这样初始化后就无法再做修改    let name: String = &quot;&quot;}</code></pre><pre><code>class User {    let name: String    init(name: String) {        self.name = name    }}        let user = User(name: &quot;liuxingxing&quot;)        print(user.name)</code></pre><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h4 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h4><pre><code>struct Vector2D {    var x = 0.0    var y = 0.0}func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {    return Vector2D(x: left.x + right.x, y: left.y + right.y)}class ViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()        let v1 = Vector2D(x: 10, y: 20)        let v2 = Vector2D(x: 5, y: 8)        let v3 = v1 + v2        print(v3)    }}</code></pre><h4 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h4><pre><code>import UIKitstruct Vector2D {    var x = 0.0    var y = 0.0}precedencegroup DotProductPrecedence {    associativity: none    higherThan: MultiplicationPrecedence}infix operator +*: DotProductPrecedence//+*并不是系统的,所以不能通过重载的方式来实现,必须要声明操作符func +* (left: Vector2D, right: Vector2D) -&gt; Double {    return  left.x * right.x +  left.y * right.y}class ViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()        let v1 = Vector2D(x: 10, y: 20)        let v2 = Vector2D(x: 5, y: 8)        let v3 = v1 +* v2        print(v3)//210.0    }}</code></pre><blockquote><p>precedencegroup: 定义了一个操作符的优先级别.操作符优先级的定义和类型声明有些相似,一个操作符必须要属于某个特定的优先级.swift库中已经定义了一些常用的运算符优先级组,比如加法优先级(AdditionPrecedence)和乘法优先级(MultiplictionPrecedence)等,如果没有适合自己的优先级组,就需要自己指定结合律方式和优先级顺序了.</p></blockquote><blockquote><p>associativity:定义了结合律.即如果多个同类的操作符顺序出现的计算顺序.比如常见的加法和减法都是left,就是说多个加法同事出现时按照从左往右的顺序计算(因为加法满足交换律,随意这个顺序无所谓,但是减法的话计算顺序就很重要). 我们定义的点乘不会再和其他的点乘结合使用,所以这里使用none</p></blockquote><blockquote><p>higherThan: 运算符的优先级.点乘运算是优于乘法的.除了higherThan,也支持lowerThan来指定优先级低于某个其他组.</p></blockquote><blockquote><p>infix:定义一个中位操作符.即前后都是输入,其他的修饰还包括prefix,postfix.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> 总结提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局的基本使用总结</title>
      <link href="/2018/12/31/2018-12-31-flex-bu-ju-de-ji-ben-shi-yong-zong-jie/"/>
      <url>/2018/12/31/2018-12-31-flex-bu-ju-de-ji-ben-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Flex布局的基本使用总结"><a href="#Flex布局的基本使用总结" class="headerlink" title="Flex布局的基本使用总结"></a>Flex布局的基本使用总结</h2><p>flex布局是微信小程序开发推荐使用的布局样式，更易上手和学习。你可以从<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰的博客</a>中系统学习到Flex布局，下面是我自己学习上手的记录总结。</p><h4 id="1-初始化我们的布局"><a href="#1-初始化我们的布局" class="headerlink" title="1.初始化我们的布局"></a>1.初始化我们的布局</h4><pre><code>.userContainer {    background-color: darkgreen;    width: 100%;    height: 100%;}.user-item {    background-color: red;    width: 120rpx;    height: 120rpx;    border: 1px solid black;}</code></pre><pre><code>&lt;!--pages/user/user.wxml--&gt;&lt;view class=&quot;userContainer&quot;&gt; &lt;view class=&quot;user-item&quot;&gt;1&lt;/view&gt; &lt;view class=&quot;user-item&quot;&gt;2&lt;/view&gt; &lt;view class=&quot;user-item&quot;&gt;3&lt;/view&gt; &lt;view class=&quot;user-item&quot;&gt;4&lt;/view&gt; &lt;view class=&quot;user-item&quot;&gt;5&lt;/view&gt;&lt;/view&gt;</code></pre><p>默认的显示效果如下:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-b870cf41be2781ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="2-现在我们使用flex布局"><a href="#2-现在我们使用flex布局" class="headerlink" title="2.现在我们使用flex布局:"></a>2.现在我们使用flex布局:</h4><pre><code>.userContainer {    background-color: darkgreen;    width: 100%;    height: 100%;    display: flex;}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-bdbd959e04b1d411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="flex容器的属性"><a href="#flex容器的属性" class="headerlink" title="flex容器的属性"></a>flex容器的属性</h3><h4 id="flex-direction的使用-决定元素的排列方向"><a href="#flex-direction的使用-决定元素的排列方向" class="headerlink" title="flex-direction的使用(决定元素的排列方向):"></a>flex-direction的使用(决定元素的排列方向):</h4><blockquote><p>flex-direction共有四个值,分别为row,row-reverse,column,column-reverse.其中row为默认值.</p></blockquote><p>row-reverse:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-694232d15dc21cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="row-reverse.png"></p><p>column:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-47a05d29bfae2e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="column.png"></p><p>column-reverse:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-f77315b4a173fab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="column-reverse.png"></p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>flex-wrap决定元素在排列不下的时候如何换行。共有3个常用值,nowrap,wrap, wrap-reverse.其中nowrap为默认值.</p><p>nowrap,元素放不下时会被强行拉伸:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-96ffc34ec8aa9ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>wrap,元素排列不下,自动换行:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-fda507407a883dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>wrap-reverse,反向排列:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-e14bd086cfd1d582.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow是flex-direction和flex-wrap的合写:</p><pre><code>flex-flow: row wrap;</code></pre><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content决定元素在主轴的对齐方式。共有6个常用属性,flex-start,flex-end,center,space-between,space-around,space-evently.其中,flex-start为默认值:</p><p>flex-start:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-ae375c2a2c926a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>flex-end:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-eb4129f8ba73c840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>center:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-8d46f812ad61c67a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>space-between:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-c3e939a088723f7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>space-around:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-d0d8f6d3ba1e0852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>space-evenly:</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-a0db2b683ec12a73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items表示元素在侧轴的对齐方式。共有5种常用属性,stretch,center,flex-start,flex-end,baseline.其中stretch为默认属性.</p><p>stretch(如果只是指定宽度,而没有指定高度):</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-10f43a6aa1fe9bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>flex-start(指定了宽高):</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-c42fd5e3329b1699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>flex-end(指定了宽高):</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-f39d3f4ac8c1093a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>baseline(子元素中首行文字对齐):</p><p><img src="https://upload-images.jianshu.io/upload_images/1773276-b9c969062860232d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="flex-元素属性的使用"><a href="#flex-元素属性的使用" class="headerlink" title="flex 元素属性的使用"></a>flex 元素属性的使用</h3><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow表示当有多余空间时,元素的放大比例。默认值为0,表示不会扩大.设置的其他值表示 该元素占据所剩下空间的比例：</p><pre><code>.user-item {    background-color: red;    width: 100rpx;    height: 100rpx;    border: 1px solid black;    flex-grow: 1;}.tree {    display: flex;    align-items: flex-end;    flex-grow: 2;}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-16ee2b62e9172004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink表示当空间不足时,元素的缩放比例。默认是1,表示当空间不足时,默认等比缩小.如果想让其中某个元素不缩小,那么可以将其值更改为0.</p><pre><code>.user-item {    background-color: red;    width: 250rpx;    height: 250rpx;    border: 1px solid black;    /* 默认按比例缩放 */    flex-shrink: 1;}.tree {    display: flex;    align-items: flex-end;    /* 不缩小该元素 */    flex-shrink: 0;}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-f2312d448dbbc7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis表示元素在主轴上占据的空间。</p><pre><code>.user-item {    background-color: red;    width: 200rpx;    height: 200rpx;    border: 1px solid black;}.tree {    display: flex;    align-items: flex-end;    flex-basis: 300rpx;}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-8a763ffb57439759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="flex是grow-shink-basis的简写"><a href="#flex是grow-shink-basis的简写" class="headerlink" title="flex是grow shink basis的简写"></a>flex是grow shink basis的简写</h4><pre><code>.user-item {    background-color: red;    width: 200rpx;    height: 200rpx;    border: 1px solid black;    /* 80会覆盖掉width的200 */    flex: 0 1 80rpx;}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-6fb83a54e78f1ef2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="order-元素的排列顺序"><a href="#order-元素的排列顺序" class="headerlink" title="order 元素的排列顺序"></a>order 元素的排列顺序</h4><pre><code>&lt;view class=&quot;userContainer&quot;&gt; &lt;view class=&quot;user-item&quot; style=&quot;order: 3&quot;&gt;1&lt;/view&gt; &lt;view class=&quot;user-item&quot; style=&quot;order: 4&quot;&gt;2&lt;/view&gt; &lt;view class=&quot;user-item three&quot; style=&quot;order: 1&quot;&gt;3&lt;/view&gt; &lt;view class=&quot;user-item&quot; style=&quot;order: 2&quot;&gt;4&lt;/view&gt;&lt;/view&gt;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-a75b6714d2684886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="align-self-设置自身的对齐方式"><a href="#align-self-设置自身的对齐方式" class="headerlink" title="align-self(设置自身的对齐方式)"></a>align-self(设置自身的对齐方式)</h4><pre><code>.user-item {    background-color: red;    width: 200rpx;    height: 200rpx;    border: 1px solid black;    /* 设置自身的对齐方式*/    align-self: flex-end;}.three {    display: flex;    align-items: flex-end;    /* 设置自身的对齐方式*/    align-self: center;}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="主轴与交叉轴内容的对比"><a href="#主轴与交叉轴内容的对比" class="headerlink" title="主轴与交叉轴内容的对比"></a>主轴与交叉轴内容的对比</h4><pre><code>//主轴.box {  justify-content: flex-start | flex-end | center | space-between | space-around;}//交叉轴.box {  align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre><h4 id="多根轴线对齐方式"><a href="#多根轴线对齐方式" class="headerlink" title="多根轴线对齐方式"></a>多根轴线对齐方式</h4><pre><code>//只有一根轴线，则该属性不起作用.box {  align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre><h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><pre><code>.item {//(1 1 auto) 有剩余空间则放大；空间不足则缩小；保持项目的本来大小；  flex: auto; }.item {//(0 0 auto) 有剩余空间也不放大；空间不足也不缩小；保持项目的本来大小；  flex: none; }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift中的开发技巧总结(一)</title>
      <link href="/2018/12/29/2018-12-29-swift-zhong-de-kai-fa-ji-qiao-zong-jie-yi/"/>
      <url>/2018/12/29/2018-12-29-swift-zhong-de-kai-fa-ji-qiao-zong-jie-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="https://github.com/MobileTipsters/Swift-Daily-Tips" target="_blank" rel="noopener">参考链接</a></h2><h3 id="1、extension-UIView"><a href="#1、extension-UIView" class="headerlink" title="1、extension  UIView"></a>1、extension  UIView</h3><pre><code>extension UIView {    func addSubviews(_ subviews: UIView...) {        subviews.forEach(addSubview)    }}</code></pre><pre><code>    lazy var view1: UIView = {        let view = UIView(frame: CGRect(x: 0, y: 0, width: 100, height: 200))        view.backgroundColor = .red        return view    }()    lazy var view2: UIView = {        let view = UIView(frame: CGRect(x: 0, y: 300, width: 100, height: 200))        view.backgroundColor = .green        return view    }()    override func viewDidLoad() {        super.viewDidLoad()        view.addSubviews(view1,view2)    }</code></pre><h4 id="forEach与forin的区别"><a href="#forEach与forin的区别" class="headerlink" title="forEach与forin的区别"></a>forEach与forin的区别</h4><pre><code>       let array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]        array.forEach { (element) in            if element == &quot;two&quot; {                return            }            print(&quot;foreach:&quot; + element)        }</code></pre><p>result：</p><pre><code>foreach:oneforeach:threeforeach:four</code></pre><pre><code>        let array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]        for element in array {            if element == &quot;two&quot; {                return            }            print(&quot;forin:&quot; + element)        }</code></pre><p>result：</p><pre><code>forin:one</code></pre><blockquote><p>在ForIn 循环中使用return的话，会立即跳出当前的循环体。然而在forEach中，还会继续遍历剩余元素。</p></blockquote><h4 id="2、extension-UILabel"><a href="#2、extension-UILabel" class="headerlink" title="2、extension UILabel"></a>2、extension UILabel</h4><pre><code>extension UILabel {    static func initForTitle() -&gt; UILabel {        let label = UILabel()        label.font = .boldSystemFont(ofSize: 27)        label.textColor = .darkGray        label.numberOfLines = 1        //根据label的宽度自动更改文字的大小        label.adjustsFontSizeToFitWidth = true        label.minimumScaleFactor = 0.2        //文本基线的行为//        label.baselineAdjustment = .alignBaselines        label.textAlignment = .center        label.backgroundColor = .red        return label    }}</code></pre><pre><code>    func test() {        let label = UILabel.initForTitle()        label.frame = CGRect(x: 0, y: 600, width: 400, height: 80)        label.text = &quot;中华人民共和国&quot;        view.addSubview(label)    }</code></pre><h4 id="3、extension-UIColor"><a href="#3、extension-UIColor" class="headerlink" title="3、extension UIColor"></a>3、extension UIColor</h4><pre><code>extension UIColor {    // UIColor(r: 95, g: 199, b: 220)    convenience init(r: Int, g: Int, b: Int) {        self.init(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: 1.0)    }    // UIColor(hex: 0x5fc7dc)    convenience init(hex:Int) {        self.init(r:(hex &gt;&gt; 16) &amp; 0xff, g:(hex &gt;&gt; 8) &amp; 0xff, b:hex &amp; 0xff)    }}</code></pre><pre><code>label.textColor = UIColor(hex: 0x5fc7dc)</code></pre><h4 id="4、滑动关闭键盘"><a href="#4、滑动关闭键盘" class="headerlink" title="4、滑动关闭键盘"></a>4、滑动关闭键盘</h4><pre><code>// Dismiss your keyboard when you are// scrolling your tableView down interactively.tableView.keyboardDismissMode = .interactive</code></pre><h4 id="5、自动填充"><a href="#5、自动填充" class="headerlink" title="5、自动填充"></a>5、自动填充</h4><pre><code>// To enable security code autofill on a UITextField we need to set the textContentType property to .oneTimeCode.otpTextField.textContentType = .oneTimeCode</code></pre><h4 id="6、数组筛选"><a href="#6、数组筛选" class="headerlink" title="6、数组筛选"></a>6、数组筛选</h4><pre><code>        let array = [1, 4, 6, 7, 8]        let sort = array.filter {$0 % 2 == 0}        print(sort)//[4, 6, 8]        let array2 = [&quot;a&quot;, &quot;12&quot;, &quot;csd&quot;, &quot;4567&quot;, &quot;88888&quot;]        let sort2 = array2.filter {$0.count &gt; 3}        print(sort2)//[&quot;4567&quot;, &quot;88888&quot;]</code></pre><h4 id="7、guard-校验"><a href="#7、guard-校验" class="headerlink" title="7、guard 校验"></a>7、guard 校验</h4><pre><code>/*  What makes the “guard” statement truly stand out,  however, is that unwrapped optional values remain  available in the rest of the code block.*/private func fetchContents() {    webService.fetchCategories { [weak self] (response) in        // Optional Binding for self        guard let self = self else { return }        self.createloadMoreRequest(content: response)                   }}private func createloadMoreRequest(content: Content?) {    // Optional Binding for content    guard let content = content else { return }    let categoryId = content.categoryId    self.loadMore(id: categoryId)}</code></pre><h3 id="8-array的操作"><a href="#8-array的操作" class="headerlink" title="8.array的操作"></a>8.array的操作</h3><pre><code>// Use .first(where: (Int) throws -&gt; Bool)// to retrieve first elemen in an array which contains// the same conditional objects.let numbers = [3, 7, 4, -2, 9, -6, 10, 1]if let firstNegative = numbers.first(where: { $0 &lt; 0 }) {    print(&quot;The first negative number is \(firstNegative).&quot;)}// Prints &quot;The first negative number is -2.&quot;</code></pre><h3 id="9-array判断条件"><a href="#9-array判断条件" class="headerlink" title="9.array判断条件"></a>9.array判断条件</h3><pre><code>        // The following code uses this method to test whether all        // the names in an array have at least five characters:        let names = [&quot;Sofia&quot;, &quot;Camilla&quot;, &quot;Martina&quot;, &quot;Mateo&quot;, &quot;Nicolás&quot;]        let allHaveAtLeastFive = names.allSatisfy({ $0.count &gt;= 5 })        // allHaveAtLeastFive == true        //是否都小于10        let digits = 0...9        let areAllSmallerThanTen = digits.allSatisfy { $0 &lt; 10 }        print(allHaveAtLeastFive,areAllSmallerThanTen)</code></pre><h3 id="10-defer延迟执行"><a href="#10-defer延迟执行" class="headerlink" title="10.defer延迟执行"></a>10.defer延迟执行</h3><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        print(&quot;start&quot;)        test()        print(&quot;end&quot;)    }    func test() {        defer { print(&quot;End of the function&quot;) }        print(&quot;Main body of the simleDefer function&quot;)    }//start//Main body of the simleDefer function//End of the function//end</code></pre><h3 id="11-inout的使用"><a href="#11-inout的使用" class="headerlink" title="11.inout的使用"></a>11.inout的使用</h3><pre><code>    func test() {        var n1 = 10, n2 = 20        swapNumber(num1: &amp;n1, num2: &amp;n2)        print(n1,n2)    }    func swapNumber( num1: inout Int, num2: inout Int) {        let temp = num1        num1 = num2        num2 = temp    }</code></pre><h3 id="12-准换大小写"><a href="#12-准换大小写" class="headerlink" title="12.准换大小写"></a>12.准换大小写</h3><pre><code>        let cast = [&quot;Name&quot;, &quot;NAME&quot;, &quot;namE&quot;]        let lowerCast = cast.map { $0.lowercased() }        print(lowerCast)//[&quot;name&quot;, &quot;name&quot;, &quot;name&quot;]        let count = cast.map { $0.count }        print(count)//[4, 4, 4]</code></pre><h3 id="13-筛选"><a href="#13-筛选" class="headerlink" title="13.筛选"></a>13.筛选</h3><pre><code>        let array = [&quot;1&quot;, &quot;3&quot;, &quot;three&quot;, &quot;4///&quot;, &quot;5&quot;, &quot;let&quot;]        let numberArray: [Int?] = array.map { Int($0) }        let number2Array:[Int] = array.compactMap { Int($0) }        print(numberArray)//[Optional(1), Optional(3), nil, nil, Optional(5), nil]        print(number2Array)//[1, 3, 5]</code></pre><h3 id="14-排序"><a href="#14-排序" class="headerlink" title="14.排序"></a>14.排序</h3><pre><code>        let array = [11, 3,  25, 17]        let sorted = array.sorted(by: &gt;)        print(sorted)//[25, 17, 11, 3]</code></pre><h3 id="15-自定义运算符"><a href="#15-自定义运算符" class="headerlink" title="15.自定义运算符"></a><a href="http://www.cnblogs.com/muzijie/p/6591045.html" target="_blank" rel="noopener">15.自定义运算符</a></h3><p>inflx 中：</p><pre><code>infix operator ∈func ∈ &lt;T: Equatable&gt;(lhs: T, rhs: [T]) -&gt; Bool {    return rhs.contains(lhs)}        let month = &quot;September&quot;        if month ∈ [&quot;April&quot;, &quot;June&quot;, &quot;September&quot;, &quot;November&quot;] {            print(&quot;\(month) has 30 days.&quot;)        }        //September has 30 days.</code></pre><p>prefix：</p><pre><code>// 前置：返回2的n次方prefix operator  ^prefix func ^ (vector: Double) -&gt; Double {    return pow(2, vector)}print(^5)  // 32.0</code></pre><p>postfix：</p><pre><code>postfix operator ^postfix func ^ (vector: Int) -&gt; Int {    return vector * vector} print(5^)  // 25</code></pre><h3 id="16-获取枚举中有多少个case-swift4-2新特性"><a href="#16-获取枚举中有多少个case-swift4-2新特性" class="headerlink" title="16.获取枚举中有多少个case(swift4.2新特性)"></a>16.获取枚举中有多少个case(swift4.2新特性)</h3><pre><code>    enum CompassDirection: CaseIterable {        case east, west, south, north    }    override func viewDidLoad() {        super.viewDidLoad()        print(&quot;there are \(CompassDirection.allCases.count) directions&quot;)        for direction in CompassDirection.allCases {            print(&quot;i want to go \(direction)&quot;)        }    }</code></pre><pre><code>there are 4 directionsi want to go easti want to go westi want to go southi want to go north</code></pre><h3 id="17-对数组进行乱序操作"><a href="#17-对数组进行乱序操作" class="headerlink" title="17.对数组进行乱序操作"></a>17.对数组进行乱序操作</h3><pre><code>        var array = [&quot;name&quot;, 1, true, &quot;age&quot;, 6, &quot;liuxingxing&quot;] as [Any]        let shuffledArray = array.shuffled()        print(shuffledArray)        array.shuffle()        print(array)</code></pre><pre><code>[6, &quot;age&quot;, &quot;name&quot;, true, 1, &quot;liuxingxing&quot;][6, &quot;liuxingxing&quot;, true, &quot;name&quot;, &quot;age&quot;, 1]</code></pre><h3 id="18-计算属性"><a href="#18-计算属性" class="headerlink" title="18.计算属性"></a>18.计算属性</h3><pre><code>class Person {    var name: String?    var surname: String?    var fullname: String? {        guard let name = name, let surname = surname else {            return nil        }        return &quot;\(name)\(surname)&quot;    }}        let person = Person()        person.name = &quot;xingxing&quot;        person.surname = &quot;liu&quot;        print(person.fullname)</code></pre><h3 id="19-静态属性"><a href="#19-静态属性" class="headerlink" title="19.静态属性"></a>19.静态属性</h3><pre><code>    struct Constant {        static let baseUrl = &quot;https://xxxxxxx&quot;        static let backgroundColor = UIColor.red    }    override func viewDidLoad() {        super.viewDidLoad()        let myUrl = URL(string: Constant.baseUrl)        view.backgroundColor = Constant.backgroundColor    }</code></pre><h3 id="20-类方法与静态方法-类方法子类可以重写-静态方法没法重写"><a href="#20-类方法与静态方法-类方法子类可以重写-静态方法没法重写" class="headerlink" title="20.类方法与静态方法(类方法子类可以重写,静态方法没法重写)"></a>20.类方法与静态方法(类方法子类可以重写,静态方法没法重写)</h3><blockquote><p>error: Cannot override static method</p><pre><code>class Service {    class func fetchData() {        print(&quot;this is Service&quot;)    }    static func sendData() {        print(&quot;this is static method&quot;)    }}class MovieService: Service {    override class func fetchData() {        print(&quot;this is movieService&quot;)    }    //error: Cannot override static method//    override static func sendData() {//        print(&quot;this is movieService&quot;)//    }}</code></pre></blockquote><h3 id="21-懒加载"><a href="#21-懒加载" class="headerlink" title="21.懒加载"></a>21.懒加载</h3><pre><code>class DataImporter {    //假使这个类需要初始化需要很长时间    var filename = &quot;data.text&quot;}class DataManager {    lazy var importer = DataImporter()    var data = [String]()}    override func viewDidLoad() {        super.viewDidLoad()        let manager = DataManager()        manager.data.append(&quot;a data&quot;)        manager.data.append(&quot;more data&quot;)        //此时DataImporter的实例还没有被初始化    }</code></pre><h3 id="22-当函数有返回值时-却没有接收这个返回值-会发生警告Result-of-call-to-39-add-39-is-unused-可以通过-discardableResult来抑制该警告"><a href="#22-当函数有返回值时-却没有接收这个返回值-会发生警告Result-of-call-to-39-add-39-is-unused-可以通过-discardableResult来抑制该警告" class="headerlink" title="22.当函数有返回值时,却没有接收这个返回值,会发生警告Result of call to &#39;add()&#39; is unused,可以通过@discardableResult来抑制该警告"></a>22.当函数有返回值时,却没有接收这个返回值,会发生警告<code>Result of call to &#39;add()&#39; is unused</code>,可以通过<code>@discardableResult</code>来抑制该警告</h3><pre><code>    var number = 10    override func viewDidLoad() {        super.viewDidLoad()        //Result of call to &#39;add()&#39; is unused       add()       print(number)    }    @discardableResult    func add() -&gt; Int {        number += 1        return number    }</code></pre><h3 id="23-使用元组作为返回值"><a href="#23-使用元组作为返回值" class="headerlink" title="23.使用元组作为返回值"></a>23.使用元组作为返回值</h3><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        let statistics = calculate(scores: [1, 2, 3, 4, 5])        print(statistics.max)//5        print(statistics.min)//1        print(statistics.sum)//15        print(statistics.2)//15    }    func calculate(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {        guard let min = scores.min(), let max = scores.max() else {            fatalError(&quot;scores is nil&quot;)        }        //map,reduce,filter        //public func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result        //0 是为 initialResultw赋值的,为初始化值        let sum = scores.reduce(0){ $0 + $1 }//如果将0更改为5,那么sum将由15更改为20//        let numberSum = numbers.reduce(0, { x, y in//            x + y//        })        return (min, max, sum)    }</code></pre><h3 id="24-属性观察者"><a href="#24-属性观察者" class="headerlink" title="24.属性观察者"></a>24.属性观察者</h3><pre><code>    struct MyClass {        var name: String {            willSet {                print(&quot;value is \(name)&quot;)                print(&quot;value will be \(newValue)&quot;)            }            didSet {                print(&quot;value is \(name)&quot;)                print(&quot;value was \(oldValue)&quot;)            }        }    }    override func viewDidLoad() {        super.viewDidLoad()        var test = MyClass(name: &quot;LXX&quot;)//此时并未调用willset和didSet,数据&quot;再次赋值&quot;的时候才会调用,即使和原来的值一样也会再次调用        test.name = &quot;DLL&quot;    }</code></pre><pre><code>value is LXXvalue will be DLLvalue is DLLvalue was LXX</code></pre><h3 id="25-属性只读public-private-set"><a href="#25-属性只读public-private-set" class="headerlink" title="25.属性只读public private(set)"></a>25.属性只读<code>public private(set)</code></h3><pre><code>    struct MyClass {        public private(set) var name: String    }    override func viewDidLoad() {        super.viewDidLoad()        var test = MyClass(name: &quot;LXX&quot;)        print(test.name)        //编译错误:Cannot assign to property: &#39;name&#39; setter is inaccessible        //test.name = &quot;DLL&quot;    }</code></pre><h3 id="26-数组拼接成字符串-字符串拆分成数组"><a href="#26-数组拼接成字符串-字符串拆分成数组" class="headerlink" title="26.数组拼接成字符串,字符串拆分成数组"></a>26.数组拼接成字符串,字符串拆分成数组</h3><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        let names = [&quot;DLL&quot;, &quot;LXX&quot;, &quot;LMY&quot;]        let nameString = names.joined()        print(nameString)//默认拼接        let nameString2 = names.joined(separator: &quot;-&quot;)        print(nameString2)//以&quot;-&quot;拼接        let array = nameString2.split(separator: &quot;-&quot;)        print(array)//以&quot;-&quot;拆分成c数组    }DLLLXXLMYDLL-LXX-LMY[&quot;DLL&quot;, &quot;LXX&quot;, &quot;LMY&quot;]</code></pre><h3 id="27-switch的”穿透”效果"><a href="#27-switch的”穿透”效果" class="headerlink" title="27.switch的”穿透”效果"></a>27.switch的”穿透”效果</h3><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        let integerToDescribe = 5        var description = &quot;The number \(integerToDescribe) is&quot;        switch integerToDescribe {        case 2, 3, 5, 7, 11, 13, 17, 19:            description += &quot; a prime number, and also&quot;            fallthrough        default:            description += &quot; an integer.&quot;        }        print(description)    }    The number 5 is a prime number, and also an integer.</code></pre><h3 id="28-泛型函数"><a href="#28-泛型函数" class="headerlink" title="28.泛型函数"></a>28.泛型函数</h3><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        var num1 = 3        var num2 = 9        swapTwoValues(&amp;num1, &amp;num2)        print(num1)        print(num2)    }    func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {        let temp = a        a = b        b = temp    }</code></pre><h3 id="29-快速交换"><a href="#29-快速交换" class="headerlink" title="29.快速交换"></a>29.快速交换</h3><pre><code>    override func viewDidLoad() {        super.viewDidLoad()        var num1 = &quot;abc&quot;        var num2 = &quot;efg&quot;        var num3 = &quot;hij&quot;        print(num1)        print(num2)        print(num3)        (num1, num2, num3) = (num2, num3, num1)        print(num1)        print(num2)        print(num3)    }abcefghijefghijabc</code></pre><h3 id="30-Builder-Pattern"><a href="#30-Builder-Pattern" class="headerlink" title="30.Builder Pattern"></a>30.Builder Pattern</h3><pre><code>protocol Builder {}extension Builder {    public func with(configure: (inout Self) -&gt; Void) -&gt; Self {        var this = self        configure(&amp;this)        return this    }}//让NSObject遵守该协议extension NSObject: Builder {}class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {//    let tab = UITableView().with(configure: &lt;#T##(inout UITableView) -&gt; Void#&gt;)    private let baseTableView = UITableView(frame: CGRect(x: 0, y: 0, width: 100, height: 200), style: .plain).with { (tableView) in        tableView.backgroundColor = .red        tableView.separatorColor = .darkGray        tableView.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 10.0, right: 0)        tableView.allowsMultipleSelection = true        tableView.register(UITableViewCell.self, forCellReuseIdentifier: &quot;cell&quot;)        tableView.frame = CGRect(x: 100, y: 200, width: 300, height: 300)//此时这里的位置是有效的    }    override func viewDidLoad() {        super.viewDidLoad()        view.addSubview(baseTableView)        baseTableView.delegate = self        baseTableView.dataSource = self    }    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {        return 10    }    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;cell&quot;, for: indexPath)        cell.textLabel?.text = &quot;99999&quot;        return cell    }}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1773276-6c7091ed01755407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> 总结提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库入门2</title>
      <link href="/2018/10/02/2018-10-02-shu-ju-ku-ru-men-2/"/>
      <url>/2018/10/02/2018-10-02-shu-ju-ku-ru-men-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><h4 id="无查询条件的查询"><a href="#无查询条件的查询" class="headerlink" title="无查询条件的查询"></a>无查询条件的查询</h4><h5 id="基本查询："><a href="#基本查询：" class="headerlink" title="基本查询："></a>基本查询：</h5><pre><code>select *from student ;</code></pre><h5 id="倒序查询5条数据："><a href="#倒序查询5条数据：" class="headerlink" title="倒序查询5条数据："></a>倒序查询5条数据：</h5><pre><code>select *from student order by id desc limit 0,5 ;</code></pre><h5 id="基础查询：查询数据量（设置别名：-字段名-as-别名）"><a href="#基础查询：查询数据量（设置别名：-字段名-as-别名）" class="headerlink" title="基础查询：查询数据量（设置别名： 字段名 as 别名）"></a>基础查询：查询数据量（设置别名： 字段名 as 别名）</h5><pre><code>select name as n,sex as s,age as a from stu;select name n,sex s,age a from stu;</code></pre><pre><code>select count(name) from student;select count(name) from student where age&gt;=26;select count(name) as total from student where age&gt;=26;</code></pre><h5 id="查询空值-null"><a href="#查询空值-null" class="headerlink" title="查询空值 null"></a>查询空值 null</h5><pre><code>select *from stu where number is null;</code></pre><h5 id="查询非空值-not-null"><a href="#查询非空值-not-null" class="headerlink" title="查询非空值 not null"></a>查询非空值 not null</h5><pre><code>select *from stu where number is not null;</code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><pre><code>select *from student where age=25;select *from student where age=25 and id&gt;=4;select *from student where sex=&#39;女&#39; or age&gt;=50;select *from student where not id=2;select *from student where  id%2=1;</code></pre><h5 id="使用in："><a href="#使用in：" class="headerlink" title="使用in："></a>使用in：</h5><pre><code>select *from student where id in(1,2,5);</code></pre><h5 id="使用between"><a href="#使用between" class="headerlink" title="使用between"></a>使用between</h5><p>查到3 4 5 三条数据：</p><pre><code>select *from student where id between 3 and 5;</code></pre><h5 id="like-模糊查询"><a href="#like-模糊查询" class="headerlink" title="like 模糊查询"></a>like 模糊查询</h5><pre><code>select *from student where name like&#39;鲁%&#39;;select *from student where name like&#39;%博%&#39;;</code></pre><h4 id="使用distinct查询唯一值"><a href="#使用distinct查询唯一值" class="headerlink" title="使用distinct查询唯一值"></a>使用distinct查询唯一值</h4><p>表里的全部数据：</p><pre><code>mysql&gt; select * from user;+----+-------------+------+---------------------+------+------+| id | name        | age  | email               | sign | grad |+----+-------------+------+---------------------+------+------+|  1 | liuxingxing |   23 | lxxwork0827@163.com |   10 | A    ||  2 | qian        |   23 | lxxwork0827@163.com |   30 | B    ||  3 | zhao        |   21 | zhaoemail           |    3 | A    ||  4 | qian        |   23 | lxxwork0827@163.com |    2 | B    ||  5 | zhao        |   23 | lxxwork0827@163.com |    2 | A    ||  6 | qian        |   23 | lxxwork0827@163.com |    7 | B    ||  7 | liudehua    |   23 | lxxwork0827@163.com |   77 | A    |+----+-------------+------+---------------------+------+------+7 rows in set (0.00 sec)</code></pre><p>使用distinct对name进行去重：</p><pre><code>mysql&gt; select distinct name from user;+-------------+| name        |+-------------+| liuxingxing || qian        || zhao        || liudehua    |+-------------+4 rows in set (0.00 sec)</code></pre><p>但是当我们想要同时筛选出id时，结果并非我们预想的那样（mysql 只会将name 和id 都重复给过滤掉，所以都给筛选出来了）：</p><pre><code>mysql&gt; select distinct name, id  from user;+-------------+----+| name        | id |+-------------+----+| liuxingxing |  1 || qian        |  2 || zhao        |  3 || qian        |  4 || zhao        |  5 || qian        |  6 || liudehua    |  7 |+-------------+----+7 rows in set (0.00 sec)</code></pre><p>如果试图将id 也加上distinct，就会报语法错误：</p><pre><code>mysql&gt; select distinct name,  distinct id  from user;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;distinct id  from user&#39; at line 1</code></pre><p> 实际中我们往往用distinct来返回不重复字段的条数（count(distinct name)）,其原因是distinct只能返回他的目标字段，而无法返回其他字段:</p><pre><code>mysql&gt; select count(distinct name)  from user;+----------------------+| count(distinct name) |+----------------------+|                    4 |+----------------------+1 row in set (0.00 sec)</code></pre><h4 id="group分组查询"><a href="#group分组查询" class="headerlink" title="group分组查询"></a>group分组查询</h4><p>注意：分组只能是分组后的数量而不能是分组后的组里信息。</p><pre><code>select 字段或聚合函数 from 表名 group by常用的聚合函数有：avg count max min sum</code></pre><h5 id="连表查询举例（蛮重要的）"><a href="#连表查询举例（蛮重要的）" class="headerlink" title="连表查询举例（蛮重要的）"></a>连表查询举例（蛮重要的）</h5><p>查询一张表的数据如下：</p><pre><code>mysql&gt; select * from user;+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | li        |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.00 sec)</code></pre><p>统计不同edu的人数：</p><pre><code>mysql&gt; select edu,count(*) from user group by edu;+-----+----------+| edu | count(*) |+-----+----------+|   1 |        4 ||   2 |        2 ||   3 |        3 ||   6 |        2 ||   5 |        2 ||   4 |        2 |+-----+----------+6 rows in set (0.00 sec)</code></pre><p>如果我们此刻想要知道每个edu下每个人的名字，直接查询会出错：</p><pre><code>mysql&gt; select edu,name, count(*) from user group by edu;ERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;db_edu.user.name&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</code></pre><p>我们此刻便可以使用group_concat()来完成此需求：</p><pre><code>mysql&gt; select edu,group_concat(name), count(*) from user group by edu;+-----+--------------------------+----------+| edu | group_concat(name)       | count(*) |+-----+--------------------------+----------+|   1 | 刘二拐,sun,feng,zhang    |        4 ||   2 | li,zhao                  |        2 ||   3 | wang,zhou,chen           |        3 ||   4 | zheng,chu                |        2 ||   5 | wu,wei                   |        2 ||   6 | qian,yang                |        2 |+-----+--------------------------+----------+6 rows in set (0.01 sec)</code></pre><p><strong>如果此刻，我们想要将edu字段对应的另一张表的tb_edu.edu具体信息查出来：</strong></p><p>通过嵌套查询：</p><pre><code>mysql&gt; select edu,(select tb_edu.edu from tb_edu where tb_edu.id=user.edu) as edu_name, group_concat(name), count(*) from user group by edu;+-----+----------+--------------------------+----------+| edu | edu_name | group_concat(name)       | count(*) |+-----+----------+--------------------------+----------+|   1 | 小学     | 刘二拐,sun,feng,zhang    |        4 ||   2 | 初中     | 李大狗,zhao              |        2 ||   3 | 高中     | wang,zhou,chen           |        3 ||   4 | 本科     | zheng,chu                |        2 ||   5 | 硕士     | wu,wei                   |        2 ||   6 | 博士     | qian,yang                |        2 |+-----+----------+--------------------------+----------+6 rows in set (0.00 sec)</code></pre><p>连表查询：</p><pre><code>mysql&gt; select user.edu, tb_edu.edu, group_concat(name), count(*) from user join tb_edu on user.edu=tb_edu.id  group by user.edu;+-----+--------+--------------------------+----------+| edu | edu    | group_concat(name)       | count(*) |+-----+--------+--------------------------+----------+|   1 | 小学   | 刘二拐,sun,feng,zhang    |        4 ||   2 | 初中   | 李大狗,zhao              |        2 ||   3 | 高中   | wang,zhou,chen           |        3 ||   4 | 本科   | zheng,chu                |        2 ||   5 | 硕士   | wu,wei                   |        2 ||   6 | 博士   | qian,yang                |        2 |+-----+--------+--------------------------+----------+6 rows in set (0.00 sec)</code></pre><h4 id="多字段通过group分组"><a href="#多字段通过group分组" class="headerlink" title="多字段通过group分组"></a>多字段通过group分组</h4><pre><code>mysql&gt; select age,edu,group_concat(name),count(*)  from user group by edu,age;+-----+-----+--------------------+----------+| age | edu | group_concat(name) | count(*) |+-----+-----+--------------------+----------+|  42 |   1 | sun                |        1 ||  55 |   1 | zhang              |        1 ||  67 |   1 | feng               |        1 || 123 |   1 | 刘二拐             |        1 ||  22 |   2 | li                 |        1 ||  25 |   2 | zhao               |        1 ||  25 |   3 | chen               |        1 ||  26 |   3 | wang               |        1 ||  34 |   3 | zhou               |        1 ||  64 |   4 | zheng              |        1 ||  72 |   4 | chu                |        1 ||  53 |   5 | wu                 |        1 ||  81 |   5 | wei                |        1 ||  19 |   6 | yang               |        1 ||  32 |   6 | qian               |        1 |+-----+-----+--------------------+----------+15 rows in set (0.00 sec)mysql&gt; select age,edu,group_concat(name),count(*)  from user group by age,edu;+-----+-----+--------------------+----------+| age | edu | group_concat(name) | count(*) |+-----+-----+--------------------+----------+|  19 |   6 | yang               |        1 ||  22 |   2 | li                 |        1 ||  25 |   2 | zhao               |        1 ||  25 |   3 | chen               |        1 ||  26 |   3 | wang               |        1 ||  32 |   6 | qian               |        1 ||  34 |   3 | zhou               |        1 ||  42 |   1 | sun                |        1 ||  53 |   5 | wu                 |        1 ||  55 |   1 | zhang              |        1 ||  64 |   4 | zheng              |        1 ||  67 |   1 | feng               |        1 ||  72 |   4 | chu                |        1 ||  81 |   5 | wei                |        1 || 123 |   1 | 刘二拐             |        1 |+-----+-----+--------------------+----------+15 rows in set (0.00 sec)</code></pre><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><blockquote><p>having是针对结果集做操作的， 而where是针对表做操作的。(也就是说，having在数据分组之后进行过滤来选择分组，而where在分组之前用来选择记录。另外，where排除的记录不再包括在分组中。)</p></blockquote><h4 id="having查询举例"><a href="#having查询举例" class="headerlink" title="having查询举例"></a>having查询举例</h4><h5 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h5><p>举例1: 筛选利润大于300的商品</p><pre><code>select goods_name, (market_price-cast_price) as profit  from goods having profit &gt; 300;</code></pre><p>举例2: 筛选总利润大于50000的商品类别</p><pre><code>select category, sum((market_price-cast_price) * goods_count_left) as category_profit_total  from goods group by category having category_profit_total &gt; 50000;</code></pre><p>举例3：获取男女人数超过3人的组的个数</p><pre><code>select  count(sex) as sexnum from student group by sex having sexnum&gt;3;//得到4</code></pre><p>举例4：获取学生姓名个数</p><pre><code>select name,count(name) from student group by name;</code></pre><p>举例5：获取学生姓名个数和该名字中最大年龄并逆序</p><pre><code>select name,count(name) as namecount,max(age) as maxold from student group by name desc;</code></pre><h5 id="具体例子：根据不同教育edu类型的人数筛选出人数不小于3-的信息。"><a href="#具体例子：根据不同教育edu类型的人数筛选出人数不小于3-的信息。" class="headerlink" title="具体例子：根据不同教育edu类型的人数筛选出人数不小于3 的信息。"></a>具体例子：根据不同教育edu类型的人数筛选出人数不小于3 的信息。</h5><p>现有user表数据如下：</p><pre><code>mysql&gt; select * from user;+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | 李大狗    |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.01 sec)</code></pre><p>按照edu的类别进行分组：</p><pre><code>mysql&gt; select edu,group_concat(name), count(*) from user group by edu ;+-----+--------------------------+----------+| edu | group_concat(name)       | count(*) |+-----+--------------------------+----------+|   1 | 刘二拐,sun,feng,zhang    |        4 ||   2 | 李大狗,zhao              |        2 ||   3 | wang,zhou,chen           |        3 ||   4 | zheng,chu                |        2 ||   5 | wu,wei                   |        2 ||   6 | qian,yang                |        2 |+-----+--------------------------+----------+6 rows in set (0.00 sec)</code></pre><p>统计出edu类别人数不小于3人的类别信息：    </p><pre><code>mysql&gt; select edu,group_concat(name), count(*) as userCount  from user group by edu having count(*)&gt;=3;+-----+--------------------------+-----------+| edu | group_concat(name)       | userCount |+-----+--------------------------+-----------+|   1 | 刘二拐,sun,feng,zhang    |         4 ||   3 | wang,zhou,chen           |         3 |+-----+--------------------------+-----------+2 rows in set (0.00 sec)</code></pre><h4 id="具体例子：查出两门及两门以上不及格者的平均成绩"><a href="#具体例子：查出两门及两门以上不及格者的平均成绩" class="headerlink" title="具体例子：查出两门及两门以上不及格者的平均成绩"></a>具体例子：查出两门及两门以上不及格者的平均成绩</h4><p>创建表并插入数据：</p><pre><code>​```create table tb_score(name varchar(20),subject varchar(20),score tinyint unsigned) engine myisam charset utf8;insert into tb_score (name, subject, score)values(&#39;张三&#39;,&#39;语文&#39;, &#39;78&#39;),(&#39;张三&#39;,&#39;数学&#39;, &#39;38&#39;),(&#39;张三&#39;,&#39;地理&#39;, &#39;58&#39;),(&#39;李四&#39;,&#39;语文&#39;, &#39;25&#39;),(&#39;李四&#39;,&#39;数学&#39;, &#39;78&#39;),(&#39;李四&#39;,&#39;地理&#39;, &#39;33&#39;),(&#39;王五&#39;,&#39;语文&#39;, &#39;66&#39;),(&#39;王五&#39;,&#39;数学&#39;, &#39;90&#39;),(&#39;王五&#39;,&#39;地理&#39;, &#39;21&#39;);​```</code></pre><p>实验：</p><pre><code>//error:想要通过count来筛选出挂科数是不行的 count（0）与count（1）筛选出的结果是一样的。select name, avg(score), count(score&lt;60) as c from tb_score group by name having c&gt;=2;//first:获取每个同学的平均成绩select name, avg(score)  from tb_score group by name;//获取每个人的每科是否挂了 select name, subject, (score&lt;60) as fail from tb_score;//获取每个人的挂科数select name, sum(score&lt;60) as fail_count from tb_score group by name;//正确(也就是将错误的语句中的count 换成 sum即可)：select name, avg(score), sum(score&lt;60) as c from tb_score group by name having c&gt;=2;</code></pre><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><pre><code>select *from student order by age desc;</code></pre><h5 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h5><pre><code>select *from student order by age desc， name desc</code></pre><h5 id="查询出年龄最大的人的id"><a href="#查询出年龄最大的人的id" class="headerlink" title="查询出年龄最大的人的id"></a>查询出年龄最大的人的id</h5><pre><code>select  id from stu where age=(select max(age) from stu);</code></pre><h5 id="分组后使用-order-by"><a href="#分组后使用-order-by" class="headerlink" title="分组后使用 order by"></a>分组后使用 order by</h5><pre><code>mysql&gt; select group_concat(age) as total_age,edu,group_concat(name) as total_name,count(*) as total_count  from user group by edu;+--------------+-----+--------------------------+-------------+| total_age    | edu | total_name               | total_count |+--------------+-----+--------------------------+-------------+| 123,42,67,55 |   1 | 刘二拐,sun,feng,zhang    |           4 || 22,25        |   2 | li,zhao                  |           2 || 26,34,25     |   3 | wang,zhou,chen           |           3 || 64,72        |   4 | zheng,chu                |           2 || 53,81        |   5 | wu,wei                   |           2 || 32,19        |   6 | qian,yang                |           2 |+--------------+-----+--------------------------+-------------+6 rows in set (0.00 sec)mysql&gt; select group_concat(age) as total_age,edu,group_concat(name) as total_name,count(*) as total_count  from user group by edu order by edu desc;+--------------+-----+--------------------------+-------------+| total_age    | edu | total_name               | total_count |+--------------+-----+--------------------------+-------------+| 32,19        |   6 | qian,yang                |           2 || 53,81        |   5 | wu,wei                   |           2 || 64,72        |   4 | zheng,chu                |           2 || 26,34,25     |   3 | wang,zhou,chen           |           3 || 22,25        |   2 | li,zhao                  |           2 || 123,42,67,55 |   1 | 刘二拐,sun,feng,zhang    |           4 |+--------------+-----+--------------------------+-------------+6 rows in set (0.00 sec)</code></pre><h3 id="limit-分页查询"><a href="#limit-分页查询" class="headerlink" title="limit 分页查询"></a>limit 分页查询</h3><pre><code>limit[位置偏移量]，行数</code></pre><h4 id="前3个"><a href="#前3个" class="headerlink" title="前3个"></a>前3个</h4><pre><code>select *from student order by age desc limit 0,3;select *from student order by age desc limit 3;</code></pre><h3 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><pre><code>avgsum countmaxmin</code></pre><h5 id="min"><a href="#min" class="headerlink" title="min"></a>min</h5><pre><code>+-------------------+-----+--------------------------+----------+| group_concat(age) | edu | group_concat(name)       | min(age) |+-------------------+-----+--------------------------+----------+| 123,42,67,55      |   1 | 刘二拐,sun,feng,zhang    |       42 || 22,25             |   2 | li,zhao                  |       22 || 26,34,25          |   3 | wang,zhou,chen           |       25 || 64,72             |   4 | zheng,chu                |       64 || 53,81             |   5 | wu,wei                   |       53 || 32,19             |   6 | qian,yang                |       19 |+-------------------+-----+--------------------------+----------+6 rows in set (0.00 sec)mysql&gt; select edu,group_concat(name),min(age)  from user group by edu;+-----+--------------------------+----------+| edu | group_concat(name)       | min(age) |+-----+--------------------------+----------+|   1 | 刘二拐,sun,feng,zhang    |       42 ||   2 | li,zhao                  |       22 ||   3 | wang,zhou,chen           |       25 ||   4 | zheng,chu                |       64 ||   5 | wu,wei                   |       53 ||   6 | qian,yang                |       19 |+-----+--------------------------+----------+6 rows in set (0.00 sec)</code></pre><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>统计下该表有多少数据</p><pre><code>select count(*) from stu;select count(id) from stu;</code></pre><h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><pre><code>select sum(age) from stu;</code></pre><h5 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h5><pre><code>select avg(age) from stu;</code></pre><h4 id="concat连接操作"><a href="#concat连接操作" class="headerlink" title="concat连接操作"></a>concat连接操作</h4><pre><code>mysql&gt; select * from user;+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | 李大狗    |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.00 sec)mysql&gt; select concat(&#39;ID:&#39;, id) as ID,concat(&#39;name:&#39;,name) as &#39;姓名&#39; from user;+-------+----------------+| ID    | 姓名           |+-------+----------------+| ID:1  | name:刘二拐    || ID:2  | name:李大狗    || ID:3  | name:wang      || ID:4  | name:zhao      || ID:5  | name:qian      || ID:6  | name:sun       || ID:7  | name:zhou      || ID:8  | name:wu        || ID:9  | name:zheng     || ID:10 | name:feng      || ID:11 | name:chen      || ID:12 | name:chu       || ID:13 | name:wei       || ID:14 | name:yang      || ID:15 | name:zhang     |+-------+----------------+15 rows in set (0.00 sec)</code></pre><pre><code>mysql&gt; select id, name, age, concat(id,&#39;_&#39;,name,&#39;_&#39;,age) as info from user;+----+-----------+-----+-----------------+| id | name      | age | info            |+----+-----------+-----+-----------------+|  1 | 刘二拐    | 123 | 1_刘二拐_123    ||  2 | 李大狗    |  22 | 2_李大狗_22     ||  3 | wang      |  26 | 3_wang_26       ||  4 | zhao      |  25 | 4_zhao_25       ||  5 | qian      |  32 | 5_qian_32       ||  6 | sun       |  42 | 6_sun_42        ||  7 | zhou      |  34 | 7_zhou_34       ||  8 | wu        |  53 | 8_wu_53         ||  9 | zheng     |  64 | 9_zheng_64      || 10 | feng      |  67 | 10_feng_67      || 11 | chen      |  25 | 11_chen_25      || 12 | chu       |  72 | 12_chu_72       || 13 | wei       |  81 | 13_wei_81       || 14 | yang      |  19 | 14_yang_19      || 15 | zhang     |  55 | 15_zhang_55     |+----+-----------+-----+-----------------+15 rows in set (0.00 sec)</code></pre><h4 id="随机数排序"><a href="#随机数排序" class="headerlink" title="随机数排序"></a>随机数排序</h4><pre><code>mysql&gt; select * from user order by rand();+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+| 11 | chen      |  25 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  7 | zhou      |  34 |   3 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        || 13 | wei       |  81 |   5 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  2 | 李大狗    |  22 |   2 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   |+----+-----------+-----+-----+-------------+15 rows in set (0.01 sec)</code></pre><h4 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h4><pre><code>select unix_timestamp();select from_unixtime(1521892355);</code></pre><h4 id="with-rollup与coalesce的使用"><a href="#with-rollup与coalesce的使用" class="headerlink" title="with rollup与coalesce的使用"></a>with rollup与coalesce的使用</h4><p>原数据如下：</p><pre><code>mysql&gt; select * from user;+----+-------------+------+---------------------+------+------+| id | name        | age  | email               | sign | grad |+----+-------------+------+---------------------+------+------+|  1 | liuxingxing |   23 | lxxwork0827@163.com |   10 | A    ||  2 | qian        |   23 | lxxwork0827@163.com |   30 | B    ||  3 | zhao        |   21 | zhaoemail           |    3 | A    ||  4 | qian        |   23 | lxxwork0827@163.com |    2 | B    ||  5 | zhao        |   23 | lxxwork0827@163.com |    2 | A    ||  6 | qian        |   23 | lxxwork0827@163.com |    7 | B    ||  7 | liudehua    |   23 | lxxwork0827@163.com |   77 | A    |+----+-------------+------+---------------------+------+------+7 rows in set (0.00 sec)</code></pre><p>现在，需要统计出每个用户sign（登录）的总次数，这里便用到了WITH ROLLUP：</p><pre><code>mysql&gt; select name, sum(sign), count(name) from user group by name;+-------------+-----------+-------------+| name        | sum(sign) | count(name) |+-------------+-----------+-------------+| liuxingxing |        10 |           1 || qian        |        39 |           3 || zhao        |         5 |           2 || liudehua    |        77 |           1 |+-------------+-----------+-------------+4 rows in set (0.00 sec)mysql&gt; select name, sum(sign), count(name) from user group by name with rollup;+-------------+-----------+-------------+| name        | sum(sign) | count(name) |+-------------+-----------+-------------+| liudehua    |        77 |           1 || liuxingxing |        10 |           1 || qian        |        39 |           3 || zhao        |         5 |           2 || NULL        |       131 |           7 |+-------------+-----------+-------------+5 rows in set (0.00 sec)</code></pre><p>我们注意到，最后一行的name字段为null。NULL表示所有人的登录次数。我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：</p><pre><code>select coalesce(a,b,c);</code></pre><blockquote><p>参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p></blockquote><pre><code>mysql&gt; select coalesce(name,&#39;总计&#39;), sum(sign), count(name) from user group by name with rollup;+-------------------------+-----------+-------------+| coalesce(name,&#39;总计&#39;)   | sum(sign) | count(name) |+-------------------------+-----------+-------------+| liudehua                |        77 |           1 || liuxingxing             |        10 |           1 || qian                    |        39 |           3 || zhao                    |         5 |           2 || 总计                    |       131 |           7 |+-------------------------+-----------+-------------+5 rows in set (0.00 sec)</code></pre><h3 id="exists查询"><a href="#exists查询" class="headerlink" title="exists查询"></a>exists查询</h3><blockquote><p> exists关键字后是任意一个子查询，如果子查询返回至少1行，则为真，外层查询语句将进行查询，否则不进行查询。</p></blockquote><p>例如这2个表的数据：</p><pre><code>mysql&gt; select * from tb_edu;+----+--------+| id | edu    |+----+--------+|  1 | 小学   ||  2 | 初中   ||  3 | 高中   ||  4 | 本科   ||  5 | 硕士   ||  6 | 博士   |+----+--------+6 rows in set (0.01 sec)mysql&gt; select * from user;+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | 李大狗    |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.00 sec)</code></pre><p>如果我将子查询语句中tb_edu.id 大于6，那么子查询返回的是空值，那么前面的查询语句就不会执行，返回空。</p><pre><code>mysql&gt; select * from user where exists (select id from tb_edu where tb_edu.id &gt; 6);Empty set (0.00 sec)</code></pre><pre><code>mysql&gt; select * from user where exists (select id from tb_edu where tb_edu.id &gt; 5);+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | 李大狗    |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.01 sec)</code></pre><h3 id="嵌套查询-where-in"><a href="#嵌套查询-where-in" class="headerlink" title="嵌套查询(where in)"></a>嵌套查询(where in)</h3><p>表数据如下：</p><pre><code>mysql&gt; select * from user;+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | 李大狗    |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.00 sec)mysql&gt; select * from tb_edu;+----+--------+| id | edu    |+----+--------+|  1 | 小学   ||  2 | 初中   ||  3 | 高中   ||  4 | 本科   ||  5 | 硕士   ||  6 | 博士   |+----+--------+6 rows in set (0.00 sec)</code></pre><p>查询：</p><pre><code>mysql&gt; select * from user where edu in (select id from tb_edu where id &gt; 5);+----+------+-----+-----+-----------+| id | name | age | edu | email     |+----+------+-----+-----+-----------+|  5 | qian |  32 |   6 | li@qq.com || 14 | yang |  19 |   6 | li@qq.com |+----+------+-----+-----+-----------+2 rows in set (0.00 sec)</code></pre><h3 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h3><h5 id="两表无条件查询"><a href="#两表无条件查询" class="headerlink" title="两表无条件查询"></a>两表无条件查询</h5><p>查询结果是乘积关系（tb_edu共有6条数据，user有15条数据）。</p><pre><code>mysql&gt; select * from user, tb_edu;+----+-----------+-----+-----+-------------+----+--------+| id | name      | age | edu | email       | id | edu    |+----+-----------+-----+-----+-------------+----+--------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com |  1 | 小学   ||  1 | 刘二拐    | 123 |   1 | lxx@agc.com |  2 | 初中   ||  1 | 刘二拐    | 123 |   1 | lxx@agc.com |  3 | 高中   ||  1 | 刘二拐    | 123 |   1 | lxx@agc.com |  4 | 本科   ||  1 | 刘二拐    | 123 |   1 | lxx@agc.com |  5 | 硕士   ||  1 | 刘二拐    | 123 |   1 | lxx@agc.com |  6 | 博士   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |  1 | 小学   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |  2 | 初中   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |  3 | 高中   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |  4 | 本科   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |  5 | 硕士   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |  6 | 博士   ||  3 | wang      |  26 |   3 | li@qq.com   |  1 | 小学   ||  3 | wang      |  26 |   3 | li@qq.com   |  2 | 初中   ||  3 | wang      |  26 |   3 | li@qq.com   |  3 | 高中   ||  3 | wang      |  26 |   3 | li@qq.com   |  4 | 本科   ||  3 | wang      |  26 |   3 | li@qq.com   |  5 | 硕士   ||  3 | wang      |  26 |   3 | li@qq.com   |  6 | 博士   ||  4 | zhao      |  25 |   2 | li@qq.com   |  1 | 小学   ||  4 | zhao      |  25 |   2 | li@qq.com   |  2 | 初中   ||  4 | zhao      |  25 |   2 | li@qq.com   |  3 | 高中   ||  4 | zhao      |  25 |   2 | li@qq.com   |  4 | 本科   ||  4 | zhao      |  25 |   2 | li@qq.com   |  5 | 硕士   ||  4 | zhao      |  25 |   2 | li@qq.com   |  6 | 博士   ||  5 | qian      |  32 |   6 | li@qq.com   |  1 | 小学   ||  5 | qian      |  32 |   6 | li@qq.com   |  2 | 初中   ||  5 | qian      |  32 |   6 | li@qq.com   |  3 | 高中   ||  5 | qian      |  32 |   6 | li@qq.com   |  4 | 本科   ||  5 | qian      |  32 |   6 | li@qq.com   |  5 | 硕士   ||  5 | qian      |  32 |   6 | li@qq.com   |  6 | 博士   ||  6 | sun       |  42 |   1 | li@qq.com   |  1 | 小学   ||  6 | sun       |  42 |   1 | li@qq.com   |  2 | 初中   ||  6 | sun       |  42 |   1 | li@qq.com   |  3 | 高中   ||  6 | sun       |  42 |   1 | li@qq.com   |  4 | 本科   ||  6 | sun       |  42 |   1 | li@qq.com   |  5 | 硕士   ||  6 | sun       |  42 |   1 | li@qq.com   |  6 | 博士   ||  7 | zhou      |  34 |   3 | li@qq.com   |  1 | 小学   ||  7 | zhou      |  34 |   3 | li@qq.com   |  2 | 初中   ||  7 | zhou      |  34 |   3 | li@qq.com   |  3 | 高中   ||  7 | zhou      |  34 |   3 | li@qq.com   |  4 | 本科   ||  7 | zhou      |  34 |   3 | li@qq.com   |  5 | 硕士   ||  7 | zhou      |  34 |   3 | li@qq.com   |  6 | 博士   ||  8 | wu        |  53 |   5 | li@qq.com   |  1 | 小学   ||  8 | wu        |  53 |   5 | li@qq.com   |  2 | 初中   ||  8 | wu        |  53 |   5 | li@qq.com   |  3 | 高中   ||  8 | wu        |  53 |   5 | li@qq.com   |  4 | 本科   ||  8 | wu        |  53 |   5 | li@qq.com   |  5 | 硕士   ||  8 | wu        |  53 |   5 | li@qq.com   |  6 | 博士   ||  9 | zheng     |  64 |   4 | li@qq.com   |  1 | 小学   ||  9 | zheng     |  64 |   4 | li@qq.com   |  2 | 初中   ||  9 | zheng     |  64 |   4 | li@qq.com   |  3 | 高中   ||  9 | zheng     |  64 |   4 | li@qq.com   |  4 | 本科   ||  9 | zheng     |  64 |   4 | li@qq.com   |  5 | 硕士   ||  9 | zheng     |  64 |   4 | li@qq.com   |  6 | 博士   || 10 | feng      |  67 |   1 | li@qq.com   |  1 | 小学   || 10 | feng      |  67 |   1 | li@qq.com   |  2 | 初中   || 10 | feng      |  67 |   1 | li@qq.com   |  3 | 高中   || 10 | feng      |  67 |   1 | li@qq.com   |  4 | 本科   || 10 | feng      |  67 |   1 | li@qq.com   |  5 | 硕士   || 10 | feng      |  67 |   1 | li@qq.com   |  6 | 博士   || 11 | chen      |  25 |   3 | li@qq.com   |  1 | 小学   || 11 | chen      |  25 |   3 | li@qq.com   |  2 | 初中   || 11 | chen      |  25 |   3 | li@qq.com   |  3 | 高中   || 11 | chen      |  25 |   3 | li@qq.com   |  4 | 本科   || 11 | chen      |  25 |   3 | li@qq.com   |  5 | 硕士   || 11 | chen      |  25 |   3 | li@qq.com   |  6 | 博士   || 12 | chu       |  72 |   4 | li@qq.com   |  1 | 小学   || 12 | chu       |  72 |   4 | li@qq.com   |  2 | 初中   || 12 | chu       |  72 |   4 | li@qq.com   |  3 | 高中   || 12 | chu       |  72 |   4 | li@qq.com   |  4 | 本科   || 12 | chu       |  72 |   4 | li@qq.com   |  5 | 硕士   || 12 | chu       |  72 |   4 | li@qq.com   |  6 | 博士   || 13 | wei       |  81 |   5 | li@qq.com   |  1 | 小学   || 13 | wei       |  81 |   5 | li@qq.com   |  2 | 初中   || 13 | wei       |  81 |   5 | li@qq.com   |  3 | 高中   || 13 | wei       |  81 |   5 | li@qq.com   |  4 | 本科   || 13 | wei       |  81 |   5 | li@qq.com   |  5 | 硕士   || 13 | wei       |  81 |   5 | li@qq.com   |  6 | 博士   || 14 | yang      |  19 |   6 | li@qq.com   |  1 | 小学   || 14 | yang      |  19 |   6 | li@qq.com   |  2 | 初中   || 14 | yang      |  19 |   6 | li@qq.com   |  3 | 高中   || 14 | yang      |  19 |   6 | li@qq.com   |  4 | 本科   || 14 | yang      |  19 |   6 | li@qq.com   |  5 | 硕士   || 14 | yang      |  19 |   6 | li@qq.com   |  6 | 博士   || 15 | zhang     |  55 |   1 | 4444        |  1 | 小学   || 15 | zhang     |  55 |   1 | 4444        |  2 | 初中   || 15 | zhang     |  55 |   1 | 4444        |  3 | 高中   || 15 | zhang     |  55 |   1 | 4444        |  4 | 本科   || 15 | zhang     |  55 |   1 | 4444        |  5 | 硕士   || 15 | zhang     |  55 |   1 | 4444        |  6 | 博士   |+----+-----------+-----+-----+-------------+----+--------+90 rows in set (0.00 sec)</code></pre><h5 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h5><pre><code>mysql&gt; select user.id, user.name,user.age, tb_edu.edu from user, tb_edu where user.edu=tb_edu.id;+----+-----------+-----+--------+| id | name      | age | edu    |+----+-----------+-----+--------+|  1 | 刘二拐    | 123 | 小学   ||  2 | 李大狗    |  22 | 初中   ||  3 | wang      |  26 | 高中   ||  4 | zhao      |  25 | 初中   ||  5 | qian      |  32 | 博士   ||  6 | sun       |  42 | 小学   ||  7 | zhou      |  34 | 高中   ||  8 | wu        |  53 | 硕士   ||  9 | zheng     |  64 | 本科   || 10 | feng      |  67 | 小学   || 11 | chen      |  25 | 高中   || 12 | chu       |  72 | 本科   || 13 | wei       |  81 | 硕士   || 14 | yang      |  19 | 博士   || 15 | zhang     |  55 | 小学   |+----+-----------+-----+--------+15 rows in set (0.00 sec)</code></pre><h4 id="内连接查询-inner-join"><a href="#内连接查询-inner-join" class="headerlink" title="内连接查询 inner join"></a>内连接查询 inner join</h4><pre><code>mysql&gt; select user.id, user.name,user.age, tb_edu.edu from user inner join tb_edu on  user.edu=tb_edu.id;+----+-----------+-----+--------+| id | name      | age | edu    |+----+-----------+-----+--------+|  1 | 刘二拐    | 123 | 小学   ||  2 | 李大狗    |  22 | 初中   ||  3 | wang      |  26 | 高中   ||  4 | zhao      |  25 | 初中   ||  5 | qian      |  32 | 博士   ||  6 | sun       |  42 | 小学   ||  7 | zhou      |  34 | 高中   ||  8 | wu        |  53 | 硕士   ||  9 | zheng     |  64 | 本科   || 10 | feng      |  67 | 小学   || 11 | chen      |  25 | 高中   || 12 | chu       |  72 | 本科   || 13 | wei       |  81 | 硕士   || 14 | yang      |  19 | 博士   || 15 | zhang     |  55 | 小学   |+----+-----------+-----+--------+15 rows in set (0.00 sec)</code></pre><blockquote><p>试了下，在内连接查询中，将on 换成where也可以查出来。</p></blockquote><h4 id="左连接查询-left-join"><a href="#左连接查询-left-join" class="headerlink" title="左连接查询 left join"></a>左连接查询 left join</h4><p>2个表数据如下：</p><pre><code>mysql&gt; select * from user;+----+-----------+-----+-----+----------------------+| id | name      | age | edu | email                |+----+-----------+-----+-----+----------------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com          ||  2 | 李大狗    |  22 |   2 | li@qq.com            ||  3 | wang      |  26 |   3 | li@qq.com            ||  4 | zhao      |  25 |   2 | li@qq.com            ||  5 | qian      |  32 |   6 | li@qq.com            ||  6 | sun       |  42 |   1 | li@qq.com            ||  7 | zhou      |  34 |   3 | li@qq.com            ||  8 | wu        |  53 |   5 | li@qq.com            ||  9 | zheng     |  64 |   4 | li@qq.com            || 10 | feng      |  67 |   1 | li@qq.com            || 11 | chen      |  25 |   3 | li@qq.com            || 12 | chu       |  72 |   4 | li@qq.com            || 13 | wei       |  81 |   5 | li@qq.com            || 14 | yang      |  19 |   6 | li@qq.com            || 15 | zhang     |  55 |   1 | 4444                 || 16 | 张大壮    |  43 |   0 | zhangdazhuang@qq.com || 17 | 郭麒麟    |  33 |   0 | zguo@qq.com          |+----+-----------+-----+-----+----------------------+17 rows in set (0.00 sec)mysql&gt; select * from tb_edu;+----+--------+| id | edu    |+----+--------+|  1 | 小学   ||  2 | 初中   ||  3 | 高中   ||  4 | 本科   ||  5 | 硕士   ||  6 | 博士   ||  7 | 大专   ||  8 | 中专   |+----+--------+8 rows in set (0.00 sec)</code></pre><p>左连接语句如下：</p><pre><code>mysql&gt; select * from user left join tb_edu on user.edu=tb_edu.id;+----+-----------+-----+-----+----------------------+------+--------+| id | name      | age | edu | email                | id   | edu    |+----+-----------+-----+-----+----------------------+------+--------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com          |    1 | 小学   ||  2 | 李大狗    |  22 |   2 | li@qq.com            |    2 | 初中   ||  3 | wang      |  26 |   3 | li@qq.com            |    3 | 高中   ||  4 | zhao      |  25 |   2 | li@qq.com            |    2 | 初中   ||  5 | qian      |  32 |   6 | li@qq.com            |    6 | 博士   ||  6 | sun       |  42 |   1 | li@qq.com            |    1 | 小学   ||  7 | zhou      |  34 |   3 | li@qq.com            |    3 | 高中   ||  8 | wu        |  53 |   5 | li@qq.com            |    5 | 硕士   ||  9 | zheng     |  64 |   4 | li@qq.com            |    4 | 本科   || 10 | feng      |  67 |   1 | li@qq.com            |    1 | 小学   || 11 | chen      |  25 |   3 | li@qq.com            |    3 | 高中   || 12 | chu       |  72 |   4 | li@qq.com            |    4 | 本科   || 13 | wei       |  81 |   5 | li@qq.com            |    5 | 硕士   || 14 | yang      |  19 |   6 | li@qq.com            |    6 | 博士   || 15 | zhang     |  55 |   1 | 4444                 |    1 | 小学   || 16 | 张大壮    |  43 |   0 | zhangdazhuang@qq.com | NULL | NULL   || 17 | 郭麒麟    |  33 |   0 | zguo@qq.com          | NULL | NULL   |+----+-----------+-----+-----+----------------------+------+--------+17 rows in set (0.00 sec)</code></pre><blockquote><p>因为 user表中的16、17两行记录的edu为0。但是对应的tb_edu中并没有关于id为0的数据，所以为null。</p></blockquote><h4 id="右连接查询-right-join"><a href="#右连接查询-right-join" class="headerlink" title="右连接查询 right join"></a>右连接查询 right join</h4><pre><code>mysql&gt; select * from user right join tb_edu on user.edu=tb_edu.id;+------+-----------+------+------+-------------+----+--------+| id   | name      | age  | edu  | email       | id | edu    |+------+-----------+------+------+-------------+----+--------+|    1 | 刘二拐    |  123 |    1 | lxx@agc.com |  1 | 小学   ||    2 | 李大狗    |   22 |    2 | li@qq.com   |  2 | 初中   ||    3 | wang      |   26 |    3 | li@qq.com   |  3 | 高中   ||    4 | zhao      |   25 |    2 | li@qq.com   |  2 | 初中   ||    5 | qian      |   32 |    6 | li@qq.com   |  6 | 博士   ||    6 | sun       |   42 |    1 | li@qq.com   |  1 | 小学   ||    7 | zhou      |   34 |    3 | li@qq.com   |  3 | 高中   ||    8 | wu        |   53 |    5 | li@qq.com   |  5 | 硕士   ||    9 | zheng     |   64 |    4 | li@qq.com   |  4 | 本科   ||   10 | feng      |   67 |    1 | li@qq.com   |  1 | 小学   ||   11 | chen      |   25 |    3 | li@qq.com   |  3 | 高中   ||   12 | chu       |   72 |    4 | li@qq.com   |  4 | 本科   ||   13 | wei       |   81 |    5 | li@qq.com   |  5 | 硕士   ||   14 | yang      |   19 |    6 | li@qq.com   |  6 | 博士   ||   15 | zhang     |   55 |    1 | 4444        |  1 | 小学   || NULL | NULL      | NULL | NULL | NULL        |  7 | 大专   || NULL | NULL      | NULL | NULL | NULL        |  8 | 中专   |+------+-----------+------+------+-------------+----+--------+17 rows in set (0.00 sec)</code></pre><h4 id="左右连接规则总结："><a href="#左右连接规则总结：" class="headerlink" title="左右连接规则总结："></a>左右连接规则总结：</h4><blockquote><p>from 谁谁在前面显示，left-right 表示以左边的关键词为主导还是以右边的关键词为主导。以谁为主导，那么谁的数据就会全部展示，另外一个表只能配合显示：另一张表有多个符合的，主导表大不了会重复显示符合的，另一个表没有符合的数据，就会乖乖的显示为空，主导表仍会把自己的数据展示出来。所以展示的现象是：主导表中的数据有没有符合的都会至少展示一次，有多个符合则展示多次。</p></blockquote><pre><code>mysql&gt; select user.*, tb_edu.*   from user left join tb_edu on user.edu=tb_edu.id;+----+-----------+-----+-----+----------------------+------+--------+| id | name      | age | edu | email                | id   | edu    |+----+-----------+-----+-----+----------------------+------+--------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com          |    1 | 小学   ||  2 | 李大狗    |  22 |   2 | li@qq.com            |    2 | 初中   ||  3 | wang      |  26 |   3 | li@qq.com            |    3 | 高中   ||  4 | zhao      |  25 |   2 | li@qq.com            |    2 | 初中   ||  5 | qian      |  32 |   6 | li@qq.com            |    6 | 博士   ||  6 | sun       |  42 |   1 | li@qq.com            |    1 | 小学   ||  7 | zhou      |  34 |   3 | li@qq.com            |    3 | 高中   ||  8 | wu        |  53 |   5 | li@qq.com            |    5 | 硕士   ||  9 | zheng     |  64 |   4 | li@qq.com            |    4 | 本科   || 10 | feng      |  67 |   1 | li@qq.com            |    1 | 小学   || 11 | chen      |  25 |   3 | li@qq.com            |    3 | 高中   || 12 | chu       |  72 |   4 | li@qq.com            |    4 | 本科   || 13 | wei       |  81 |   5 | li@qq.com            |    5 | 硕士   || 14 | yang      |  19 |   6 | li@qq.com            |    6 | 博士   || 15 | zhang     |  55 |   1 | 4444                 |    1 | 小学   || 16 | 张大壮    |  43 |   0 | zhangdazhuang@qq.com | NULL | NULL   || 17 | 郭麒麟    |  33 |   0 | zguo@qq.com          | NULL | NULL   |+----+-----------+-----+-----+----------------------+------+--------+17 rows in set (0.01 sec)</code></pre><p>现在筛选出不为null的值。</p><pre><code>mysql&gt; select user.*, tb_edu.*   from user left join tb_edu on user.edu=tb_edu.id where tb_edu.id is not null;+----+-----------+-----+-----+-------------+------+--------+| id | name      | age | edu | email       | id   | edu    |+----+-----------+-----+-----+-------------+------+--------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com |    1 | 小学   ||  2 | 李大狗    |  22 |   2 | li@qq.com   |    2 | 初中   ||  3 | wang      |  26 |   3 | li@qq.com   |    3 | 高中   ||  4 | zhao      |  25 |   2 | li@qq.com   |    2 | 初中   ||  5 | qian      |  32 |   6 | li@qq.com   |    6 | 博士   ||  6 | sun       |  42 |   1 | li@qq.com   |    1 | 小学   ||  7 | zhou      |  34 |   3 | li@qq.com   |    3 | 高中   ||  8 | wu        |  53 |   5 | li@qq.com   |    5 | 硕士   ||  9 | zheng     |  64 |   4 | li@qq.com   |    4 | 本科   || 10 | feng      |  67 |   1 | li@qq.com   |    1 | 小学   || 11 | chen      |  25 |   3 | li@qq.com   |    3 | 高中   || 12 | chu       |  72 |   4 | li@qq.com   |    4 | 本科   || 13 | wei       |  81 |   5 | li@qq.com   |    5 | 硕士   || 14 | yang      |  19 |   6 | li@qq.com   |    6 | 博士   || 15 | zhang     |  55 |   1 | 4444        |    1 | 小学   |+----+-----------+-----+-----+-------------+------+--------+15 rows in set (0.00 sec)mysql&gt; select user.*, tb_edu.*   from user left join tb_edu on user.edu=tb_edu.id where tb_edu.id is  null;+----+-----------+-----+-----+----------------------+------+------+| id | name      | age | edu | email                | id   | edu  |+----+-----------+-----+-----+----------------------+------+------+| 16 | 张大壮    |  43 |   0 | zhangdazhuang@qq.com | NULL | NULL || 17 | 郭麒麟    |  33 |   0 | zguo@qq.com          | NULL | NULL |+----+-----------+-----+-----+----------------------+------+------+2 rows in set (0.00 sec)</code></pre><p><img src="https://note.youdao.com/yws/public/resource/ba14969cb0c918adbb769c3272d95816/xmlnote/B6F02A34945C470AB5405BAE599DC7EE/26865" alt="image"></p><h4 id="较为复杂的左连接查询"><a href="#较为复杂的左连接查询" class="headerlink" title="较为复杂的左连接查询"></a>较为复杂的左连接查询</h4><pre><code>select gid, t1.name, t2.name from m left join t as t1 on m.tid = t1.tid left join t2 on  m.gid = t2.gid;</code></pre><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>使用union时，两个对应的列数和数据类型必须相同。各个select语句之间使用 union 或者union all连接。不使用all时，执行时会删除重复的数据，所有的返回的行都是唯一的。使用all时，不删除重复行也不对结果进行自动排序。</p><pre><code>select temp.id, temp.name, temp.age, temp.edu from (select *from user union select * from tb_edu) as temp;</code></pre><h2 id="在数据库中使用enum类型"><a href="#在数据库中使用enum类型" class="headerlink" title="在数据库中使用enum类型"></a>在数据库中使用enum类型</h2><p>enum是一个字符串对象，其值为表创建时在列规定中枚举中的一列值。</p><pre><code>create table temp1(soc int,level enum(&#39;excellent&#39;,&#39;good&#39;,&#39;bad&#39;));</code></pre><pre><code>mysql&gt; desc temp1\G;*************************** 1. row ***************************  Field: soc   Type: int(11)   Null: YES    Key:Default: NULL  Extra:*************************** 2. row ***************************  Field: level   Type: enum(&#39;excellent&#39;,&#39;good&#39;,&#39;bad&#39;)   Null: YES    Key:Default: NULL  Extra:2 rows in set (0.00 sec)ERROR:No query specified</code></pre><p>如果插入的枚举值不在enum列表中，则会报错</p><pre><code>mysql&gt; insert into temp1 values(100,&#39;best&#39;);ERROR 1265 (01000): Data truncated for column &#39;level&#39; at row 1</code></pre><p>enum(‘excellent’,’good’,’bad’)分别代表1，2，3</p><pre><code>insert into temp1 values(70,&#39;good&#39;),(90,1),(70,2),(50,3);</code></pre><pre><code>mysql&gt; insert into temp1 values(70,&#39;good&#39;),(90,1),(70,2),(50,3);Query OK, 4 rows affected (0.02 sec)Records: 4  Duplicates: 0  Warnings: 0mysql&gt; select * from temp1;+------+-----------+| soc  | level     |+------+-----------+|   70 | good      ||   90 | excellent ||   70 | good      ||   50 | bad       |+------+-----------+4 rows in set (0.00 sec)</code></pre><h3 id="在MySQL中使用set数据类型"><a href="#在MySQL中使用set数据类型" class="headerlink" title="在MySQL中使用set数据类型"></a>在MySQL中使用set数据类型</h3><p>set是一个字符串对象，可以有零个或多个值。set最多可以有64个成员，其值为表创建时在列规定中枚举中的一列值。与enum不同的是，enum只能从定义的列表中选择一个值插入，而set可以从定义的列值中选择多个字符的结合。</p><pre><code>create table temp2(s set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;));</code></pre><pre><code>mysql&gt; desc temp2\G;*************************** 1. row ***************************  Field: s   Type: set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)   Null: YES    Key:Default: NULL  Extra:1 row in set (0.00 sec)ERROR:No query specified</code></pre><pre><code>insert into temp2 values(&#39;a&#39;),(&#39;a,b,a&#39;),(&#39;c,a,d&#39;);</code></pre><pre><code>mysql&gt; insert into temp2 values(&#39;a&#39;),(&#39;a,b,a&#39;),(&#39;c,a,d&#39;);Query OK, 3 rows affected (0.00 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from temp2;+-------+| s     |+-------+| a     || a,b   || a,c,d |+-------+3 rows in set (0.00 sec)</code></pre><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><pre><code>^ 匹配以^后面的字符开头的字符串 ^test$ 匹配以$前面的字符结尾的字符串 test$. 匹配任何一个单字符 &#39;b.t&#39;   bat bct but bite[...] 匹配方括号内的任何字符* 匹配零个或多个在它前面的字符。+ 1次或多次[^] 不包含括号内的任何字符 [^abc] 不包含a b 或c 的字符串 字符串{n,}  前面的字符串至少匹配n次   b{2} 匹配2个或者更多的b字符串{n,m}  前面的字符串至少匹配n次，至多m次   </code></pre><pre><code>mysql&gt; select * from user;+----+-----------+-----+-----+-------------+| id | name      | age | edu | email       |+----+-----------+-----+-----+-------------+|  1 | 刘二拐    | 123 |   1 | lxx@agc.com ||  2 | li        |  22 |   2 | li@qq.com   ||  3 | wang      |  26 |   3 | li@qq.com   ||  4 | zhao      |  25 |   2 | li@qq.com   ||  5 | qian      |  32 |   6 | li@qq.com   ||  6 | sun       |  42 |   1 | li@qq.com   ||  7 | zhou      |  34 |   3 | li@qq.com   ||  8 | wu        |  53 |   5 | li@qq.com   ||  9 | zheng     |  64 |   4 | li@qq.com   || 10 | feng      |  67 |   1 | li@qq.com   || 11 | chen      |  25 |   3 | li@qq.com   || 12 | chu       |  72 |   4 | li@qq.com   || 13 | wei       |  81 |   5 | li@qq.com   || 14 | yang      |  19 |   6 | li@qq.com   || 15 | zhang     |  55 |   1 | 4444        |+----+-----------+-----+-----+-------------+15 rows in set (0.00 sec)mysql&gt; select * from user where name regexp &#39;^c&#39;;+----+------+-----+-----+-----------+| id | name | age | edu | email     |+----+------+-----+-----+-----------+| 11 | chen |  25 |   3 | li@qq.com || 12 | chu  |  72 |   4 | li@qq.com |+----+------+-----+-----+-----------+2 rows in set (0.02 sec)mysql&gt; select * from user where name regexp &#39;ng$&#39;;+----+-------+-----+-----+-----------+| id | name  | age | edu | email     |+----+-------+-----+-----+-----------+|  3 | wang  |  26 |   3 | li@qq.com ||  9 | zheng |  64 |   4 | li@qq.com || 10 | feng  |  67 |   1 | li@qq.com || 14 | yang  |  19 |   6 | li@qq.com || 15 | zhang |  55 |   1 | 4444      |+----+-------+-----+-----+-----------+5 rows in set (0.00 sec)mysql&gt; select * from user where name regexp &#39;h..g&#39;;+----+-------+-----+-----+-----------+| id | name  | age | edu | email     |+----+-------+-----+-----+-----------+|  9 | zheng |  64 |   4 | li@qq.com || 15 | zhang |  55 |   1 | 4444      |+----+-------+-----+-----+-----------+2 rows in set (0.00 sec)mysql&gt; select * from user where name regexp &#39;ng&#39;;+----+-------+-----+-----+-----------+| id | name  | age | edu | email     |+----+-------+-----+-----+-----------+|  3 | wang  |  26 |   3 | li@qq.com ||  9 | zheng |  64 |   4 | li@qq.com || 10 | feng  |  67 |   1 | li@qq.com || 14 | yang  |  19 |   6 | li@qq.com || 15 | zhang |  55 |   1 | 4444      |+----+-------+-----+-----+-----------+5 rows in set (0.00 sec)mysql&gt; select * from user where name regexp &#39;[wz]&#39;;+----+-------+-----+-----+-----------+| id | name  | age | edu | email     |+----+-------+-----+-----+-----------+|  3 | wang  |  26 |   3 | li@qq.com ||  4 | zhao  |  25 |   2 | li@qq.com ||  7 | zhou  |  34 |   3 | li@qq.com ||  8 | wu    |  53 |   5 | li@qq.com ||  9 | zheng |  64 |   4 | li@qq.com || 13 | wei   |  81 |   5 | li@qq.com || 15 | zhang |  55 |   1 | 4444      |+----+-------+-----+-----+-----------+7 rows in set (0.00 sec)mysql&gt; select * from user where name regexp &#39;[w-z]&#39;;+----+-------+-----+-----+-----------+| id | name  | age | edu | email     |+----+-------+-----+-----+-----------+|  3 | wang  |  26 |   3 | li@qq.com ||  4 | zhao  |  25 |   2 | li@qq.com ||  7 | zhou  |  34 |   3 | li@qq.com ||  8 | wu    |  53 |   5 | li@qq.com ||  9 | zheng |  64 |   4 | li@qq.com || 13 | wei   |  81 |   5 | li@qq.com || 14 | yang  |  19 |   6 | li@qq.com || 15 | zhang |  55 |   1 | 4444      |+----+-------+-----+-----+-----------+8 rows in set (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 检索数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库入门1</title>
      <link href="/2018/10/01/2018-10-01-shu-ju-ku-ru-men/"/>
      <url>/2018/10/01/2018-10-01-shu-ju-ku-ru-men/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>什么是数据库？</p><blockquote><p>数据库(database) 保存有组织的数据的容器(通常是一个文 件或一组文件)。数据库软件称为DBMS(数据库管理系统)。数据库 是通过DBMS创建和操纵的容器。</p></blockquote><p>什么是SQL?</p><blockquote><p>SQL(发音为字母S-Q-L或sequel)是结构化查询语言(Structured Query Language)的缩写。SQL是一种专门用来与数据库通信的语言。</p></blockquote><p>什么是非关系型数据库NoSQL？</p><blockquote><p>非关系型数据库NoSQL是通过键值对存储的，每个键值对可以有不同的结构和字段，相对灵活。无需经过SQL层的解析，性能非常高。由于是基于键值对，数据没有耦合性，非常容易水平拓展。</p></blockquote><p>什么是关系型数据库？</p><blockquote><p> 关系型数据库可以简单理解为二维表格及其之间的联系所组成的数据组织。关系型数据库可以在一个或多个表之间做复杂的查询。同时也支持事务，对于安全性能要求较高的应用，可以保证安全。</p></blockquote><h3 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h3><h5 id="登录："><a href="#登录：" class="headerlink" title="登录："></a>登录：</h5><pre><code>mysql -u root -p mysql -uroot -proot//直接使用某个数据库mysql -uroot -proot lx</code></pre><h5 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h5><pre><code>show databases;</code></pre><h5 id="查看数据库的引擎"><a href="#查看数据库的引擎" class="headerlink" title="查看数据库的引擎"></a>查看数据库的引擎</h5><pre class=" language-mysql"><code class="language-mysql">mysql> show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         || BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         || MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         || FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       || MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         || PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         || InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        || MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         || CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)</code></pre><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><pre><code>create database lx_databse charset utf8;</code></pre><h5 id="查看创建的数据库"><a href="#查看创建的数据库" class="headerlink" title="查看创建的数据库"></a>查看创建的数据库</h5><pre><code>show create database lx_database;</code></pre><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><pre><code>drop database lxx_database;</code></pre><h5 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h5><pre><code>use  lxx_database;</code></pre><blockquote><p>注意：如果要修改数据库，不能修改数据库名称，只能修改字符集和校对集。</p></blockquote><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h5 id="创建表方式1："><a href="#创建表方式1：" class="headerlink" title="创建表方式1："></a>创建表方式1：</h5><pre><code>create table stu (id int not null auto_increment primary key comment&#39;id 学号&#39;,name varchar(10) not null default&#39;&#39; comment&#39;姓名&#39;,age int not null default 0 comment&#39;年龄&#39; ,sex varchar(5) not null default&#39;男&#39; comment&#39;性别&#39;)charset=utf8 engine=Myisam;</code></pre><h5 id="创建表方式2："><a href="#创建表方式2：" class="headerlink" title="创建表方式2："></a>创建表方式2：</h5><pre><code>create table user(id int unsigned not null auto_increment,name varchar(8) not null,primary key(id));</code></pre><h5 id="创建表-单字段主键-并指定引擎为myisam："><a href="#创建表-单字段主键-并指定引擎为myisam：" class="headerlink" title="创建表(单字段主键)并指定引擎为myisam："></a>创建表(单字段主键)并指定引擎为myisam：</h5><pre><code>create table member(id int unsigned auto_increment primary key,username char(20) not null default &#39;&#39;,gender char(1) not null default &#39;&#39;,weight tinyint unsigned not null default 0,birth date not null default &#39;0000-01-01&#39;,salary decimal(8,2) not null default 0.00,lastlogin int unsigned not null default 0) engine myisam charset utf8;</code></pre><h5 id="创建表-多字段联合主键-并指定引擎为myisam："><a href="#创建表-多字段联合主键-并指定引擎为myisam：" class="headerlink" title="创建表(多字段联合主键)并指定引擎为myisam："></a>创建表(多字段联合主键)并指定引擎为myisam：</h5><pre><code>create table student(id int unsigned auto_increment,username char(20) not null default &#39;&#39;,gender char(1) not null default &#39;&#39;,weight tinyint unsigned not null default 0,birth date not null default &#39;0000-01-01&#39;,salary decimal(8,2) not null default 0.00,lastlogin int unsigned not null default 0,primary key(id,username));</code></pre><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><pre><code>drop table stu；</code></pre><h5 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h5><pre><code>show tables；</code></pre><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><pre><code>desc  stu；show columns from user;</code></pre><h5 id="查看创建该表时使用的语句"><a href="#查看创建该表时使用的语句" class="headerlink" title="查看创建该表时使用的语句"></a>查看创建该表时使用的语句</h5><pre><code>show create table stu;</code></pre><h5 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h5><pre><code>alter table stu rename to student;</code></pre><h5 id="修改表引擎"><a href="#修改表引擎" class="headerlink" title="修改表引擎"></a>修改表引擎</h5><pre><code>mysql&gt; show create  table  tb_edu\G;*************************** 1. row ***************************       Table: tb_eduCreate Table: CREATE TABLE `tb_edu` (  `id` int(10) unsigned NOT NULL,  `edu` char(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#39;&#39;,  PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf81 row in set (0.00 sec)ERROR:No query specifiedmysql&gt; alter table tb_edu engine=InnoDB;Query OK, 6 rows affected (0.02 sec)Records: 6  Duplicates: 0  Warnings: 0mysql&gt; show create  table  tb_edu\G;*************************** 1. row ***************************       Table: tb_eduCreate Table: CREATE TABLE `tb_edu` (  `id` int(10) unsigned NOT NULL,  `edu` char(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#39;&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)ERROR:No query specified</code></pre><h5 id="添加新的字段到该表"><a href="#添加新的字段到该表" class="headerlink" title="添加新的字段到该表"></a>添加新的字段到该表</h5><pre><code>alter table student add address varchar(200) not null default&#39;&#39; comment&#39;住址&#39; ;</code></pre><h5 id="添加新的字段到该表的指定字段后面"><a href="#添加新的字段到该表的指定字段后面" class="headerlink" title="添加新的字段到该表的指定字段后面"></a>添加新的字段到该表的指定字段后面</h5><pre><code>alter table stu add address varchar(200) not null default&#39;&#39; comment&#39;住址&#39; after age;</code></pre><h5 id="修改表中的字段名-改名-改属性"><a href="#修改表中的字段名-改名-改属性" class="headerlink" title="修改表中的字段名(改名 改属性)"></a>修改表中的字段名(改名 改属性)</h5><pre><code>alter table student change address tel char(11) default&#39;18210823650&#39; comment&#39;电话&#39;;</code></pre><h5 id="修改表中的字段-只改属性"><a href="#修改表中的字段-只改属性" class="headerlink" title="修改表中的字段(只改属性)"></a>修改表中的字段(只改属性)</h5><pre><code>alter table student modify  tel int comment&#39;电话&#39;;</code></pre><h5 id="修改表中的字段的位置"><a href="#修改表中的字段的位置" class="headerlink" title="修改表中的字段的位置"></a>修改表中的字段的位置</h5><pre><code>alter table stu modify  sex  varchar(5) after name;alter table stu modify  name varchar(10)  First;</code></pre><h5 id="删除表中的字段"><a href="#删除表中的字段" class="headerlink" title="删除表中的字段"></a>删除表中的字段</h5><pre><code>alter table student drop  tel;</code></pre><h5 id="为表中的字段添加普通索引"><a href="#为表中的字段添加普通索引" class="headerlink" title="为表中的字段添加普通索引"></a>为表中的字段添加普通索引</h5><p>原来的表结构：</p><pre><code>mysql&gt; desc user;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(255)     | YES  |     | NULL    |                || age   | int(11)          | YES  |     | NULL    |                || email | varchar(255)     | YES  |     | NULL    |                || sign  | int(11)          | YES  |     | NULL    |                || grad  | varchar(255)     | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+6 rows in set (0.01 sec)</code></pre><p>添加索引（name的key变成了MUL）：</p><pre><code>mysql&gt; alter table user add index i_name(name);Query OK, 0 rows affected (0.03 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(255)     | YES  | MUL | NULL    |                || age   | int(11)          | YES  |     | NULL    |                || email | varchar(255)     | YES  |     | NULL    |                || sign  | int(11)          | YES  |     | NULL    |                || grad  | varchar(255)     | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+6 rows in set (0.00 sec)</code></pre><h5 id="删除属性为普通索引的字段"><a href="#删除属性为普通索引的字段" class="headerlink" title="删除属性为普通索引的字段"></a>删除属性为普通索引的字段</h5><pre><code>mysql&gt; alter table user drop index i_name;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(255)     | YES  |     | NULL    |                || age   | int(11)          | YES  |     | NULL    |                || email | varchar(255)     | YES  |     | NULL    |                || sign  | int(11)          | YES  |     | NULL    |                || grad  | varchar(255)     | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+6 rows in set (0.00 sec)</code></pre><h5 id="删除表中的主键"><a href="#删除表中的主键" class="headerlink" title="删除表中的主键"></a>删除表中的主键</h5><p>删除表中的主键时比较特殊，id是自增类型，需要先修改id为非自增才能删除。直接删除会报错：</p><pre><code>mysql&gt; desc user;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(255)     | YES  |     | NULL    |                || age   | int(11)          | YES  |     | NULL    |                || email | varchar(255)     | YES  |     | NULL    |                || sign  | int(11)          | YES  |     | NULL    |                || grad  | varchar(255)     | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+6 rows in set (0.00 sec)mysql&gt; alter table user drop primary key;ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key</code></pre><pre><code>mysql&gt; show create table user\G;*************************** 1. row ***************************       Table: userCreate Table: CREATE TABLE `user` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,  `sign` int(11) DEFAULT NULL,  `grad` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci1 row in set (0.00 sec)ERROR:No query specifiedmysql&gt; alter table user modify id int(10) unsigned not null;Query OK, 7 rows affected (0.03 sec)Records: 7  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || name  | varchar(255)     | YES  |     | NULL    |       || age   | int(11)          | YES  |     | NULL    |       || email | varchar(255)     | YES  |     | NULL    |       || sign  | int(11)          | YES  |     | NULL    |       || grad  | varchar(255)     | YES  |     | NULL    |       |+-------+------------------+------+-----+---------+-------+6 rows in set (0.00 sec)mysql&gt; alter table user drop primary key;Query OK, 7 rows affected (0.02 sec)Records: 7  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   |     | NULL    |       || name  | varchar(255)     | YES  |     | NULL    |       || age   | int(11)          | YES  |     | NULL    |       || email | varchar(255)     | YES  |     | NULL    |       || sign  | int(11)          | YES  |     | NULL    |       || grad  | varchar(255)     | YES  |     | NULL    |       |+-------+------------------+------+-----+---------+-------+6 rows in set (0.00 sec)</code></pre><h3 id="外键约束（FOREIGN-KEY）"><a href="#外键约束（FOREIGN-KEY）" class="headerlink" title="外键约束（FOREIGN KEY）"></a>外键约束（FOREIGN KEY）</h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><blockquote><p>外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。外键的主要作用是保持数据的一致性、完整性.主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。</p></blockquote><p>注意：应该先创建主表，而且两个关联表必须为innodb，不然会报错：</p><pre><code>ERROR 1824 (HY000): Failed to open the referenced table &#39;tb_edu&#39;</code></pre><h4 id="完整测试小案例："><a href="#完整测试小案例：" class="headerlink" title="完整测试小案例："></a>完整测试小案例：</h4><p>创建主表person_edu：</p><pre><code>create table person_edu(    id int unsigned primary key,    edu char(20) not null default &#39;&#39;);</code></pre><pre><code>mysql&gt; desc person_edu;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || edu   | char(20)         | NO   |     |         |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>为person_edu表中的edu字段增加唯一性约束：</p><pre><code>mysql&gt; alter table person_edu add unique(edu);Query OK, 0 rows affected (0.03 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc person_edu;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| id    | int(10) unsigned | NO   | PRI | NULL    |       || edu   | char(20)         | NO   | UNI |         |       |+-------+------------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><p>插入数据：</p><pre><code>INSERT INTO `db_edu`.`person_edu`(`id`, `edu`) VALUES(1, &#39;小学&#39;),(2, &#39;初中&#39;),(3, &#39;高中&#39;),(4, &#39;本科&#39;),(5, &#39;硕士&#39;),(6, &#39;博士&#39;);</code></pre><p>创建从表（从表person的edu_id成为 person_edu的id字段的外键）：</p><pre><code>create table person(id int unsigned auto_increment,name char(20) not null default &#39;&#39;,age tinyint not null default 0,edu_id int unsigned not null default 1,email char(40) not null default &#39;&#39;,primary key(id,name),constraint FK_edu foreign key(edu_id) references person_edu(id));</code></pre><p>查看表的表述：</p><pre><code>mysql&gt; desc person;+--------+------------------+------+-----+---------+----------------+| Field  | Type             | Null | Key | Default | Extra          |+--------+------------------+------+-----+---------+----------------+| id     | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name   | char(20)         | NO   | PRI |         |                || age    | tinyint(4)       | NO   |     | 0       |                || edu_id | int(10) unsigned | NO   | MUL | 1       |                || email  | char(40)         | NO   |     |         |                |+--------+------------------+------+-----+---------+----------------+5 rows in set (0.00 sec)</code></pre><pre><code>mysql&gt; show create table person\G;*************************** 1. row ***************************       Table: personCreate Table: CREATE TABLE `person` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` char(20) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39;,  `age` tinyint(4) NOT NULL DEFAULT &#39;0&#39;,  `edu_id` int(10) unsigned NOT NULL DEFAULT &#39;1&#39;,  `email` char(40) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39;,  PRIMARY KEY (`id`,`name`),  KEY `FK_edu` (`edu_id`),  CONSTRAINT `FK_edu` FOREIGN KEY (`edu_id`) REFERENCES `person_edu` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci1 row in set (0.00 sec)</code></pre><p>为从表插入数据：</p><pre><code>INSERT INTO `db_edu`.`person`( `name`, `age`, `edu_id`, `email`) VALUES (&#39;wang&#39;, 26, 3, &#39;li@qq.com&#39;),(&#39;zhao&#39;, 25, 2, &#39;li3@qq.com&#39;), (&#39;qian&#39;, 32, 6, &#39;lfi@qq.com&#39;), (&#39;sun&#39;, 42, 1, &#39;lfafi@qq.com&#39;), (&#39;zhou&#39;, 34, 3, &#39;lfa2i@qq.com&#39;), (&#39;wu&#39;, 53, 5, &#39;lgfi@qq.com&#39;), (&#39;zheng&#39;, 64, 4, &#39;l532i@qq.com&#39;), (&#39;feng&#39;, 67, 1, &#39;lddi@qq.com&#39;), (&#39;chen&#39;, 25, 3, &#39;lgi@qq.com&#39;), (&#39;chu&#39;, 72, 4, &#39;lfasi@qq.com&#39;), (&#39;wei&#39;, 81, 5, &#39;lhasi@qq.com&#39;), (&#39;yang&#39;, 19, 6, &#39;lfai@qq.com&#39;);</code></pre><h4 id="删除从表外键"><a href="#删除从表外键" class="headerlink" title="删除从表外键"></a>删除从表外键</h4><pre><code>mysql&gt; alter table person drop foreign key FK_edu;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; show create table person\G;*************************** 1. row ***************************       Table: personCreate Table: CREATE TABLE `person` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` char(20) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39;,  `age` tinyint(4) NOT NULL DEFAULT &#39;0&#39;,  `edu_id` int(10) unsigned NOT NULL DEFAULT &#39;1&#39;,  `email` char(40) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39;,  PRIMARY KEY (`id`,`name`),  KEY `FK_edu` (`edu_id`)) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci1 row in set (0.00 sec)ERROR:No query specified</code></pre><h4 id="通过alter方式为现有的表增加外键"><a href="#通过alter方式为现有的表增加外键" class="headerlink" title="通过alter方式为现有的表增加外键"></a>通过alter方式为现有的表增加外键</h4><pre><code>mysql&gt; alter table person add constraint FK_edu foreign key(edu_id) references person_edu(id);Query OK, 12 rows affected (0.06 sec)Records: 12  Duplicates: 0  Warnings: 0mysql&gt; show create table person\G;*************************** 1. row ***************************       Table: personCreate Table: CREATE TABLE `person` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` char(20) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39;,  `age` tinyint(4) NOT NULL DEFAULT &#39;0&#39;,  `edu_id` int(10) unsigned NOT NULL DEFAULT &#39;1&#39;,  `email` char(40) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39;,  PRIMARY KEY (`id`,`name`),  KEY `FK_edu` (`edu_id`),  CONSTRAINT `FK_edu` FOREIGN KEY (`edu_id`) REFERENCES `person_edu` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci1 row in set (0.00 sec)ERROR:No query specified</code></pre><h4 id="删除没有关联的表："><a href="#删除没有关联的表：" class="headerlink" title="删除没有关联的表："></a>删除没有关联的表：</h4><pre><code>drop table if exists user_copy;</code></pre><h4 id="删除有关联的表"><a href="#删除有关联的表" class="headerlink" title="删除有关联的表"></a>删除有关联的表</h4><p>如果直接删除主表，则会显示失败。原因是会破坏表的完整性。如果必须要删除，则可以先删除与它关联的子表，再删除主表。但是，有的情况下可能需要保留子表而只删除父表，可以通过取消关联的外键，就可已删除父表了。</p><pre><code>mysql&gt; drop table if exists person_edu;ERROR 3730 (HY000): Cannot drop table &#39;person_edu&#39; referenced by a foreign key constraint &#39;FK_edu&#39; on table &#39;person&#39;.mysql&gt;</code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><h5 id="指定字段插入："><a href="#指定字段插入：" class="headerlink" title="指定字段插入："></a>指定字段插入：</h5><pre><code>insert  into member (user_name,gender,weight,birth) values(&#39;lgj&#39;,&#39;1&#39;,55.5,&#39;1963-11-22&#39;),(&#39;wsl&#39;,&#39;0&#39;,52.5,&#39;1965-08-27&#39;);</code></pre><h5 id="对于自增的主键id，赋值时直接给null："><a href="#对于自增的主键id，赋值时直接给null：" class="headerlink" title="对于自增的主键id，赋值时直接给null："></a>对于自增的主键id，赋值时直接给null：</h5><pre><code>insert into student (id,name,age,sex) values(null,&#39;刘星星&#39;,25,&#39;男&#39;);</code></pre><h5 id="插入数据时可以省略字段列表-但必须要按顺序给值"><a href="#插入数据时可以省略字段列表-但必须要按顺序给值" class="headerlink" title="插入数据时可以省略字段列表 但必须要按顺序给值"></a>插入数据时可以省略字段列表 但必须要按顺序给值</h5><pre><code>insert into student values(null,&#39;刘国杰&#39;,54,&#39;男&#39;);</code></pre><h5 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h5><pre><code>insert into student (id,name,age,sex) values(null,&#39;李梦强&#39;,20,&#39;男&#39;),(null,&#39;段亚辉&#39;,21,&#39;男&#39;),(null,&#39;王水兰&#39;,52,&#39;&#39;女&#39;);</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code>delete from student where id &gt;= 7;</code></pre><h5 id="查看删除该数据时数据库操作的描述（只是产看，并没有删除）"><a href="#查看删除该数据时数据库操作的描述（只是产看，并没有删除）" class="headerlink" title="查看删除该数据时数据库操作的描述（只是产看，并没有删除）"></a>查看删除该数据时数据库操作的描述（只是产看，并没有删除）</h5><pre><code>desc delete from user where id=12\G;</code></pre><h5 id="注意：普通删除后会保留删除的id号，不再让数据使用。truncate会删除表内容，重新建立表。"><a href="#注意：普通删除后会保留删除的id号，不再让数据使用。truncate会删除表内容，重新建立表。" class="headerlink" title="注意：普通删除后会保留删除的id号，不再让数据使用。truncate会删除表内容，重新建立表。"></a>注意：普通删除后会保留删除的id号，不再让数据使用。truncate会删除表内容，重新建立表。</h5><pre><code>truncate  student;</code></pre><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code>update student set age=28,sex=&#39;女&#39; where id=1;update student set age=26,name=&#39;段LL&#39; where name=&#39;鲁大师&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的内存管理总结</title>
      <link href="/2018/08/27/2018-08-27-ios-zhong-de-nei-cun-guan-li-zong-jie/"/>
      <url>/2018/08/27/2018-08-27-ios-zhong-de-nei-cun-guan-li-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>iOS通过以下三种方式来管理内存方案：</p><pre><code>TaggedPointer//非指针型的isaNONPOINTER_ISA//包含了引用计数表 和 弱引用表散列表</code></pre><h3 id="TaggedPointer"><a href="#TaggedPointer" class="headerlink" title="TaggedPointer"></a>TaggedPointer</h3><p>TaggedPointer对象是为了改进在64位架构下内存的占用和效率问题。比如NSNumber和NSDate，使用4个字节就可以基本满足需要，剩余的4个字节作为特殊的标记，表示这是一个特别的指针，不指向任何地址。</p><h3 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER_ISA"></a>NONPOINTER_ISA</h3><p>在arm64位下iOS操作系统，苹果也对isa指针进行了优化。Objective-C对象的isa区域不再只是一个指针.<br>NONPOINTER_ISA中，只有33位作为指针部分，其余的31位使用了类似于TaggedPointer的概念。在31位中，其中19位（extra_rc）被用来存储该对象额外的引用计数值，其余的位数用来标识是否关联过对象，是否有弱引用对象等标志。</p><h3 id="散列表方式"><a href="#散列表方式" class="headerlink" title="散列表方式"></a>散列表方式</h3><p>散列表的这种方案是通过sideTables()这种hash表来存储的。在sideTables下面挂载了若干个sideTable这种数据结构。sideTable下共包含3个元素：<br>1.自旋锁spinlock_t、2.引用计数表RefcountMap、3.弱引用表weak_table_t.</p><p>为什么不是一个sideTable？</p><blockquote><p>如果只有一张表时，当有多个线程来操作其中的一个对象，来更改它的引用计数时，为了保证数据的正确性，就需要为这张表进行加锁操作来保证安全，更改完成后再释放锁让其他的对象操作自己的引用计数。那么效率就会十分的低下。所以系统引入了分离锁这个方案，将内存对象存入到不同的sidetable来提高效率。</p></blockquote><p>那么我们如何快速的定位到它属于哪个sideTable呢？</p><blockquote><p>sideTables其实是个hash表。系统通过hash查找，来找到对应的索引。</p></blockquote><h4 id="自旋锁spinlock-t"><a href="#自旋锁spinlock-t" class="headerlink" title="自旋锁spinlock_t"></a>自旋锁spinlock_t</h4><p>自旋锁是一个忙等的锁。是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。<br>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><h4 id="引用计数表RefcountMap"><a href="#引用计数表RefcountMap" class="headerlink" title="引用计数表RefcountMap"></a>引用计数表RefcountMap</h4><p>RefcountMap实际上是一个哈希表。通过同哈希算法可以避免循环遍历，达到快速查找的目的。size_t用来存储一个对象的引用计数值（64）位。<br>其中第一位用weakly_referenced表示该对象是否有弱引用。第二位用deallocating表示当前对象是否正在进行dealloc。其余的用来保存引用计数。</p><h4 id="弱引用表weak-table-t"><a href="#弱引用表weak-table-t" class="headerlink" title="弱引用表weak_table_t"></a>弱引用表weak_table_t</h4><p>weak_table_t也是一个哈希表。对应的hash值用weak_entry_t来表示。</p><hr><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>ARC是LLVM编译器和Runtime共同协作来为我们实现引用计数的管理。ARC禁止手动调用retain/release/retaionCount/dealloc.ARC中新增了weak和strong属性关键字。</p><h4 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h4><h5 id="alloc的实现"><a href="#alloc的实现" class="headerlink" title="alloc的实现"></a>alloc的实现</h5><p>alloc的实现比较简单，就是经过一系列的调用，最终调用了C函数的calloc。注意，此时并没有设置引用计数为1.</p><h5 id="retain的实现"><a href="#retain的实现" class="headerlink" title="retain的实现"></a>retain的实现</h5><pre><code>SideTable&amp; table = SideTables()[this];size_t refcntStorage = table.refcnts[this];refcntStorage += SIDE_TABLE_RC_ONE;</code></pre><blockquote><p>我们可以知道，通过对象的this指针到SideTables中查找到该对象所在的table。然后再通过this指针查找到该对象所对应的引用计数值。因为是做retain操作，所以系统再通过SIDE_TABLE_RC_ONE这个宏对原有的refcntStorage引用计数再加上1.</p></blockquote><p>我们在进行retain操作的时候，系统是怎样查找它对应的引用计数的呢？</p><blockquote><p>通过上面的分析，我们可以知道，系统是通过两次哈希查找，来查找到对应的引用计数值，然后再做加一操作。</p></blockquote><h5 id="release实现"><a href="#release实现" class="headerlink" title="release实现"></a>release实现</h5><pre><code>SideTable&amp; table = SideTables()[this];RefcountMap::iterator it = table.refcnts.find(this);it-&gt;second -= SIDE_TABLE_RC_ONE;</code></pre><blockquote><p>同样的，系统首先通过this指针查找到对象所在的table表。然后再在table表中查找到对应的引用计数，再对该对象的引用计数做减一操作。</p></blockquote><h5 id="retainCount实现"><a href="#retainCount实现" class="headerlink" title="retainCount实现"></a>retainCount实现</h5><pre><code>SideTable&amp; table = SideTables()[this];size_t refcnt_result = 1;RefcountMap::iterator it = table.refcnts.find(this);refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</code></pre><blockquote><p>同样的，系统首先通过this指针查找到对象所在的table表，并初始化一个局部变量，然后再在table表中查找到对应的引用计数，再对该对象z做一次向右偏移操作，最后与局部变量refcnt_result的值1想加。所以呢，当我们新alloc一个对象时，虽然在引用计数表中是没有这个对象的，但由于refcnt_result初始化为1，所以alloc之后调用retainCount的结果为1.</p></blockquote><h5 id="dealloc实现"><a href="#dealloc实现" class="headerlink" title="dealloc实现"></a>dealloc实现</h5><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/BE2BBB45902844E08CD9F954476D2F18/28181" alt="image"></p><p>如上图所示，调用dealloc时，系统会在内部调用<code>_objc_rootDealloc</code>函数，<code>_objc_rootDealloc</code>函数内部又会调用<code>rootDealloc</code>函数。<code>rootDealloc</code>会做以下5种判断：</p><ul><li><ol><li>nonpointer_isa:判断当前对象是否使用了非指针型的isa</li></ol></li><li><ol start="2"><li>weakly_referenced:判断当前对象是否有weak指针指向它</li></ol></li><li><ol start="3"><li>has_assoc:判断当前对象是否有关联对象</li></ol></li><li><ol start="4"><li>has_cxx_dtor:判断当前对象的实现是否涉及到C++相关的内容，以及呢当前对象是否使用ARC来管理内存</li></ol></li><li><ol start="5"><li>has_sidetable_rc:判断当前对象的引用计数是否是通过sidetable表来维护的。因为有的对象是通过nonpointer_isa这种非指针型的isa指针来维护的，nonpointer_isa中有19位被用来存储对象的引用计数，当超过最大阈值时，再通过sidetable来维护引用计数。</li></ol></li></ul><p>当该对象根据以上5个条件判断均不满足时，那么系统会直接调用C中的函数free来直接释放对象。否则的话，系统会调用objct_dispose()来做进一步的操作。</p><h5 id="objct-dispose内部实现"><a href="#objct-dispose内部实现" class="headerlink" title="objct_dispose内部实现"></a>objct_dispose内部实现</h5><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/EA41DEAFEDCA47E1BCA3AC48830FB83E/28183" alt="image"></p><p>如上图所示，系统会调用objc_destructInstance函数来销毁对象的实例，然后再执行C函数的free函数。</p><h5 id="objc-destructInstance内部实现"><a href="#objc-destructInstance内部实现" class="headerlink" title="objc_destructInstance内部实现"></a>objc_destructInstance内部实现</h5><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/E3D6451E63344BA88094994F85DE149E/28185" alt="image"></p><p>如上图所示，系统会首先判断hasCxxDtor,上面已经说过hasCxxDtor是用来判断对象是否有c++的实现以及是否通过ARC来管理内存。如果有的话，系统会调用object_cxxDestruct函数来做进一步操作。如果没有的话，会接着判断hasAssociatedObjects是否有关联对象。如果有关联对象的话，系统会调用_object_remove_associations函数，接着如果没有关联对象的话，系统会调用clearDeallocating函数结束调用流程。</p><h5 id="clearDeallocating内部实现"><a href="#clearDeallocating内部实现" class="headerlink" title="clearDeallocating内部实现"></a>clearDeallocating内部实现</h5><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/9124BC005A1D49FF9CE1693F9647C1E4/28276" alt="image"></p><p>如上图所示，系统会首先调用sidetable_clearDeallocating函数，接着系统会调用weak_clear_no_lock,weak_clear_no_lock会将指向该对象的弱引用指针置为nil（这也就可以解释“为什么对象有weak指针指向时，当该对象dealloc时，它的weak指针为什么会自动被置为nil？”原因就是在dealloc的内部实现中，有做对象的弱引用指针置为nil的操作。 ）。在调用了weak_clear_no_lock函数之后，系统会调用table_refcnts.erase来对对象的引用计数进行擦除，将该对象在引用计数表中的相关存储给清除掉，最后结束调用流程。</p><h4 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h4><p>那么一个weak修饰的变量是怎样被添加到弱引用表当中的呢？</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/83E829C3A9CC4CDF83F43E3B7E0049BF/28288" alt="image"></p><p>如上图所示，当我们通过一个弱引用指针指向一个变量obj1时，代码经过编译后就入上图所示，调用了objc_initWeak函数。</p><h5 id="objc-initWeak函数的调用栈"><a href="#objc-initWeak函数的调用栈" class="headerlink" title="objc_initWeak函数的调用栈"></a>objc_initWeak函数的调用栈</h5><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/289B463635C240A48EF210EA85F78E7C/28296" alt="image"></p><p>如上图所示， objc_initWeak函数会首先调用storeWeak函数，接着调用weak_register_no_lock函数，到弱引用表中进行注册添加。在这个函数中，系统通过哈希算法得到需要插入的位置，如果该位置已经有了该对象对应的弱引用数组，那么系统就讲这个新的弱引用变量添加到该数组中，如果没有对应的数组，系统会重新创建一个弱引用数组，然后在该数组下标为0的位置添加这个新的弱引用指针。</p><p>我们知道，在销毁weak修饰的对象时，系统会同时将这个weak指针置为nil。那么系统是怎样实现的呢？</p><p>通过dealloc的分析，我们知道系统会在dealloc的底层调用weak_clear_no_lock函数。在这个函数中，系统会根据当前对象的弱引用指针查找弱引用表，把当前对象对应的弱引用数组给取出，然后遍历这个弱引用数组，将数组中的每一个弱引用指针分别置为nil。</p><h5 id="总结：为什么weak指针指向的对象被废弃后会被自动置为nil？"><a href="#总结：为什么weak指针指向的对象被废弃后会被自动置为nil？" class="headerlink" title="总结：为什么weak指针指向的对象被废弃后会被自动置为nil？"></a>总结：为什么weak指针指向的对象被废弃后会被自动置为nil？</h5><p>当对象被废弃后，对象的dealloc方法会有做对象的弱引用指针置为nil的方法（也就是weak_clear_no_lock方法）。在这个方法中，系统会根据当前对象的弱引用指针，通过哈希方法查找到当前对象对应的弱引用数组，然后遍历这个弱引用数组，将数组中的每一个弱引用指针分别置为nil。</p><hr><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>我们在OC中的main函数中会发现自动释放池的使用：</p><pre><code>#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) {    NSString * appDelegateClassName;    @autoreleasepool {        // Setup code that might create autoreleased objects goes here.        appDelegateClassName = NSStringFromClass([AppDelegate class]);    }    return UIApplicationMain(argc, argv, nil, appDelegateClassName);}</code></pre><p>@autoreleasepool经过编译器编译之后，会改写为以下的代码：</p><pre><code>void* ctx = objc_autoreleasePoolPush();{    //在xcode中被{}包裹的代码}objc_autoreleasePoolPop(ctx);</code></pre><h4 id="objc-autoreleasePoolPush和objc-autoreleasePoolPop的实现"><a href="#objc-autoreleasePoolPush和objc-autoreleasePoolPop的实现" class="headerlink" title="objc_autoreleasePoolPush和objc_autoreleasePoolPop的实现"></a>objc_autoreleasePoolPush和objc_autoreleasePoolPop的实现</h4><p>objc_autoreleasePoolPush内部会调用C++类的AutoreleasePoolPage中的push方法。对应的objc_autoreleasePoolPop会调用AutoreleasePoolPage类中的pop方法：</p><pre><code>void* objc_autoreleasePoolPush(void)      -----&gt;void* AutoreleasePoolPage::push(void)void* objc_autoreleasePoolPop(void* ctx)      -----&gt;void* AutoreleasePoolPage::pop(void* ctx)</code></pre><p>实际上，一次pop操作相当于一次批量的pop操作。也就是说，在@autoreleasepool中的花括号{}所包含的对象都会被添加到自动释放池中，当进行pop操作时，花括号中所有的对象都会被发送一次release消息。</p><h4 id="自动释放池的数据结构"><a href="#自动释放池的数据结构" class="headerlink" title="自动释放池的数据结构"></a>自动释放池的数据结构</h4><p>实际上，自动释放池是以栈为节点通过双向链表的形式组合而成，并且它是和线程一一对应的。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/BC46FB527433412C9C8F2BC4D872CC41/28376" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/8F07A4A8485A404D86631282A953DB44/28380" alt="image"></p><h5 id="AutoreleasePoolPage的内部实现"><a href="#AutoreleasePoolPage的内部实现" class="headerlink" title="AutoreleasePoolPage的内部实现"></a>AutoreleasePoolPage的内部实现</h5><p>如下图所示，AutoreleasePoolPage主要有4个成员变量：next指向下一个可以填充的位置；而parent和next则是双向链表中的父指针和子指针；thread则很明显是一个线程相关的变量，所以我们才说autoreleasePool是和线程一一对应的。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/29EF31D5E7C049A49E58EE159D7CC1D4/28386" alt="image"></p><p>如下图所示，在这个栈中，存放的就是@autoreleasepool中花括号中创建的autorelease对象。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/E71B11B09AEE4334B314132BD0BF4E52/28400" alt="image"></p><h5 id="AutoreleasePoolPage-push的实现"><a href="#AutoreleasePoolPage-push的实现" class="headerlink" title="AutoreleasePoolPage::push的实现"></a>AutoreleasePoolPage::push的实现</h5><p>当调用AutoreleasePoolPage::push函数时，意味着会向栈中添加新的一批对象。此时，会将当前的next置为nil，我们称它为哨兵对象。同时将next指针指向下一个可以入栈的位置，然后将这一批对象依次添加到栈中。这也就是AutoreleasePoolPage的push方法的实现过程。实际上，我们每次进行一个@autoreleasepool的代码块的创建，就相当于不断的先在栈中插入哨兵对象，然后添加一批新的autorelease对象的过程。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/5ADB4857E9A14D51B0ABA802A4127CD7/28420" alt="image"></p><h5 id="对象调用autorelease的流程"><a href="#对象调用autorelease的流程" class="headerlink" title="对象调用autorelease的流程"></a>对象调用autorelease的流程</h5><p>如下图，当我们调用了一个对象的autorelease，那么系统会先判断栈中的next指针是否指向了栈顶，如果没有指向栈顶，说明还有存储空间，便直接做入栈的push操作，将该对象添加到next的位置；如果next已经位于栈顶，那么系统会先新增加一个栈节点到链表上，然后在新的栈上添加对象。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/B57FF57C802448C29835BF5DB3717B8C/28431" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/800CF036B2A24E11B91CBA6DAF4D227D/28445" alt="image"></p><h5 id="AutoreleasePoolPage-pop"><a href="#AutoreleasePoolPage-pop" class="headerlink" title="AutoreleasePoolPage::pop"></a>AutoreleasePoolPage::pop</h5><p>如下图所示：在进行pop操作的时候，系统会根据传入的哨兵对象找到对应的位置。而这个哨兵对象，就是上面提到过的<code>void* ctx = objc_autoreleasePoolPush();</code>,然后将哨兵对象ctx传给pop函数<code>objc_autoreleasePoolPop(ctx);</code>。通过哨兵对象找到对应的位置之后，系统就会给上次push操作之后添加的对象依次发送release消息，最后再将next指针回退到正确的位置。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/02F03F6FA193448992443660562E55AF/28469" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/E0BC4947137E4946BFAA9E1BDFCE610B/28472" alt="image"></p><h5 id="下面代码，array对象的内存是什么时候释放的呢？"><a href="#下面代码，array对象的内存是什么时候释放的呢？" class="headerlink" title="下面代码，array对象的内存是什么时候释放的呢？"></a>下面代码，array对象的内存是什么时候释放的呢？</h5><pre><code>- (void)viewDidLoad {    [super viewDidLoad];    NSMutableArray *array = [NSMutableArray array];    NSLog(@&quot;%@&quot;, array);}</code></pre><blockquote><p>实际上，在每一次的runloop循环当中，runloop都会在它将要结束的时候，对前一次创建的autoreleasePool进行pop操作，然后再push进来一个新的autoreleasePool。所以说，我们在viewDidLoad中创建的array对象，会在当次runloop将要结束的时候调用AutoreleasePoolPage::pop(),对array进行释放。</p></blockquote><h5 id="autoreleasePool的实现原理是怎样的？"><a href="#autoreleasePool的实现原理是怎样的？" class="headerlink" title="autoreleasePool的实现原理是怎样的？"></a>autoreleasePool的实现原理是怎样的？</h5><blockquote><p>autoreleasePool是以栈为节点通过双向链表形式组合而成的数据结构。</p></blockquote><h5 id="autoreleasePool为什么可以嵌套使用呢？"><a href="#autoreleasePool为什么可以嵌套使用呢？" class="headerlink" title="autoreleasePool为什么可以嵌套使用呢？"></a>autoreleasePool为什么可以嵌套使用呢？</h5><blockquote><p>实际上，多层嵌套调用就是多次插入哨兵对象。我们每次进行@autoreleasepool中代码块创建的时候，系统就会为我们进行一次哨兵对象的插入，然后将这批对象添加到AutoreleasePoolPage当中。</p></blockquote><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>iOS中的循环引用可以分为3种：自循环引用、相互循环引用、多循环引用。</p><h4 id="自循环引用"><a href="#自循环引用" class="headerlink" title="自循环引用"></a>自循环引用</h4><p>如下图，创建一个对象，该对象有个成员变量obj，当我们将该对象赋值给obj的话，就会产生自循环引用的问题。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/8CF7408482CC47E19E870A03D127F40A/28511" alt="image"></p><h4 id="相互循环引用"><a href="#相互循环引用" class="headerlink" title="相互循环引用"></a>相互循环引用</h4><p>如下图，有两个对象，他们均有一个成员变量引用了对方，就会造成相互循环引用。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/4A2F4A97FC0B4965A989ADB8476835F3/28519" alt="image"></p><h4 id="多循环引用"><a href="#多循环引用" class="headerlink" title="多循环引用"></a>多循环引用</h4><p>如下图，多循环引用其实跟相互循环引用的情况是一样的，就是多个对象依次引用下一个对象造成的。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/71F857102EBE4AFB83BE66CF455E0C36/28526" alt="image"></p><h4 id="如何解决循环引用？"><a href="#如何解决循环引用？" class="headerlink" title="如何解决循环引用？"></a>如何解决循环引用？</h4><p>我们在开发中，经常涉及到的循环引用有代理、Block、NSTimer等情况。一方面，我们可以通过避免循环引用，例如我们在使用代理时，通过弱引用来避免产生循环引用。比如使用<code>__weak __block __unsafe_unretained</code>.另一方面，我们也可以在合适的时机通过手动来断开循环引用。</p><blockquote><p>通过<strong>block方式来避免循环引用需要注意</strong>block在MRC和在ARC中不同的表现。在MRC中，<strong>block不会增加引用计数，避免了循环引用。但是在ARC下，</strong>block修饰的对象会被强引用，无法避免循环引用，需要我们手动解环。</p></blockquote><blockquote><p>通过<strong>unsafe_unretained来避免循环引用时，</strong>unsafe_unretained修饰的对象不会增加引用计数，从而避免了循环引用。但是，如果被<strong>unsafe_unretained修饰的对象在某一时机被释放，会产生悬垂指针。所以我们也不建议使用</strong>unsafe_unretained来解决循环引用的问题。</p></blockquote><h5 id="解决NSTimer造成的循环引用"><a href="#解决NSTimer造成的循环引用" class="headerlink" title="解决NSTimer造成的循环引用"></a>解决NSTimer造成的循环引用</h5><p>定时器有重复定时器和非重复定时器的分别。非重复定时器使用时一般是在回调方法中调用<code>[timer invalidate]; timer = nil;</code>来解决循环引用的问题。这里我们讨论的是重复定时器。首先，我们要明白NSTimer造成循环引用的原因。例如我们要实现一个无限滚动的广告栏View。那么我们的控制器VC会持有这个View，而View为了实现定时滚动，则会运用到了定时器。我们知道定时器会通过targe持有这个View。这个时候就产生了View和Timer相互引用的问题。</p><pre><code>[NSTimer scheduledTimerWithTimeInterval:interval target:object selector:@selector(fire:) userInfo:userInfo repeats:repeats];</code></pre><p>如下图，如果是想通过View对Timer使用弱引用的方式来解决循环引用的方式是行不通的。因为当View中的Timer被创建启动后，Timer会被当前的runloop进行强引用，如果timer是在主线程创建的，那么这个timer便会被主线程的runloop所持有。由于主线程的runloop常住内存，所以runloop会对timer进行强引用，而timer又通过targe对view进行强引用，这就形成了主线程的runloop对view对象的强引用。所以，当控制器VC销毁后，它的这个循环滚动的子视图view由于被runloop强持有，从而无法销毁。进而造成了内存泄露。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/35C5AC10280748A6A1A3721883B17B87/28599" alt="image"></p><p>如下图，我们可以通过创建中间对象来解决Timer造成的循环引用问题。中间对象对Timer对象和view视图对象都采用弱引用的方式。由此轮播图的view只被控制器VC所持有。当控制器VC退出后就会释放对轮播图View。当定时器Timer进行下次循环的回调时，会判断视图对象是否被释放废弃掉了，如果被释放了则调用timer的invalidate方法。由于Timer和中间对象并没有形成相互引用，从而解决了内存泄露的问题（实际上，我们运用中间对象的思路，就是利用视图对象被释放后，中间对象对视图的弱引用会被置为nil这个原理，来在这个时机解决循环引用的问题）。</p><p><img src="https://note.youdao.com/yws/public/resource/29c97d56d2957fcf5f47e6d23fcd3f2a/xmlnote/F83C23F1163E41EB8A0635CBABE22A7C/28609" alt="image"></p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface NSTimer (WeakTimer)+ (NSTimer *)scheduledWeakTimerWithTimeInterval:(NSTimeInterval)interval                                         target:(id)aTarget                                       selector:(SEL)aSelector                                       userInfo:(id)userInfo                                        repeats:(BOOL)repeats;@end</code></pre><pre><code>#import &quot;NSTimer+WeakTimer.h&quot;@interface TimerWeakObject : NSObject@property (nonatomic, weak) id target;@property (nonatomic, assign) SEL selector;@property (nonatomic, weak) NSTimer *timer;- (void)fire:(NSTimer *)timer;@end@implementation TimerWeakObject- (void)fire:(NSTimer *)timer{    if (self.target) {        if ([self.target respondsToSelector:self.selector]) {            [self.target performSelector:self.selector withObject:timer.userInfo];        }    }    else{        [self.timer invalidate];        self.timer = nil;    }}@end@implementation NSTimer (WeakTimer)+ (NSTimer *)scheduledWeakTimerWithTimeInterval:(NSTimeInterval)interval                                         target:(id)aTarget                                       selector:(SEL)aSelector                                       userInfo:(id)userInfo                                        repeats:(BOOL)repeats{    TimerWeakObject *object = [[TimerWeakObject alloc] init];    object.target = aTarget;    object.selector = aSelector;    object.timer = [NSTimer scheduledTimerWithTimeInterval:interval target:object selector:@selector(fire:) userInfo:userInfo repeats:repeats];    return object.timer;}@end</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 总结提高 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的GCD使用总结</title>
      <link href="/2018/08/03/2018-08-03-ios-zhong-de-gcd-shi-yong-zong-jie/"/>
      <url>/2018/08/03/2018-08-03-ios-zhong-de-gcd-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="iOS中的GCD使用总结"><a href="#iOS中的GCD使用总结" class="headerlink" title="iOS中的GCD使用总结"></a>iOS中的GCD使用总结</h2><p>GCD是iOS开发者必须要熟练掌握和使用的异步执行任务的技术之一。下面是我自己总结的GCD的使用总结。</p><h3 id="GCD的API"><a href="#GCD的API" class="headerlink" title="GCD的API"></a>GCD的API</h3><h4 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h4><p>GCD中，执行时存在2种Dispatch Queue。一种是串行队列Serial Dispatch Queue，一种是并发队列Concurrent Dispatch Queue。我们可以自己创建串行队列和并发队列：</p><pre><code>// 串行队列dispatch_queue_t serialQueue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL); //并发队列 dispatch_queue_t concurrentQueue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</code></pre><blockquote><p>串行队列Serial Dispatch Queue是指执行多个任务时，任务会按照先后顺序一个一个执行，也就是说Serial Dispatch Queue同时只能执行一个任务。注意：使用dispatc_queue_create函数时，第二个参数如果不指定为DISPATCH_QUEUE_SERIAL或者DISPATCH_QUEUE_CONCURRENT，传入NULL则为串行队列。</p></blockquote><p>虽然如此，你却可以创建多个Serial Dispatch Queue队列，此时各个Serial Dispatch Queue将并行执行。比如你可以通过<code>dispatch_queue_create</code>同时创建5个串行队列，然后再在每个串行队列中执行一个任务，那么CPU将同时执行这5个任务。</p><p>但是，如果我们创建过多的线程，就会造成大量的性能开销，造成CPU的频繁调度，反而会降低系统的性能。</p><h4 id="Dispatch-Main-Queue"><a href="#Dispatch-Main-Queue" class="headerlink" title="Dispatch Main Queue"></a>Dispatch Main Queue</h4><p>我们可以获取系统为我们提供的Dispatch Queue。比如Main Dispatch  Queue和Global Dispatch  Queue。</p><pre><code>// 主队列dispatch_queue_t mainQueue = dispatch_get_main_queue();</code></pre><blockquote><p> Main Dispatch  Queue就是我们说的主线程或者UI线程。因为主线程只有一个，Main Dispatch  Queue自然就是串行队列Serial Dispatch Queue。</p></blockquote><h4 id="Global-Dispatch-Queue"><a href="#Global-Dispatch-Queue" class="headerlink" title="Global Dispatch  Queue"></a>Global Dispatch  Queue</h4><p>系统为我们提供了并发队列Concurrent Dispatch Queue：</p><pre><code>// 全局队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</code></pre><blockquote><p> Global Dispatch  Queue共提供了4个优先级。DISPATCH_QUEUE_PRIORITY_HIGH:高优先级；DISPATCH_QUEUE_PRIORITY_DEFAULT：默认优先级；DISPATCH_QUEUE_PRIORITY_LOW：低优先级；DISPATCH_QUEUE_PRIORITY_BACKGROUND： 后台。</p></blockquote><p>声明的宏定义如下：</p><pre><code>#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</code></pre><h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><p>我们通过<code>dispatch_queue_create</code>创建生成的队列，默认使用的优先级都是与<code>dispatch_get_global_queue</code>使用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>的优先级相同。而如果你想要改变自己创建的队列的优先级，需要使用<code>dispatch_set_target_queue</code>函数来实现：</p><pre><code>// 自己创建的队列dispatch_queue_t serialQueue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);// 使用系统提供的队列，并指定优先级为DISPATCH_QUEUE_PRIORITY_BACKGROUNDdispatch_queue_t  globalBackgoundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);//我们希望自己创建的队列也使用与DISPATCH_QUEUE_PRIORITY_BACKGROUND相同的优先级，可以这样指定：// (原队列， 参考的队列) dispatch_set_target_queue(serialQueue, globalBackgoundQueue);</code></pre><blockquote><p>请不要将原队列设置为主队列Main  Queue和全局队列Global   Queue。</p></blockquote><p>通过dispatch_get_global_queue不仅可以改变队列的优先级，还可以变更队列的“执行阶层”。我们创建5个串行队列，然后异步执行：</p><pre><code>    dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;liuxingxing1&quot;, NULL);    dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;liuxingxing2&quot;, NULL);    dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;liuxingxing3&quot;, NULL);    dispatch_queue_t serialQueue4 = dispatch_queue_create(&quot;liuxingxing4&quot;, NULL);    dispatch_queue_t serialQueue5 = dispatch_queue_create(&quot;liuxingxing5&quot;, NULL);    dispatch_async(serialQueue1, ^{        NSLog(@&quot;1:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue2, ^{        NSLog(@&quot;2:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue3, ^{        NSLog(@&quot;3:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue4, ^{        NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue5, ^{        NSLog(@&quot;5:%@&quot;,[NSThread currentThread]);    });</code></pre><p>打印结果如下：</p><pre><code>2018-08-02 09:40:14.540502+0800 GCD[77612:10924290] 2:&lt;NSThread: 0x6000034e7240&gt;{number = 5, name = (null)}2018-08-02 09:40:14.540506+0800 GCD[77612:10924287] 1:&lt;NSThread: 0x6000034cb240&gt;{number = 6, name = (null)}2018-08-02 09:40:14.540588+0800 GCD[77612:10924291] 5:&lt;NSThread: 0x6000034e6c40&gt;{number = 3, name = (null)}2018-08-02 09:40:14.540544+0800 GCD[77612:10924293] 4:&lt;NSThread: 0x6000034cb280&gt;{number = 7, name = (null)}2018-08-02 09:40:14.540644+0800 GCD[77612:10924298] 3:&lt;NSThread: 0x6000034cb300&gt;{number = 8, name = (null)}</code></pre><blockquote><p>通过打印，我们可以看到，系统为5个队列分别开了5个线程，5个线程并行执行，没有先后顺序。</p></blockquote><p>现在，我们再创建一个串行队列，让这5个串行队列作为该队列的执行阶层：</p><pre><code>    // 目标串行队列    dispatch_queue_t targetSerialQueue = dispatch_queue_create(&quot;liuxingxing&quot;, NULL);    // 5个用于测试的串行队列    dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;liuxingxing1&quot;, NULL);    dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;liuxingxing2&quot;, NULL);    dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;liuxingxing3&quot;, NULL);    dispatch_queue_t serialQueue4 = dispatch_queue_create(&quot;liuxingxing4&quot;, NULL);    dispatch_queue_t serialQueue5 = dispatch_queue_create(&quot;liuxingxing5&quot;, NULL);    // 将这5个队列设置为目标队列的执行阶层：    dispatch_set_target_queue(serialQueue1, targetSerialQueue);    dispatch_set_target_queue(serialQueue2, targetSerialQueue);    dispatch_set_target_queue(serialQueue3, targetSerialQueue);    dispatch_set_target_queue(serialQueue4, targetSerialQueue);    dispatch_set_target_queue(serialQueue5, targetSerialQueue);    NSLog(@&quot;执行了。。。&quot;);    dispatch_async(serialQueue1, ^{        NSLog(@&quot;1:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue2, ^{        NSLog(@&quot;2:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue3, ^{        NSLog(@&quot;3:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue4, ^{        NSLog(@&quot;4:%@&quot;,[NSThread currentThread]);    });    dispatch_async(serialQueue5, ^{        NSLog(@&quot;5:%@&quot;,[NSThread currentThread]);    });    NSLog(@&quot;我也执行了。。。&quot;);</code></pre><p>打印结果如下：</p><pre><code>2018-08-02 09:54:08.938848+0800 GCD[78218:10933655] 执行了。。。2018-08-02 09:54:08.939075+0800 GCD[78218:10933655] 我也执行了。。。2018-08-02 09:54:08.939155+0800 GCD[78218:10933741] 1:&lt;NSThread: 0x6000004e0180&gt;{number = 5, name = (null)}2018-08-02 09:54:08.939307+0800 GCD[78218:10933741] 2:&lt;NSThread: 0x6000004e0180&gt;{number = 5, name = (null)}2018-08-02 09:54:08.939431+0800 GCD[78218:10933741] 3:&lt;NSThread: 0x6000004e0180&gt;{number = 5, name = (null)}2018-08-02 09:54:08.939567+0800 GCD[78218:10933741] 4:&lt;NSThread: 0x6000004e0180&gt;{number = 5, name = (null)}2018-08-02 09:54:08.939698+0800 GCD[78218:10933741] 5:&lt;NSThread: 0x6000004e0180&gt;{number = 5, name = (null)}</code></pre><blockquote><p>我们可以发现，5个串行队列在一个编号为5的子线程中异步串行执行了。</p></blockquote><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p>我们有时候需要延迟指定时间后做执行的场景。假如你希望延迟5s后执行处理，可以这样实现：</p><pre><code>    NSLog(@&quot;执行了。。。&quot;);    dispatch_time_t afterTime = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);    dispatch_after(afterTime, dispatch_get_main_queue(), ^{        NSLog(@&quot;我5秒后执行了。。。&quot;);    });    NSLog(@&quot;我也执行了。。。&quot;);</code></pre><blockquote><p>补充：5ull * NSEC_PER_SEC的乘积结果是单位为毫微秒的数值。“ull”是C语言的数值字面量，是显式表明类型时使用的字符串（表示“unsigned long long”）。如果使用NSEC_PER_MSEC，则表示已毫秒计算。如果不是很清晰，我们可以点击这个宏，就一目了然了。</p></blockquote><pre><code>#define NSEC_PER_SEC 1000000000ull#define NSEC_PER_MSEC 1000000ull#define USEC_PER_SEC 1000000ull#define NSEC_PER_USEC 1000ull#define DISPATCH_TIME_NOW (0ull)</code></pre><p>接下来，我们查看打印结果，结果如下：</p><pre><code>2018-08-02 10:16:51.485556+0800 GCD[79047:10947179] 执行了。。。2018-08-02 10:16:51.485787+0800 GCD[79047:10947179] 我也执行了。。。2018-08-02 10:16:56.486077+0800 GCD[79047:10947179] 我5秒后执行了。。。</code></pre><blockquote><p>需要注意的是，5s后执行是指5s后将block中的业务处理添加到mainQueue中，而不是说5s后执行block中的业务代码。也就是说，如果主队列mainQueue中有大量耗时操作时，虽然5s时追加到了主队列，但这个实际执行的时间要比5s时间长的多。</p></blockquote><p>我们一般会使用dispatch_time函数来计算相对时间。但是我们如果想使用绝对时间，例如在“2018-08-02 11:19:00”时执行，可以使用<code>**struct** timespec</code>来实现：</p><pre><code>dispatch_time_t getDispatchTimeByDate(NSDate *date) {    NSTimeInterval interval;    double second, subsecond;    struct timespec time;    dispatch_time_t milestone;    interval = [date timeIntervalSince1970];    subsecond = modf(interval, &amp;second);    time.tv_sec = second;    time.tv_nsec = subsecond * NSEC_PER_SEC;    milestone = dispatch_walltime(&amp;time, 0);    return milestone;}</code></pre><p>调用该函数：</p><pre><code>    NSLog(@&quot;执行了。。。&quot;);    NSDateFormatter * form = [[NSDateFormatter alloc]init];    form.dateFormat = @&quot;yyyy-MM-dd HH:mm:ss&quot;;    NSDate *date = [form dateFromString:@&quot;2018-08-02 11:19:00&quot;];    dispatch_after(getDispatchTimeByDate(date), dispatch_get_main_queue(), ^{        NSLog(@&quot;我在2018-08-02 11:19:00秒执行了。。。&quot;);    });    NSLog(@&quot;我也执行了。。。&quot;);</code></pre><p>打印结果：</p><pre><code>2018-08-02 11:18:08.710400+0800 GCD[81313:10983251] 执行了。。。2018-08-02 11:18:08.724402+0800 GCD[81313:10983251] 我也执行了。。。2018-08-02 11:19:00.001673+0800 GCD[81313:10983251] 我在2018-08-02 11:19:00秒执行了。。。</code></pre><h4 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h4><p>如果我们使用异步并发队列执行多个耗时操作，执行完毕后希望在主队列main Queue中再做下一步的处理。这时候你可以使用Dispatch Group来实现这个功能。</p><pre><code>    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    dispatch_group_t group = dispatch_group_create();    dispatch_group_async(group, queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });    dispatch_group_async(group, queue, ^{        NSLog(@&quot;执行了2:%@&quot;,[NSThread currentThread]);    });    dispatch_group_async(group, queue, ^{        NSLog(@&quot;执行了3:%@&quot;,[NSThread currentThread]);    });    dispatch_group_notify(group, dispatch_get_main_queue(), ^{        NSLog(@&quot;我也执行了。。。&quot;);    });</code></pre><p>执行结果如下：</p><pre><code>2018-08-02 11:49:09.194348+0800 GCD[82438:11001111] 执行了1:&lt;NSThread: 0x6000007916c0&gt;{number = 4, name = (null)}2018-08-02 11:49:09.194348+0800 GCD[82438:11001100] 执行了3:&lt;NSThread: 0x60000079fe40&gt;{number = 7, name = (null)}2018-08-02 11:49:09.194348+0800 GCD[82438:11001102] 执行了2:&lt;NSThread: 0x600000791980&gt;{number = 5, name = (null)}2018-08-02 11:49:09.212106+0800 GCD[82438:11000996] 我也执行了。。。</code></pre><blockquote><p>无论子队列按照什么顺序执行，主队列都会在所有子队列执行完毕后再做处理。</p></blockquote><h5 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h5><p>我们也可以在Dispatch Group中使用dispatch_group_wait函数，dispatch_group_wait可以指定超时的时间。例如，我们的超时时间为5s，超过5s，则提示用户失败：</p><pre><code>    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    dispatch_group_t group = dispatch_group_create();    dispatch_group_async(group, queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });    dispatch_group_async(group, queue, ^{        NSLog(@&quot;执行了2:%@&quot;,[NSThread currentThread]);    });    dispatch_group_async(group, queue, ^{        NSLog(@&quot;执行了3:%@&quot;,[NSThread currentThread]);    });    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,  5ull * NSEC_PER_SEC);    long result = dispatch_group_wait(group,time);    if (result == 0) {        NSLog(@&quot;5s内执行完毕了。。。&quot;);    } else {        NSLog(@&quot;5s内还没有执行完！！！！&quot;);    }</code></pre><blockquote><p> 如果dispatch_group_wait的返回值result不为0，就意味着在指定时间内，Dispatch Group中还有处理没有完成；如果返回值为0，表示已经在指定时间内完成。</p></blockquote><p>如果设置的超时时间为<code>DISPATCH_TIME_FOREVER</code>，那么就意味着会一直等待，直到Dispatch Group完成。所以dispatch_group_wait的返回值result将一直为0。如果指定超时时间为<code>DISPATCH_TIME_NOW</code>，则不设置超时时间，立即判断Dispatch Group是否执行结束。</p><pre><code>#define DISPATCH_TIME_NOW (0ull)#define DISPATCH_TIME_FOREVER (~0ull)</code></pre><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>dispatch_barrier_async可以想象为一个栅栏，在一个异步并发的多线程任务中，执行顺序是不固定的：</p><pre><code>    NSLog(@&quot;执行了。。。&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;liuxingxing&quot;, DISPATCH_QUEUE_CONCURRENT);    dispatch_async(queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了2:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了3:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了4:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了5:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了6:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了7:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了8:%@&quot;,[NSThread currentThread]);    });     NSLog(@&quot;我也执行了。。。&quot;);</code></pre><p>打印结果如下：</p><pre><code>2018-08-02 18:56:09.165354+0800 GCD[1349:11264928] 执行了。。。2018-08-02 18:56:09.167767+0800 GCD[1349:11264928] 我也执行了。。。2018-08-02 18:56:09.168206+0800 GCD[1349:11265364] 执行了1:&lt;NSThread: 0x600000d8cf00&gt;{number = 15, name = (null)}2018-08-02 18:56:09.169986+0800 GCD[1349:11265364] 执行了2:&lt;NSThread: 0x600000d8cf00&gt;{number = 15, name = (null)}2018-08-02 18:56:09.171324+0800 GCD[1349:11265596] 执行了4:&lt;NSThread: 0x600000d71b00&gt;{number = 18, name = (null)}2018-08-02 18:56:09.171176+0800 GCD[1349:11265594] 执行了3:&lt;NSThread: 0x600000d9de00&gt;{number = 17, name = (null)}2018-08-02 18:56:09.171441+0800 GCD[1349:11265364] 执行了5:&lt;NSThread: 0x600000d8cf00&gt;{number = 15, name = (null)}2018-08-02 18:56:09.171562+0800 GCD[1349:11265596] 执行了8:&lt;NSThread: 0x600000d71b00&gt;{number = 18, name = (null)}2018-08-02 18:56:09.171559+0800 GCD[1349:11265594] 执行了7:&lt;NSThread: 0x600000d9de00&gt;{number = 17, name = (null)}2018-08-02 18:56:09.171611+0800 GCD[1349:11265598] 执行了6:&lt;NSThread: 0x600000d71580&gt;{number = 19, name = (null)}</code></pre><p>现在，我们希望在执行线程3和执行线程4之间做些操作，就可以使用dispatch_barrier_async函数。</p><pre><code>    NSLog(@&quot;执行了。。。&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;liuxingxing&quot;, DISPATCH_QUEUE_CONCURRENT);    dispatch_async(queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了2:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了3:%@&quot;,[NSThread currentThread]);    });    dispatch_barrier_async(queue, ^{        NSLog(@&quot;我是3和4之间的dispatch_barrier_async&quot;);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了4:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了5:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了6:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了7:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了8:%@&quot;,[NSThread currentThread]);    });     NSLog(@&quot;我也执行了。。。&quot;);</code></pre><p>打印结果如下：</p><pre><code>2018-08-02 19:01:25.175002+0800 GCD[1389:11268238] 我也执行了。。。2018-08-02 19:01:25.176161+0800 GCD[1389:11268735] 执行了1:&lt;NSThread: 0x600000edf840&gt;{number = 10, name = (null)}2018-08-02 19:01:25.176187+0800 GCD[1389:11268826] 执行了2:&lt;NSThread: 0x600000edfcc0&gt;{number = 11, name = (null)}2018-08-02 19:01:25.176276+0800 GCD[1389:11268827] 执行了3:&lt;NSThread: 0x600000edff00&gt;{number = 12, name = (null)}2018-08-02 19:01:25.176630+0800 GCD[1389:11268827] 我是3和4之间的dispatch_barrier_async2018-08-02 19:01:25.176820+0800 GCD[1389:11268826] 执行了5:&lt;NSThread: 0x600000edfcc0&gt;{number = 11, name = (null)}2018-08-02 19:01:25.176782+0800 GCD[1389:11268827] 执行了4:&lt;NSThread: 0x600000edff00&gt;{number = 12, name = (null)}2018-08-02 19:01:25.176936+0800 GCD[1389:11268735] 执行了6:&lt;NSThread: 0x600000edf840&gt;{number = 10, name = (null)}2018-08-02 19:01:25.177329+0800 GCD[1389:11268828] 执行了7:&lt;NSThread: 0x600000ed1f40&gt;{number = 13, name = (null)}2018-08-02 19:01:25.177525+0800 GCD[1389:11268829] 执行了8:&lt;NSThread: 0x600000ed1d40&gt;{number = 14, name = (null)}</code></pre><blockquote><p>可以看到，dispatch_barrier_async就好比一个栅栏，栅栏两侧的线程无论什么执行顺序，但是dispatch_barrier_async会始终“横亘”在线程3和线程4之间。</p></blockquote><h4 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h4><p>dispatch_async与dispatch_sync两者的区别是：dispatch_async是异步队列，所谓异步，就是指不会等待block块的执行完毕才会执行后面的代码；dispatch_sync则恰恰相反，表示是同步队列，表示在block代码快执行完毕之前，不会执行后面的代码。</p><p>我们先看dispatch_async异步执行的代码：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;liuxingxing&quot;, DISPATCH_QUEUE_CONCURRENT);    dispatch_async(queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了2:%@&quot;,[NSThread currentThread]);    });    dispatch_async(queue, ^{        NSLog(@&quot;执行了3:%@&quot;,[NSThread currentThread]);    });     NSLog(@&quot;end。。。&quot;);</code></pre><p>dispatch_async的执行结果是这样的：</p><pre><code>2018-08-02 19:11:10.560857+0800 GCD[1490:11273203] start。。。2018-08-02 19:11:10.561109+0800 GCD[1490:11273203] end。。。2018-08-02 19:11:10.561169+0800 GCD[1490:11273294] 执行了1:&lt;NSThread: 0x6000005ef400&gt;{number = 3, name = (null)}2018-08-02 19:11:10.561225+0800 GCD[1490:11273293] 执行了3:&lt;NSThread: 0x60000058b040&gt;{number = 6, name = (null)}2018-08-02 19:11:10.561225+0800 GCD[1490:11273297] 执行了2:&lt;NSThread: 0x6000005b5740&gt;{number = 5, name = (null)}</code></pre><blockquote><p>我们可以看到，“start”和“end”按照代码执行顺序分别为开始和结束，但是异步函数却没有等待block中的代码执行完毕后再执行end.</p></blockquote><p>dispatch_sync的测试代码如下：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;liuxingxing&quot;, DISPATCH_QUEUE_CONCURRENT);    dispatch_sync(queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });    dispatch_sync(queue, ^{        NSLog(@&quot;执行了2:%@&quot;,[NSThread currentThread]);    });    dispatch_sync(queue, ^{        NSLog(@&quot;执行了3:%@&quot;,[NSThread currentThread]);    });     NSLog(@&quot;end。。。&quot;);</code></pre><p>dispatch_sync的执行结果是这样的：</p><pre><code>2018-08-02 19:20:51.028573+0800 GCD[1642:11279240] start。。。2018-08-02 19:20:51.028822+0800 GCD[1642:11279240] 执行了1:&lt;NSThread: 0x6000018918c0&gt;{number = 1, name = main}2018-08-02 19:20:51.028980+0800 GCD[1642:11279240] 执行了2:&lt;NSThread: 0x6000018918c0&gt;{number = 1, name = main}2018-08-02 19:20:51.029108+0800 GCD[1642:11279240] 执行了3:&lt;NSThread: 0x6000018918c0&gt;{number = 1, name = main}2018-08-02 19:20:51.029208+0800 GCD[1642:11279240] end。。。</code></pre><blockquote><p>虽然我们使用了并发队列，但是由于我们使用的同步操作，可以看到，系统并没有开启子线程，并且，始终按照代码的顺序进行执行的。</p></blockquote><p>需要注意的是，我们使用dispatch_sync函数时，一定要不要为dispatch_sync指定为Main Queue主队列，否则将会发生死锁：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_get_main_queue();    dispatch_sync(queue, ^{        NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);    });     NSLog(@&quot;end。。。&quot;);</code></pre><blockquote><p>Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</p></blockquote><p>同样的，下面的这种写法，也会造成死锁：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_get_main_queue();    dispatch_async(queue, ^{       dispatch_sync(queue, ^{            NSLog(@&quot;执行了1:%@&quot;,[NSThread currentThread]);        });    });     NSLog(@&quot;end。。。&quot;);</code></pre><h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><p>我们可以使用dispatch_apply来实现在指定线程内多次执行任务：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);    dispatch_apply(5, queue, ^(size_t index) {        NSLog(@&quot;当前线程为：%@---%zu&quot;, [NSThread currentThread],index);    });     NSLog(@&quot;end。。。&quot;);</code></pre><p>打印结果如下：</p><pre><code>2018-08-02 19:35:04.326280+0800 GCD[1849:11288245] start。。。2018-08-02 19:35:04.326591+0800 GCD[1849:11288245] 当前线程为：&lt;NSThread: 0x600000630740&gt;{number = 1, name = main}---02018-08-02 19:35:04.327070+0800 GCD[1849:11288245] 当前线程为：&lt;NSThread: 0x600000630740&gt;{number = 1, name = main}---12018-08-02 19:35:04.327574+0800 GCD[1849:11288378] 当前线程为：&lt;NSThread: 0x600000660080&gt;{number = 3, name = (null)}---32018-08-02 19:35:04.327553+0800 GCD[1849:11288245] 当前线程为：&lt;NSThread: 0x600000630740&gt;{number = 1, name = main}---22018-08-02 19:35:04.327740+0800 GCD[1849:11288378] 当前线程为：&lt;NSThread: 0x600000660080&gt;{number = 3, name = (null)}---42018-08-02 19:35:04.328556+0800 GCD[1849:11288245] end。。。</code></pre><p>我们可以通过这种方式，来模仿系统对NSArray的实现：</p><pre><code>    NSArray *testArray = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;];    [testArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {         NSLog(@&quot;当前元素为：%@---当前下标为%zd&quot;, obj,idx);    }];    //自己模拟实现    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);    dispatch_apply(testArray.count, queue, ^(size_t index) {        NSLog(@&quot;当前元素为：%@&quot;, testArray[index]);    });</code></pre><h4 id="dispatch-suspend和dispatch-resume"><a href="#dispatch-suspend和dispatch-resume" class="headerlink" title="dispatch_suspend和dispatch_resume"></a>dispatch_suspend和dispatch_resume</h4><p>GCD为我们提供了“挂起”、“恢复”队列的功能。但是，需要注意的是，“挂起”的队列是针对尚未执行的block，正在执行的block不会被挂起。</p><p>为了演示这个功能，需要创建一个串行异步队列做演示，然后创建3个耗时任务，每个耗时任务需要时长5s：</p><pre><code>dispatch_queue_t queue;bool flag = 1;- (void)viewDidLoad {    [super viewDidLoad];    [self test];}-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {    if (flag == 1) {        NSLog(@&quot;暂停任务&quot;);        flag = 0;        dispatch_suspend(queue);    } else {        flag = 1;        NSLog(@&quot;继续任务&quot;);         dispatch_resume(queue);    }}- (void)test {    NSLog(@&quot;start&quot;);    queue = dispatch_queue_create(&quot;liuxingxing&quot;, DISPATCH_QUEUE_SERIAL);    dispatch_async(queue, ^{         NSLog(@&quot;我开始执行任务1&quot;);        sleep(5);        NSLog(@&quot;任务1执行完毕&quot;);    });    dispatch_async(queue, ^{        NSLog(@&quot;我开始执行任务2&quot;);        sleep(5);        NSLog(@&quot;任务2执行完毕&quot;);    });    dispatch_async(queue, ^{        NSLog(@&quot;我开始执行任务3&quot;);        sleep(5);        NSLog(@&quot;任务3执行完毕&quot;);    });}</code></pre><p>我们在2s左右切换一下线程的状态，打印结果如下：</p><pre><code>2018-08-03 15:05:30.636230+0800 GCD[20645:11727750] start2018-08-03 15:05:30.636592+0800 GCD[20645:11727858] 我开始执行任务12018-08-03 15:05:32.325692+0800 GCD[20645:11727750] 暂停任务2018-08-03 15:05:35.640567+0800 GCD[20645:11727858] 任务1执行完毕2018-08-03 15:05:44.397150+0800 GCD[20645:11727750] 继续任务2018-08-03 15:05:44.397735+0800 GCD[20645:11727856] 我开始执行任务22018-08-03 15:05:45.991072+0800 GCD[20645:11727750] 暂停任务2018-08-03 15:05:49.402791+0800 GCD[20645:11727856] 任务2执行完毕2018-08-03 15:05:53.625076+0800 GCD[20645:11727750] 继续任务2018-08-03 15:05:53.625362+0800 GCD[20645:11727856] 我开始执行任务32018-08-03 15:05:54.609694+0800 GCD[20645:11727750] 暂停任务2018-08-03 15:05:58.629619+0800 GCD[20645:11727856] 任务3执行完毕</code></pre><blockquote><p>通过打印结果可以验证，我们暂停任务时，正在执行的任务并不会暂停，而是会执行完毕，被“挂起”的任务是没有被执行的任务。而恢复，则使这些被挂起的任务继续执行。</p></blockquote><h4 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h4><p>GCD为我们提供了信号量机制，让我们可以进行更加细度的控制。信号量机制主要涉及到下面三个函数：</p><pre><code>dispatch_semaphore_create(long value); // 创建信号量dispatch_semaphore_signal(dispatch_semaphore_t deem); // 发送信号量dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); // 等待信号量</code></pre><p><code>dispatch_semaphore_create</code>用来创建信号量。value表示可以设置信号量的资源数。0表示没有资源，调用<code>dispatch_semaphore_wait</code>会立即等待。我们也可以把这个value当做并发总数量，dispatch_semaphore_wait会使信号量的资源数减去1，可以理解为value - 1 ；dispatch_semaphore_signal发送信号量，可以理解为添加信号量，也就是value + 1。</p><h5 id="使用场景1-解决死亡回调"><a href="#使用场景1-解决死亡回调" class="headerlink" title="使用场景1:解决死亡回调"></a>使用场景1:解决死亡回调</h5><p>假设我们有3个网络接口ABC，B接口依赖A，C依赖B，如果我们要实现这个功能，最简单粗暴的办法就是：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    dispatch_async(queue, ^{ //模拟网络请求1        NSLog(@&quot;我开始执行任务1&quot;);        sleep(5);        NSLog(@&quot;任务1执行完毕&quot;);        //模拟1成功的回调        dispatch_async(queue, ^{ //模拟网络请求2            NSLog(@&quot;我开始执行任务2&quot;);            sleep(5);            NSLog(@&quot;任务2执行完毕&quot;);            //模拟2成功的回调            dispatch_async(queue, ^{  //模拟网络请求3                NSLog(@&quot;我开始执行任务3&quot;);                sleep(5);                NSLog(@&quot;任务3执行完毕&quot;);            });        });    });    NSLog(@&quot;end。。。&quot;);</code></pre><p>打印结果如下：</p><pre><code>2018-08-03 19:28:55.177312+0800 GCD[31913:11879778] start。。。2018-08-03 19:28:55.177565+0800 GCD[31913:11879778] end。。。2018-08-03 19:28:55.177603+0800 GCD[31913:11879878] 我开始执行任务12018-08-03 19:29:00.178352+0800 GCD[31913:11879878] 任务1执行完毕2018-08-03 19:29:00.178604+0800 GCD[31913:11879878] 我开始执行任务22018-08-03 19:29:05.182333+0800 GCD[31913:11879878] 任务2执行完毕2018-08-03 19:29:05.182579+0800 GCD[31913:11879878] 我开始执行任务32018-08-03 19:29:10.186252+0800 GCD[31913:11879878] 任务3执行完毕</code></pre><blockquote><p>也就是，我们在网络成功的回调中，再次嵌套网络回调。如果多个网络请求相互依赖，就会陷入死亡回调。</p></blockquote><p>我们可以使用GCD提供的信号量机制，相对优雅的解决这个问题：</p><pre><code>    NSLog(@&quot;start。。。&quot;);    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); //    dispatch_async(queue, ^{ //模拟网络请求1        NSLog(@&quot;我开始执行任务1&quot;);        sleep(5);        NSLog(@&quot;任务1执行完毕&quot;);        //模拟1成功的回调        // 发送信号量         dispatch_semaphore_signal(semaphore);    });    dispatch_async(queue, ^{ //模拟网络请求1        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);        NSLog(@&quot;我开始执行任务2&quot;);        sleep(5);        NSLog(@&quot;任务2执行完毕&quot;);        //模拟2成功的回调        // 发送信号量         dispatch_semaphore_signal(semaphore);    });    dispatch_async(queue, ^{ //模拟网络请求1        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);        NSLog(@&quot;我开始执行任务3&quot;);        sleep(5);        NSLog(@&quot;任务3执行完毕&quot;);    });    NSLog(@&quot;end。。。&quot;);</code></pre><p>打印结果如下：</p><pre><code>2018-08-03 19:34:32.836136+0800 GCD[32019:11883248] start。。。2018-08-03 19:34:32.836377+0800 GCD[32019:11883248] end。。。2018-08-03 19:34:32.836391+0800 GCD[32019:11883361] 我开始执行任务12018-08-03 19:34:37.841238+0800 GCD[32019:11883361] 任务1执行完毕2018-08-03 19:34:37.841505+0800 GCD[32019:11883362] 我开始执行任务22018-08-03 19:34:42.845288+0800 GCD[32019:11883362] 任务2执行完毕2018-08-03 19:34:42.845526+0800 GCD[32019:11883360] 我开始执行任务32018-08-03 19:34:47.848411+0800 GCD[32019:11883360] 任务3执行完毕</code></pre><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>dispatch_once函数可以保证在应用程序执行中只执行一次处理。我们最可能想到的是单例：</p><pre><code>    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{    });</code></pre><p>AFNetworking中使用dispatch_once函数：</p><pre><code>+ (instancetype)sharedManager {    static AFNetworkReachabilityManager *_sharedManager = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        _sharedManager = [self manager];    });    return _sharedManager;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结提高 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的数组常用操作</title>
      <link href="/2018/07/30/2018-07-30-javascript-shu-zu-de-chang-yong-cao-zuo/"/>
      <url>/2018/07/30/2018-07-30-javascript-shu-zu-de-chang-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="for-in-遍历数组（不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象）"><a href="#for-in-遍历数组（不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象）" class="headerlink" title="for in 遍历数组（不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象）"></a>for in 遍历数组（不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象）</h3><pre><code>var a = [1, 2, 3];a.foo = true;for (var key in a) {console.log(key);}// 0// 1// 2// foo</code></pre><blockquote><p>上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for…in遍历数组</p></blockquote><h3 id="使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性"><a href="#使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性" class="headerlink" title="使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性"></a>使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性</h3><pre><code>var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3</code></pre><h3 id="“类似数组的对象”的操作"><a href="#“类似数组的对象”的操作" class="headerlink" title="“类似数组的对象”的操作"></a>“类似数组的对象”的操作</h3><pre><code>var obj = {//自定义类数组对象0: &#39;a&#39;,1: &#39;b&#39;,2: &#39;c&#39;,length: 3};let isArray = obj instanceof Array;console.log(isArray); //false//方式1转换为数组var arr1 = Array.prototype.slice.call(obj);isArray = arr1 instanceof Array;console.log(isArray); //true//使用call()把数组的方法放到对象上Array.prototype.forEach.call(obj,print);function print(value, index) {console.log(index + &#39; : &#39; + value);}Array.prototype.forEach.call(obj,(value, index) =&gt; {console.log(index + &#39; =&gt; &#39; + value);});</code></pre><hr><h3 id="1-Array-isArray"><a href="#1-Array-isArray" class="headerlink" title="1.Array.isArray()"></a>1.Array.isArray()</h3><pre><code>var arr = [1, 2, 3];typeof arr // &quot;object&quot;Array.isArray(arr) // true</code></pre><h3 id="2-push-，pop-（会改变原数组）"><a href="#2-push-，pop-（会改变原数组）" class="headerlink" title="2.push()，pop() （会改变原数组）"></a>2.push()，pop() （会改变原数组）</h3><pre><code>var arr = [];arr.push(1) // 1arr.push(&#39;a&#39;) // 2arr.push(true, {}) // 4arr // [1, &#39;a&#39;, true, {}]</code></pre><h3 id="3-shift-，unshift-（会改变原数组）"><a href="#3-shift-，unshift-（会改变原数组）" class="headerlink" title="3.shift()，unshift()（会改变原数组）"></a>3.shift()，unshift()（会改变原数组）</h3><ul><li>shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组</li><li>shift()方法可以遍历并清空一个数组</li></ul><pre><code>var list = [1, 2, 3, 4];var item;while (item = list.shift()) {console.log(item);}list // []</code></pre><blockquote><p>上面代码通过list.shift()方法每次取出一个元素，从而遍历数组。它的前提是数组元素不能是0或任何布尔值等于false的元素，因此这样的遍历不是很可靠。</p></blockquote><ul><li>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</li></ul><pre><code>var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.unshift(&#39;x&#39;); // 4a // [&#39;x&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]var arr = [ &#39;c&#39;, &#39;d&#39; ];arr.unshift(&#39;a&#39;, &#39;b&#39;) // 4arr // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]</code></pre><h3 id="4-join"><a href="#4-join" class="headerlink" title="4.join()"></a>4.join()</h3><ul><li>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</li></ul><pre><code>var a = [1, 2, 3, 4];a.join(&#39; &#39;) // &#39;1 2 3 4&#39;a.join(&#39; | &#39;) // &quot;1 | 2 | 3 | 4&quot;a.join() // &quot;1,2,3,4&quot;</code></pre><ul><li>通过call方法，这个方法也可以用于字符串或类似数组的对象。</li></ul><pre><code>Array.prototype.join.call(&#39;hello&#39;, &#39;-&#39;)// &quot;h-e-l-l-o&quot;var obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, length: 2 };Array.prototype.join.call(obj, &#39;-&#39;)// &#39;a-b&#39;</code></pre><h3 id="5-concat"><a href="#5-concat" class="headerlink" title="5.concat()"></a>5.concat()</h3><ul><li>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</li></ul><pre><code>[&#39;hello&#39;].concat([&#39;world&#39;])// [&quot;hello&quot;, &quot;world&quot;][&#39;hello&#39;].concat([&#39;world&#39;], [&#39;!&#39;])// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;][].concat({a: 1}, {b: 2})// [{ a: 1 }, { b: 2 }][2].concat({a: 1})// [2, {a: 1}][1, 2, 3].concat(4, 5, 6)// [1, 2, 3, 4, 5, 6]</code></pre><ul><li>如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</li></ul><pre><code>var obj = { a: 1 };var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2</code></pre><h3 id="6-reverse-改变原数组"><a href="#6-reverse-改变原数组" class="headerlink" title="6.reverse() (改变原数组)"></a>6.reverse() (改变原数组)</h3><pre><code>var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</code></pre><h3 id="7-slice"><a href="#7-slice" class="headerlink" title="7.slice()"></a>7.slice()</h3><ul><li>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 </li></ul><pre><code>arr.slice(start, end);</code></pre><blockquote><p>它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p></blockquote><pre><code>var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]a.slice(1) // [&quot;b&quot;, &quot;c&quot;]a.slice(1, 2) // [&quot;b&quot;]a.slice(2, 6) // [&quot;c&quot;]a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><blockquote><p>上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。</p></blockquote><ul><li>如果slice方法的参数是负数，则表示倒数计算的位置。</li></ul><pre><code>var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]a.slice(-2, -1) // [&quot;b&quot;]</code></pre><ul><li>slice方法的一个重要应用，是将类似数组的对象转为真正的数组.</li></ul><pre><code>Array.prototype.slice.call({ 0: &#39;a&#39;, 1: &#39;b&#39;, length: 2 })// [&#39;a&#39;, &#39;b&#39;]Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));Array.prototype.slice.call(arguments);</code></pre><h3 id="8-splice-改变原数组"><a href="#8-splice-改变原数组" class="headerlink" title="8.splice() (改变原数组)"></a>8.splice() (改变原数组)</h3><ul><li>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</li></ul><pre><code>arr.splice(start, count, addElement1, addElement2, ...);</code></pre><ul><li>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</li></ul><pre><code>var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];a.splice(4, 2, 1, 2) // [&quot;e&quot;, &quot;f&quot;]a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];a.splice(-4, 2) // [&quot;c&quot;, &quot;d&quot;]</code></pre><ul><li>如果只是单纯地插入元素，splice方法的第二个参数可以设为0。</li></ul><pre><code>var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1]</code></pre><ul><li>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</li></ul><pre><code>var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2]</code></pre><h3 id="9-sort"><a href="#9-sort" class="headerlink" title="9.sort()"></a>9.sort()</h3><pre><code>[10111, 1101, 111].sort(function (a, b) {return a - b;})// [111, 1101, 10111]</code></pre><blockquote><p>上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p></blockquote><pre><code>[{ name: &quot;张三&quot;, age: 30 },{ name: &quot;李四&quot;, age: 24 },{ name: &quot;王五&quot;, age: 28  }].sort(function (o1, o2) {return o1.age - o2.age;})// [//   { name: &quot;李四&quot;, age: 24 },//   { name: &quot;王五&quot;, age: 28  },//   { name: &quot;张三&quot;, age: 30 }// ]</code></pre><h3 id="10-map"><a href="#10-map" class="headerlink" title="10.map()"></a>10.map()</h3><ul><li>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</li></ul><pre><code>var numbers = [1, 2, 3];numbers.map(function (n) {return n + 1;});// [2, 3, 4]numbers// [1, 2, 3]</code></pre><ul><li>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。</li></ul><pre><code>[1, 2, 3].map(function(elem, index, arr) {return elem * index;});// [0, 2, 6]</code></pre><ul><li>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量。</li></ul><pre><code>var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];[1, 2].map(function (e) {return this[e];}, arr)// [&#39;b&#39;, &#39;c&#39;]</code></pre><ul><li>如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。</li></ul><pre><code>var f = function (n) { return &#39;a&#39; };[1, undefined, 2].map(f) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;][1, null, 2].map(f) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;][1, , 2].map(f) // [&quot;a&quot;, , &quot;a&quot;]</code></pre><h3 id="11-forEach"><a href="#11-forEach" class="headerlink" title="11.forEach()"></a>11.forEach()</h3><ul><li>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法</li><li>forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</li></ul><pre><code>function log(element, index, array) {console.log(&#39;[&#39; + index + &#39;] = &#39; + element);}[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9</code></pre><ul><li>forEach方法也可以接受第二个参数，绑定参数函数的this变量。</li></ul><pre><code>var out = [];[1, 2, 3].forEach(function(elem) {this.push(elem * elem);}, out);out // [1, 4, 9]</code></pre><blockquote><p>上面代码中，空数组out是forEach方法的第二个参数，结果，回调函数内部的this关键字就指向out。<br>注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。</p></blockquote><pre><code>var log = function (n) {console.log(n + 1);};[1, undefined, 2].forEach(log)// 2// NaN// 3[1, null, 2].forEach(log)// 2// 1// 3[1, , 2].forEach(log)// 2// 3</code></pre><blockquote><p>上面代码中，forEach方法不会跳过undefined和null，但会跳过空位。</p></blockquote><h3 id="12-filter"><a href="#12-filter" class="headerlink" title="12.filter()"></a>12.filter()</h3><ul><li>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</li></ul><pre><code>[1, 2, 3, 4, 5].filter(function (elem) {return (elem &gt; 3);})// [4, 5]</code></pre><pre><code>var arr = [0, 1, &#39;a&#39;, false];arr.filter(Boolean)// [1, &quot;a&quot;]</code></pre><blockquote><p>上面代码中，filter方法返回数组arr里面所有布尔值为true的成员</p></blockquote><ul><li>filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组:</li></ul><pre><code>[1, 2, 3, 4, 5].filter(function (elem, index, arr) {return index % 2 === 0;});// [1, 3, 5]</code></pre><ul><li>filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</li></ul><pre><code>var obj = { MAX: 3 };var myFilter = function (item) {if (item &gt; this.MAX) return true;};var arr = [2, 8, 3, 4, 1, 3, 2, 9];arr.filter(myFilter, obj) // [8, 4, 9]</code></pre><blockquote><p>上面代码中，过滤器myFilter内部有this变量，它可以被filter方法的第二个参数obj绑定，返回大于3的成员。</p></blockquote><h3 id="13-some-，every"><a href="#13-some-，every" class="headerlink" title="13.some()，every()"></a>13.some()，every()</h3><ul><li><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p></li><li><p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p></li><li><p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false</p></li></ul><pre><code>var arr = [1, 2, 3, 4, 5];arr.some(function (elem, index, arr) {return elem &gt;= 3;});// true</code></pre><blockquote><p>上面代码中，如果数组arr有一个成员大于等于3，some方法就返回true。</p></blockquote><ul><li>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false</li></ul><pre><code>var arr = [1, 2, 3, 4, 5];arr.every(function (elem, index, arr) {return elem &gt;= 3;});// false</code></pre><blockquote><p>上面代码中，数组arr并非所有成员大于等于3，所以返回false</p></blockquote><ul><li>注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。</li></ul><pre><code>function isEven(x) { return x % 2 === 0 }[].some(isEven) // false[].every(isEven) // true</code></pre><ul><li>some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量</li></ul><h3 id="14-reduce-，reduceRight"><a href="#14-reduce-，reduceRight" class="headerlink" title="14.reduce()，reduceRight()"></a>14.reduce()，reduceRight()</h3><ul><li>reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</li></ul><pre><code>[1, 2, 3, 4, 5].reduce(function (a, b) {console.log(a, b);return a + b;})// 1 2// 3 3// 6 4// 10 5//最后结果：15</code></pre><blockquote><p>上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。</p></blockquote><ol><li>reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。</li><li>累积变量，默认为数组的第一个成员</li><li>当前变量，默认为数组的第二个成员</li><li>当前位置（从0开始）</li><li>原数组</li></ol><ul><li>这四个参数之中，只有前两个是必须的，后两个则是可选的。</li><li>如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。</li></ul><pre><code>[1, 2, 3, 4, 5].reduce(function (a, b) {return a + b;}, 10);// 25</code></pre><pre><code>function add(prev, cur) {return prev + cur;}[].reduce(add)// TypeError: Reduce of empty array with no initial value[].reduce(add, 1)// 1</code></pre><blockquote><p>上面代码指定参数a的初值为10，所以数组从10开始累加，最终结果为25。注意，这时b是从数组的第一个成员开始遍历。上面的第二个参数相当于设定了默认值，处理空数组时尤其有用。</p></blockquote><ul><li>下面是一个reduceRight方法的例子:</li></ul><pre><code>function subtract(prev, cur) {return prev - cur;}[3, 2, 1].reduce(subtract) // 0[3, 2, 1].reduceRight(subtract) // -4</code></pre><blockquote><p>上面代码中，reduce方法相当于3减去2再减去1，reduceRight方法相当于1减去2再减去3。</p></blockquote><ul><li>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。</li></ul><pre><code>function findLongest(entries) {return entries.reduce(function (longest, entry) {return entry.length &gt; longest.length ? entry : longest;}, &#39;&#39;);}findLongest([&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;]) // &quot;aaa&quot;</code></pre><h3 id="15-indexOf-，lastIndexOf"><a href="#15-indexOf-，lastIndexOf" class="headerlink" title="15.indexOf()，lastIndexOf()"></a>15.indexOf()，lastIndexOf()</h3><ul><li>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1</li></ul><pre><code>var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];a.indexOf(&#39;b&#39;) // 1a.indexOf(&#39;y&#39;) // -1</code></pre><ul><li>indexOf方法还可以接受第二个参数，表示搜索的开始位置</li></ul><pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].indexOf(&#39;a&#39;, 1) // -1</code></pre><blockquote><p>上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。</p></blockquote><ul><li>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</li></ul><pre><code>var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1</code></pre><ul><li>注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN</li></ul><pre><code>[NaN].indexOf(NaN) // -1[NaN].lastIndexOf(NaN) // -1</code></pre><blockquote><p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</p></blockquote><hr><h3 id="16-链式使用"><a href="#16-链式使用" class="headerlink" title="16. 链式使用"></a>16. 链式使用</h3><pre><code>var users = [{name: &#39;tom&#39;, email: &#39;tom@example.com&#39;},{name: &#39;peter&#39;, email: &#39;peter@example.com&#39;}];users.map(function (user) {return user.email;}).filter(function (email) {return /^t/.test(email);}).forEach(function (email) {console.log(email);});// &quot;tom@example.com&quot;</code></pre><blockquote><p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以t开头的 Email 地址，最后将它打印出来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES5 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript总结提高.md</title>
      <link href="/2018/04/28/2018-04-28-javascript-zong-jie-ti-gao/"/>
      <url>/2018/04/28/2018-04-28-javascript-zong-jie-ti-gao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><blockquote><p>数据类型分为基本数据类型和对象类型；变量的值类型分为基本类型（保存的基本类型的数据）和引用类型（保存的是地址值 array、 function、object ）。</p></blockquote><p>对于undefined和null的判断：</p><pre><code>            let a;            if (a === undefined ||  typeof a === &#39;undefined&#39;) {                console.log(&#39;a没有定义&#39;)            }            let b = null;            if (b === null) {                //typeof b的值为 &#39;null&#39;                console.log(&#39;b为null&#39;)            }</code></pre><p>对于数组的判断：</p><pre><code>if (c instanceof Array) {                console.log(typeof c);// object                console.log( &#39;c是一个数组&#39;);    }</code></pre><blockquote><p>undefined有2种判断方式。null和array的typeof都是object，所以需要特殊判断。</p></blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上:</p><pre><code>function Car(make, model, year) {  this.make = make;  this.model = model;  this.year = year;}var auto = new Car(&#39;Honda&#39;, &#39;Accord&#39;, 1998);console.log(auto instanceof Car);//trueconsole.log(auto instanceof Object);//true</code></pre><h3 id="全局执行上下文与函数执行上下文"><a href="#全局执行上下文与函数执行上下文" class="headerlink" title="全局执行上下文与函数执行上下文"></a>全局执行上下文与函数执行上下文</h3><h4 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h4><p>在执行全局代码前，首先将window确定为全局执行上下文，然后，对全局数据进行预处理：①将var定义的全局变量初始化为undefined，然后添加为window的属性；②将function声明的全局函数添加为window的方法；③将this赋值给window。最后，开始执行全局代码。</p><h4 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h4><p>在调用函数准备执行函数体前,创建对应的函数执行上下文对象,然后对局部数据进行预处理:将函数定义的形参赋值给函数体内的实参,并添加为执行上下文的属性;将arguments添加为执行上下文属性;将var定义的局部变量初始化为undefined并添加为执行上下文属性;将函数体内声明的function函数赋值给fun并添加为执行上下文方法;将this赋值给调用该函数的对象; 最后开始执行函数整体代码.</p><p>执行上下文举例:</p><pre><code>&lt;script&gt;    console.log(&#39;begin&#39; + i)    var i = 1    test(1)    function test(i) {        if (i == 4) {            return        }        console.log(&#39;test-begin:&#39; + i)        test(i + 1)        console.log(&#39;test-end:&#39; + i)    }    console.log(&#39;end&#39; + i)&lt;/script&gt;</code></pre><pre><code>begin: undefinedtest-begin: 1test-begin: 2test-begin: 3test-end: 3test-end: 2test-end: 1end: 1</code></pre><p>变量提升与函数提升举例:</p><pre><code>    function test() {    }    var test    console.log(typeof test) //function</code></pre><blockquote><p>由打印结果可知,先执行变量提升,后执行函数提升</p></blockquote><p>var作用域举例:</p><pre><code>    if (!(b in window)) {        var b = 234    }    console.log(b) //undefined</code></pre><p>易错举例:</p><pre><code>        var c = 1    function c(c) {        console.log(c)        var c = 3    }    c(2) //Uncaught TypeError: c is not a function</code></pre><blockquote><p>这个还是变量提升与函数提升的问题.代码先执行变量提升 var c = undefined, 再执行函数提升,然后赋值c = 1,此时c是一个基本数据类型,再执行c(2))时,当然会报错.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 总结提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的BOM使用总结</title>
      <link href="/2018/04/24/2018-04-24-javascript-zhong-de-bom-shi-yong-zong-jie/"/>
      <url>/2018/04/24/2018-04-24-javascript-zhong-de-bom-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><blockquote><p>BOM(浏览器对象模型):BOM将浏览器的各个功能特性转换成对象，进而使我们通过JavaScript来访问和操作浏览器，控制浏览器的行为。 </p></blockquote><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>window对象是BOM的核心，它表示一个浏览器的实例 ，代表的是整个浏览器窗口。在浏览器中我们可以通过window对象来访问操作浏览器，同时window也是作为全局对象存在的。 因此所有在全局作用 域中声明的变量、对象、函数都会变成window对象的属性 和方法。 </p><h5 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h5><p>使用setInterval来每隔一段时间执行指定代码 :</p><pre><code>                //每隔1s执行一次                var num = 1;                var count = document.getElementById(&quot;count&quot;);                var timer = setInterval(function(){                    count.innerHTML = num++;                    if(num == 11){                        //关闭定时器                        clearInterval(timer);                    }                },1000);</code></pre><h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h5><p>使用setTimeout延时调用： </p><pre><code>var timer = setTimeout(function(){                console.log(num++);            },3000);            //使用clearTimeout()来关闭一个延时调用            clearTimeout(timer);</code></pre><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p>navigator对象包含了浏览器的版本、浏览器所支持的插件、浏览器所使用的语言等各种与浏览器相关的信息。通过该对象可以识别不同的浏览器，我们有时会使用navigator的userAgent属性来检查用户浏览器的版本。</p><pre><code>        console.log(navigator.appName);//Netscape    console.log(navigator.userAgent);//通过该属性判断浏览器        //在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了    //如果navigator.userAgent不能判断，那么我们可以通过一些浏览器特有对象来判断if(/firefox/i.test(ua)){                alert(&quot;你是火狐！！！&quot;);            }else if(/chrome/i.test(ua)){                alert(&quot;你是Chrome&quot;);            }else if(/msie/i.test(ua)){                alert(&quot;你是IE浏览器~~~&quot;);            }else if(&quot;ActiveXObject&quot; in window){                alert(&quot;你是IE11&quot;);            }</code></pre><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 对象保存着用户上网的历史记录， 从窗口被打开的那一刻算起。我们可以通过操作该对象来操作浏览器的历史记录。但是由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或者向后翻页（该操作只在当次访问有效）。</p><pre><code>history.length  //属性，可以获取到当成访问的链接数量history.back()  //可以用来回退到上一个页面，作用和浏览器的回退按钮一样history.forward() //可以用来回退到上一个页面，作用和浏览器的回退按钮一样                    /*                     * go()                     *     - 可以用来跳转到指定的页面                     *     - 它需要一个整数作为参数                     *         1:表示向前跳转一个页面 相当于forward()                     *         2:表示向前跳转两个页面                     *         -1:表示向后跳转一个页面                     *         -2:表示向后跳转两个页面                     */                    history.go(-2);</code></pre><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>location对象提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。 </p><pre><code>                    //如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）                    alert(location);                     // 如果直接将location属性修改为一个完整的路径，或相对路径                     //则我们页面会自动跳转到该路径，并且会生成相应的历史记录                    location = &quot;http://www.baidu.com&quot;;                    location = &quot;test.html&quot;;                    //assign()用来跳转到其他的页面，作用和直接修改location一样                    location.assign(&quot;http://www.baidu.com&quot;);                    //reload()用于重新加载当前页面，作用和刷新按钮一样.                    //如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面                    location.reload(true);                //replace()可以使用一个新的页面替换当前页面，调用完毕也会跳转页面.                //不会生成历史记录，不能使用回退按钮回退                location.replace(&quot;test.html&quot;);</code></pre><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>screen对象代表用户的屏幕信息，如像素宽度和高度等。  </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的DOM操作总结</title>
      <link href="/2018/04/07/2018-04-07-javascript-zhong-de-dom-shi-yong-zong-jie/"/>
      <url>/2018/04/07/2018-04-07-javascript-zhong-de-dom-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><blockquote><p> DOM: document object model文档对象模型。</p></blockquote><h3 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h3><p>其中，querySelector可以根据一个css选择器获取一个节点对象，所以很强大和灵活，需要重点掌握。</p><pre><code>getElementById         通过id获取一个元素getElementsByTagName   通过标签名获取一组元素getElementsByName      通过name属性获取一组元素getElementsByTagName   获取当前节点的指定标签名后代节点getElementsByClassName 通过class获取一组元素（IE8以上）childNodes（属性）       获取当前节点的所有子节点（会把标签与标签之间的空白当成文本节点）children(属性)          获取当前节点下的所有子元素firstChild（属性）       获取当前节点的第一个子节点firstElementChild(属性) 获取当前节点的第一个子元素（IE9以上）lastChild（属性）        获取当前节点的最后一个子节点lastElementChildparentNode              父节点(不获取空白文本)parentElementpreviousSibling         前一个兄弟节点previousElementSiblingnextSibling             后一个兄弟节点nextElementSiblingdocument.body  获取bodydocument.documentElement 获取html根标签document.all 获取页面的所有元素//注意：如果有多个元素满足css选择器，那么只会返回一个节点对象,所以可以使用querySelectorAll来代替。document.querySelector(&#39;#city li&#39;) 根据一个css选择器获取一个节点对象（很强大和灵活）</code></pre><p>例子如下：</p><pre class=" language-"><code class="language-"><ul id="city">    <li>北京</li>    <li>上海</li>    <li>广州</li>    <li id="select">深圳</li></ul>        let city = document.getElementById('city')        let list = city.getElementsByTagName('li')        console.log(list);        console.log(Array.isArray(list));//false        for (let i = 0; i < list.length; i++) {            console.log(list[i].innerHTML);        }        let child = city.childNodes        //注意：childNodes会把标签与标签之间的空白也当成文本节点        console.log(child); //NodeList(9) [text, li, text, li, text, li, text, li, text]        let child2 = city.children        //注意：childNodes会把标签与标签之间的空白也当成文本节点        console.log(child2); //HTMLCollection(4) [li, li, li, li]        let sel = document.getElementById('select')        let parent = sel.parentNode        console.log(parent.innerHTML);        // <li>北京</li>        // <li>上海</li>        // <li>广州</li>        // <li id="select">深圳</li>        console.log(parent.innerText);        // 北京        // 上海        // 广州        // 深圳        //获取第一个子节点的文本内容        let value = sel.firstChild.nodeValue        console.log(value);</code></pre><h5 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h5><pre><code>innerHTML    用于获取元素内部的文本，例如&lt;button&gt;登录&lt;/button&gt;。无法获取自结束标签。&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;/&gt;  let inputs = document.getElementsByName(&#39;gender&#39;);  //注意：返回的是类数组对象，而不是数组。  console.log(Array.isArray(inputs));//false  inputs.forEach(input =&gt; {     console.log(input.value);   })</code></pre><h5 id="按钮的获取与事件处理"><a href="#按钮的获取与事件处理" class="headerlink" title="按钮的获取与事件处理"></a>按钮的获取与事件处理</h5><pre><code>        &lt;button id=&quot;btn&quot; onclick=&quot;btnClick()&quot;&gt;登录&lt;/button&gt;        let button = document.getElementById(&#39;btn&#39;);    button.innerHTML = &#39;我是个按钮&#39;;    function btnClick() {        console.log(&#39;------&#39;)    }     button.ondblclick = () =&gt; {        console.log(&#39;我被双击了&#39;)    }</code></pre><h5 id="监听window加载完成"><a href="#监听window加载完成" class="headerlink" title="监听window加载完成"></a>监听window加载完成</h5><pre><code>    window.onload = function() {        let button = document.getElementById(&#39;btn&#39;);        button.innerHTML = &#39;我是个按钮&#39;;        button.ondblclick = () =&gt; {            console.log(&#39;我被双击了&#39;)        }    }    function btnClick() {        console.log(&#39;------&#39;)    }</code></pre><h5 id="箭头函数绑定事件与函数表达式的区别"><a href="#箭头函数绑定事件与函数表达式的区别" class="headerlink" title="箭头函数绑定事件与函数表达式的区别"></a>箭头函数绑定事件与函数表达式的区别</h5><pre><code>        let button = document.getElementById(&#39;btn&#39;);        button.innerHTML = &#39;我是个按钮&#39;;        button.ondblclick = () =&gt; {            console.log(&#39;我被双击了&#39;)            console.log(this === button) //false        }        button.ondblclick = function () {            console.log(&#39;我被双击了&#39;)            //在使用函数表达式这种方式绑定时，响应函数是给谁绑定的，this就指向谁            console.log(this === button) //true        }</code></pre><h3 id="DOM“元素”的增删改"><a href="#DOM“元素”的增删改" class="headerlink" title="DOM“元素”的增删改"></a>DOM“元素”的增删改</h3><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>向ul添加一个新的li（只添加新加的）：</p><pre><code>&lt;ul id=&quot;city&quot;&gt;    &lt;li&gt;北京&lt;/li&gt;    &lt;li&gt;上海&lt;/li&gt;    &lt;li&gt;广州&lt;/li&gt;    &lt;li id=&quot;select&quot;&gt;深圳&lt;/li&gt;&lt;/ul&gt;        let city =document.getElementById(&#39;city&#39;)        let newLi = document.createElement(&#39;li&#39;)        let text = document.createTextNode(&#39;河南&#39;)         newLi.appendChild(text)        city.appendChild(newLi)</code></pre><p>另一种添加li的方式（这种方式等于是将之前的给删了，然后重新创建以前的和新加的）：</p><pre><code>        let city =document.getElementById(&#39;city&#39;)        city.innerHTML += &#39;&lt;li&gt;郑州&lt;/li&gt;&#39;</code></pre><p>折中的方式(推荐)：</p><pre><code>                let city =document.getElementById(&#39;city&#39;)        let newLi = document.createElement(&#39;li&#39;)        // let text = document.createTextNode(&#39;河南&#39;)        // newLi.appendChild(text)        newLi.innerText = &#39;郑州&#39;        city.appendChild(newLi)</code></pre><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入到深圳之前：</p><pre><code>        let city =document.getElementById(&#39;city&#39;)        let newLi = document.createElement(&#39;li&#39;)        let text = document.createTextNode(&#39;河南&#39;)        newLi.appendChild(text)        let sel = document.getElementById(&#39;select&#39;)        city.insertBefore(newLi, sel)</code></pre><h5 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h5><p>替换深圳：</p><pre><code>        let city =document.getElementById(&#39;city&#39;)        let newLi = document.createElement(&#39;li&#39;)        let text = document.createTextNode(&#39;河南&#39;)        newLi.appendChild(text)        let sel = document.getElementById(&#39;select&#39;)        city.replaceChild(newLi, sel)</code></pre><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除深圳：</p><pre><code>        let city =document.getElementById(&#39;city&#39;)        let sel = document.getElementById(&#39;select&#39;)        //city.removeChild(sel)        //这种方式更简单方便：        sel.parentNode.removeChild(sel)</code></pre><h5 id="综合小案例"><a href="#综合小案例" class="headerlink" title="综合小案例"></a>综合小案例</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;DOM操作实例&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    ul {        list-style-type: none;    }    li {        border-style: solid;        border-width: 1px;        padding: 5px;        margin: 5px;        background-color: #99ff99;        float: left;    }    #employeeTable {        border-spacing: 1px;        background-color: black;        margin: 80px auto 10px auto;    }    th,td {        background-color: white;    }    #formDiv {        width: 250px;        border-style: solid;        border-width: 1px;        margin: 50px auto 10px auto;        padding: 10px;    }    #formDiv input {        width: 100%;    }    .word {        width: 40px;    }    .inp {        width: 200px;    }&lt;/style&gt;&lt;body&gt;&lt;table id=&quot;employeeTable&quot;&gt;    &lt;tr&gt;        &lt;th&gt;Name&lt;/th&gt;        &lt;th&gt;Email&lt;/th&gt;        &lt;th&gt;Age&lt;/th&gt;        &lt;th&gt;&amp;nbsp;&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Tom&lt;/td&gt;        &lt;td&gt;tom@tom.com&lt;/td&gt;        &lt;td&gt;5000&lt;/td&gt;        &lt;td&gt;            &lt;a href=&quot;javascript:;&quot;&gt;Delete&lt;/a&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Tom&lt;/td&gt;        &lt;td&gt;tom@tom.com&lt;/td&gt;        &lt;td&gt;5000&lt;/td&gt;        &lt;td&gt;            &lt;a href=&quot;javascript:;&quot;&gt;Delete&lt;/a&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Tom&lt;/td&gt;        &lt;td&gt;tom@tom.com&lt;/td&gt;        &lt;td&gt;5000&lt;/td&gt;        &lt;td&gt;            &lt;a href=&quot;javascript:;&quot;&gt;Delete&lt;/a&gt;        &lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;div id=&quot;formDiv&quot;&gt;    &lt;h4&gt;添加新员工&lt;/h4&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td class=&quot;word&quot;&gt;name:&lt;/td&gt;            &lt;td class=&quot;inp&quot;&gt;                &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot;/&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td class=&quot;word&quot;&gt;email:&lt;/td&gt;            &lt;td class=&quot;inp&quot;&gt;                &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot;/&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td class=&quot;word&quot;&gt;salary:&lt;/td&gt;            &lt;td class=&quot;inp&quot;&gt;                &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot;/&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;                &lt;button id=&quot;addEmpButton&quot;&gt;                    Submit                &lt;/button&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    window.onload = function () {        let allA = document.getElementsByTagName(&#39;a&#39;)        Array.from(allA).map(item =&gt; item.onclick = deleteOption)        //添加新的员工        let addBtn = document.getElementById(&#39;addEmpButton&#39;)        addBtn.onclick = function () {            let name = document.getElementById(&quot;empName&quot;).value            let email = document.getElementById(&quot;email&quot;).value            let salary = document.getElementById(&quot;salary&quot;).value            //创建一个tr            let tr = document.createElement(&quot;tr&quot;)            //设置tr中的内容            tr.innerHTML = &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+                &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+                &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+                &quot;&lt;td&gt;&lt;a href=&#39;javascript:;&#39;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;            //获取刚刚添加的a元素，并为其绑定单击响应函数            let a = tr.getElementsByTagName(&quot;a&quot;)[0]            a.onclick = deleteOption            //获取table            let employeeTable = document.getElementById(&quot;employeeTable&quot;);            //获取employeeTable中的tbody            let tbody = employeeTable.getElementsByTagName(&quot;tbody&quot;)[0];            //将tr添加到tbodye中            tbody.appendChild(tr);        }    }    function deleteOption() {        //谁调用，this就指向谁        let tr = this.parentNode.parentNode        let name = tr.children[0].innerHTML        let warning = confirm(`确认要删除${name}？？`)        warning &amp;&amp; tr.parentNode.removeChild(tr)        // 点击超链接以后，超链接会跳转页面，这个是超链接的默认行为，        // 但是此时我们不希望出现默认行为，可以通过在响应函数的最后return false来取消默认行为        return false    }&lt;/script&gt;</code></pre><h3 id="DOM“样式”的修改"><a href="#DOM“样式”的修改" class="headerlink" title="DOM“样式”的修改"></a>DOM“样式”的修改</h3><p>语法：   元素.style.样式名称  = 样式值(我们通过此种方式添加的样式为内联样式)：</p><pre><code>        let btn =document.getElementById(&#39;btn&#39;)        btn.style.backgroundColor = &#39;#00F&#39;        btn.style.width = &#39;200px&#39;        btn.style.height = &#39;200px&#39;        btn.style.color = &#39;#F00&#39;</code></pre><h5 id="获取元素设置的样式"><a href="#获取元素设置的样式" class="headerlink" title="获取元素设置的样式"></a>获取元素设置的样式</h5><p>注意：btn.style只能获取设置的内联样式，显式样式获取不到：</p><pre><code>        //btn.style只能获取设置的内联样式，显式样式获取不到        console.log(btn.style.color);//        console.log(btn.style.width);        console.log(btn.style.border);//获取不到</code></pre><h5 id="通过window-getComputedStyle方式获取元素设置的所有生效的样式"><a href="#通过window-getComputedStyle方式获取元素设置的所有生效的样式" class="headerlink" title="通过window.getComputedStyle方式获取元素设置的所有生效的样式"></a>通过window.getComputedStyle方式获取元素设置的所有生效的样式</h5><pre><code>  console.log(window.getComputedStyle(btn).border);//5px solid rgb(0, 128, 0)</code></pre><blockquote><p>注意：btn.style和window.getComputedStyle都是只读属性，不能通过此方式更改样式值。</p></blockquote><h4 id="获取其他样式的属性"><a href="#获取其他样式的属性" class="headerlink" title="获取其他样式的属性"></a>获取其他样式的属性</h4><h5 id="使用clientHeight和clientWidth获取元素的内部宽度和高度"><a href="#使用clientHeight和clientWidth获取元素的内部宽度和高度" class="headerlink" title="使用clientHeight和clientWidth获取元素的内部宽度和高度"></a>使用clientHeight和clientWidth获取元素的内部宽度和高度</h5><p>clientHeight和clientWidth属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。</p><pre><code>clientHeight    clientWidth 获取元素的宽高&lt;button  id=&quot;btn&quot; onclick=&quot;btnClick()&quot;&gt;登录&lt;/button&gt;&lt;div  id=&quot;div&quot;&gt;我是个div&lt;/div&gt;&lt;style&gt;    #btn {        border: 5px solid green;        width: 200px;        height: 200px;    }    #div {        border: 5px solid blue;        width: 200px;        height: 200px;    }&lt;/style&gt;        let btn =document.getElementById(&#39;btn&#39;)        let div = document.getElementById(&#39;div&#39;)        console.log(btn.clientHeight);//190        console.log(btn.clientWidth);//190        console.log(div.clientHeight);//200        console.log(div.clientWidth);//200</code></pre><blockquote><p>注意：div和button的表现是不同的，由于button元素默认设置的有box-sizing: border-box属性，所以为button和div同时设置宽高为200px，边框为5px时，得到的内容宽度却是分别为190px和200px。</p></blockquote><p>如果此时再为其分别加上margin：</p><pre><code>&lt;style&gt;    #btn {        border: 5px solid green;        width: 200px;        height: 200px;    }    #div {        border: 5px solid blue;        width: 200px;        height: 200px;    }&lt;/style&gt;        let btn =document.getElementById(&#39;btn&#39;)        let div = document.getElementById(&#39;div&#39;)        btn.style.padding = &#39;20px&#39;        div.style.padding = &#39;20px&#39;        console.log(btn.clientHeight);//190        console.log(btn.clientWidth);//190        console.log(div.clientHeight);//240        console.log(div.clientWidth);//240</code></pre><blockquote><p>可以看到button的宽高仍为190（也就是说，clientWidth不包括border，只是包括内容宽高和内边距），而div则变为240. 注意：clientWidth和clientHeight都是只读属性，不能通过赋值修改。</p></blockquote><p>如果此时的元素结构是子元素的宽高比父元素的宽高要大，而且设置父元素的属性为<code>overflow：hidden</code> :</p><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;div id=&quot;div2&quot;&gt;    &lt;/div&gt;&lt;/div&gt;    #div1 {        width: 120px;        height: 150px;        background-color: red;        overflow: hidden;    }    #div2 {        width: 400px;        height: 400px;        background-color: blue;    }    //此时获得的clientWidth和clientHeight仍然为400       let div2 = document.getElementById(&#39;div2&#39;)        console.log(div2.clientWidth);//400        console.log(div2.clientHeight);//400</code></pre><h5 id="使用clientTop和clientLeft"><a href="#使用clientTop和clientLeft" class="headerlink" title="使用clientTop和clientLeft"></a>使用clientTop和clientLeft</h5><p>使用clientTop和clientLeft获取一个元素顶部边框的宽度和做边框的宽度（以像素表示）。clientTop不包括顶部外边距或内边距。<code>clientTop</code> 是只读的。<code>clientLeft</code> 不包括左外边距和左内边距。<code>clientLeft</code> 是只读的。</p><pre><code>&lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt;    #areaDiv {        border: 15px solid red;        width: 300px;        height: 50px;        margin: 100px auto 20px auto;        padding: 20px;    }            let areaDiv = document.getElementById(&quot;areaDiv&quot;);                        let clientX = areaDiv.clientLeft            let clientY = areaDiv.clientTop            console.log(clientX, clientY);//15 15</code></pre><h5 id="使用offsetWidth和offsetHeight获取整个元素的宽高（内容宽高-内边距-border）"><a href="#使用offsetWidth和offsetHeight获取整个元素的宽高（内容宽高-内边距-border）" class="headerlink" title="使用offsetWidth和offsetHeight获取整个元素的宽高（内容宽高 + 内边距 + border）"></a>使用offsetWidth和offsetHeight获取整个元素的宽高（内容宽高 + 内边距 + border）</h5><pre><code>&lt;style&gt;    #btn {        border: 5px solid green;        width: 200px;        height: 200px;    }    #div {        border: 5px solid blue;        width: 200px;        height: 200px;    }&lt;/style&gt;        let btn =document.getElementById(&#39;btn&#39;)        let div = document.getElementById(&#39;div&#39;)        btn.style.padding = &#39;20px&#39;        div.style.padding = &#39;20px&#39;        console.log(btn.offsetWidth);//200        console.log(btn.offsetHeight);//200        console.log(div.offsetWidth);//250        console.log(div.offsetHeight);//250</code></pre><h5 id="获取元素的“定位”父元素"><a href="#获取元素的“定位”父元素" class="headerlink" title="获取元素的“定位”父元素"></a>获取元素的“定位”父元素</h5><pre><code>&lt;body id=&quot;body&quot;&gt;&lt;div id=&quot;div1&quot;&gt;    &lt;div id=&quot;div2&quot;&gt;        &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>如果没有开启定位，那么div3的定位父元素为body：</p><pre><code>        let div3 = document.getElementById(&#39;div3&#39;)        console.log(div3.offsetParent.id);//body</code></pre><p>offsetParent会获取开启了定位的最近的祖先元素。开启div2的相对定位：</p><pre><code>   let div2 = document.getElementById(&#39;div2&#39;)        let div3 = document.getElementById(&#39;div3&#39;)        div2.style.position = &#39;relative&#39;        console.log(div3.offsetParent.id);//div2</code></pre><h5 id="使用offsetTop和offsetLeft获取当前元素相对于定位元素的水平偏移量和竖直偏移量"><a href="#使用offsetTop和offsetLeft获取当前元素相对于定位元素的水平偏移量和竖直偏移量" class="headerlink" title="使用offsetTop和offsetLeft获取当前元素相对于定位元素的水平偏移量和竖直偏移量"></a>使用offsetTop和offsetLeft获取当前元素相对于定位元素的水平偏移量和竖直偏移量</h5><pre><code>        let div3 = document.getElementById(&#39;div3&#39;)        console.log(div3.offsetTop);//712        console.log(div3.offsetLeft);//0</code></pre><blockquote><p>由于没有找到开启定位的父元素，那么偏移量就是相对于body的偏移量。</p></blockquote><p>让div2开启定位：</p><pre><code>                let div2 = document.getElementById(&#39;div2&#39;)        let div3 = document.getElementById(&#39;div3&#39;)        div2.style.position = &#39;relative&#39;        console.log(div3.offsetTop);//0        console.log(div3.offsetLeft);//0</code></pre><h5 id="scrollWidth、scrollHeight、scrollLeft、scrollTop"><a href="#scrollWidth、scrollHeight、scrollLeft、scrollTop" class="headerlink" title="scrollWidth、scrollHeight、scrollLeft、scrollTop"></a>scrollWidth、scrollHeight、scrollLeft、scrollTop</h5><p>获取元素的可滚动区域的宽高scrollWidth和scrollHeight，获取滚动条水平和竖直方向滚动的值scrollLeft和scrollTop：</p><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;div id=&quot;div2&quot;&gt;    &lt;/div&gt;&lt;/div&gt;    #div1 {        width: 120px;        height: 150px;        background-color: red;        overflow: auto;    }    #div2 {        width: 800px;        height: 400px;        background-color: blue;    }    let div1 = document.getElementById(&#39;div1&#39;)        console.log(div1.scrollWidth);//800        console.log(div1.scrollHeight);//400        console.log(div1.clientWidth);//105        console.log(div1.clientHeight);//135        console.log(div1.scrollLeft);        console.log(div1.scrollTop);</code></pre><blockquote><p>注意：设置div1的宽高为120 和150，得到的clientWidth宽度为105，clientHeight为135.原因是滚动条的宽度为15px。client值不包括滚动条。 </p><p>如果，div1.scrollHeight - div1.scrollTop === div1.clientHeight时，说明竖直滚动条滚到底部了。</p></blockquote><h5 id="示例1：滚动监听"><a href="#示例1：滚动监听" class="headerlink" title="示例1：滚动监听"></a>示例1：滚动监听</h5><pre><code>&lt;div id=&quot;box&quot;&gt;    &lt;div id=&quot;content&quot;&gt;    &lt;/div&gt;&lt;/div&gt;    window.onload = function() {        let box = document.getElementById(&#39;box&#39;)        console.log(&#39;0000&#39;)        box.onscroll = function () {            if (box.scrollHeight - box.scrollTop === box.clientHeight) {              console.log(&#39;------滚动到底部了--&#39;)            } else {                console.log(&#39;没有滚动到底部&#39;)            }        }    }</code></pre><h5 id="示例2：鼠标位置"><a href="#示例2：鼠标位置" class="headerlink" title="示例2：鼠标位置"></a>示例2：鼠标位置</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;鼠标位置&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt;    #areaDiv {        border: 15px solid red;        width: 300px;        height: 50px;        margin: 100px auto 20px auto;        padding: 20px;    }    #showMsg {        border: 1px solid black;        width: 300px;        height: 20px;        margin: 0 auto;    }&lt;/style&gt;&lt;body&gt;&lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt;&lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    window.onload = function () {        let areaDiv = document.getElementById(&quot;areaDiv&quot;);        let showMsg = document.getElementById(&quot;showMsg&quot;);        areaDiv.onmousemove = function (event) {            event = event || window.event            let offsetX = areaDiv.offsetLeft            let offsetY = areaDiv.offsetTop            let clientX = areaDiv.clientLeft            let clientY = areaDiv.clientTop            console.log(offsetX, offsetY, clientX, clientY);            /*             * clientX可以获取鼠标指针的水平坐标             * cilentY可以获取鼠标指针的垂直坐标             * 因为获取到的鼠标位置是相对于body的，             * 所以需要减去元素本身距离body的偏移             * 减去自身的边框             */            let x = event.clientX - offsetX - clientX;            let y = event.clientY - offsetY - clientY;            showMsg.innerHTML = &quot;x = &quot;+x + &quot; , y = &quot;+y;        }    }&lt;/script&gt;</code></pre><h5 id="示例3：-跟随鼠标移动"><a href="#示例3：-跟随鼠标移动" class="headerlink" title="示例3： 跟随鼠标移动"></a>示例3： 跟随鼠标移动</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;鼠标移动&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        #box {            width: 100px;            height: 100px;            background-color: red;            position: absolute;        }    &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;height: 1000px;width: 2000px;&quot;&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    window.onload = function () {        let box = document.getElementById(&#39;box&#39;)        //绑定鼠标        document.onmousemove = function (event) {            event = event || window.event            let left = event.clientX;            let　top = event.clientY;            //获取滚动条滚动的距离            /*             * chrome认为浏览器的滚动条是body的，可以通过body.scrollTop来获取             * 火狐等浏览器认为浏览器的滚动条是html的，             */            let st = document.body.scrollTop || document.documentElement.scrollTop;            let sl = document.body.scrollLeft || document.documentElement.scrollLeft;            console.log(left, top);            box.style.left = left + sl+ &quot;px&quot;;            box.style.top = top  + st + &quot;px&quot;;        }    }&lt;/script&gt;</code></pre><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>所谓事件冒泡，就是指事件会向上传递。表现为当后代元素的事件被触发后，其祖先的相同事件也会被触发。</p><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;        let div1 = document.getElementById(&#39;div1&#39;)        let div2 = document.getElementById(&#39;div2&#39;)        div1.onclick = function (event) {            console.log(&#39;div1___&#39;);        }        div2.onclick = function (event) {            console.log(&#39;div2&#39;);        }</code></pre><p>如果不希望事件冒泡，可以取消冒泡：</p><pre><code>        div2.onclick = function (event) {            console.log(&#39;div2&#39;);            event = event || window.event            //取消冒泡            event.cancelBubble = true        }</code></pre><h5 id="示例1：-事件的委派"><a href="#示例1：-事件的委派" class="headerlink" title="示例1： 事件的委派"></a>示例1： 事件的委派</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;事件的委派&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;添加超链接&lt;/button&gt;&lt;ul id=&quot;u1&quot; style=&quot;background-color: #bfa;&quot;&gt;    &lt;li&gt;        &lt;p&gt;我是p元素&lt;/p&gt;    &lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接一&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接二&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;超链接三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    window.onload = function () {        let ul = document.getElementById(&quot;u1&quot;)        console.log(ul);        let btn = document.getElementById(&#39;btn&#39;)        btn.onclick = function () {            let li = document.createElement(&#39;li&#39;)            li.innerHTML = &quot;&lt;a href=&#39;javascript:;&#39; class=&#39;link&#39;&gt;新建的超链接&lt;/a&gt;&quot;            ul.appendChild(li)        }        // 我们给li的父元素ul绑定事件        ul.onclick = function (event) {            //event.target 获取触发事件的对象            if (event.target.className === &#39;link&#39;) {                console.log(&quot;我是ul的单击响应函数&quot;);            }        }    }&lt;/script&gt;</code></pre><h5 id="示例2：事件绑定"><a href="#示例2：事件绑定" class="headerlink" title="示例2：事件绑定"></a>示例2：事件绑定</h5><p>我们通过<code>btn01.onclick = function(){}</code>这种方式绑定响应函数，多次绑定只有最后一个生效。如果希望可以绑定多个响应函数，可以通过<code>addEventListener</code>这种方式：</p><pre><code>        //  参数：        //     1.事件的字符串，不要on        //  2.回调函数，当事件触发时该函数会被调用        //  3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false        btn.addEventListener(&#39;click&#39;, function () {            console.log(&quot;222222222222&quot;);        }, false)</code></pre><blockquote><p>注意：addEventListener这个方法不支持IE8及以下的浏览器。在IE8中可以使用attachEvent()来绑定事件。</p></blockquote><p>封装函数适配IE8：</p><pre><code>            function bind(obj , eventStr , callback){                if(obj.addEventListener){                    //大部分浏览器兼容的方式                    obj.addEventListener(eventStr , callback , false);                }else{                    /*                     * this是谁由调用方式决定                     * callback.call(obj)                     */                    //IE8及以下                    obj.attachEvent(&quot;on&quot;+eventStr , function(){                        //在匿名函数中调用回调函数                        callback.call(obj);                    });                }            }//使用：bind(btn01 , &quot;click&quot; , function(){                    alert(this);                });</code></pre><h5 id="示例3：鼠标拖拽"><a href="#示例3：鼠标拖拽" class="headerlink" title="示例3：鼠标拖拽"></a>示例3：鼠标拖拽</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;鼠标拖拽&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    #box {        width: 100px;        height: 100px;        background-color: blue;        position: absolute;    }&lt;/style&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    window.onload = function () {        let box = document.getElementById(&#39;box&#39;)        box.onmousedown = function (event) {            //当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上            box.setCapture &amp;&amp; box.setCapture()            event = event || window.event            //获取按下时，鼠标相对于该元素左上角的偏移值            let offsetX = event.clientX - box.offsetLeft            let offsetY = event.clientY - box.offsetTop            document.onmousemove = function (event) {                event = event || window.event                //每一次移动，都需要减去这个偏移量                box.style.left = event.clientX - offsetX + &#39;px&#39;                box.style.top = event.clientY - offsetY + &#39;px&#39;            }            document.onmouseup = function (event) {                document.onmousemove = null                document.onmouseup = null                //当鼠标松开时，取消对事件的捕获                box.releaseCapture &amp;&amp; box.releaseCapture()            }            /*             * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，             *     此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，             *     如果不希望发生这个行为，则可以通过return false来取消默认行为             *             * 但是这招对IE8不起作用             */            return false        }    }&lt;/script&gt;</code></pre><h5 id="示例4：-鼠标滚轮滚动事件"><a href="#示例4：-鼠标滚轮滚动事件" class="headerlink" title="示例4： 鼠标滚轮滚动事件"></a>示例4： 鼠标滚轮滚动事件</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;鼠标滚轮滚动事件&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    #box {        width: 100px;        height: 100px;        background-color: red;    }&lt;/style&gt;&lt;body style=&quot;height: 2000px;&quot;&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    window.onload = function () {        let box = document.getElementById(&#39;box&#39;)        //为box绑定一个鼠标滚轮滚动的事件        /*         * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，         *     但是火狐不支持该属性         *         * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件         *     注意该事件需要通过addEventListener()函数来绑定         */        box.onmousewheel = function (event) {            event = event || window.event            //event.wheelDelta 可以获取鼠标滚轮滚动的方向(向上为120，向下-120,与系统设置的鼠标方向有关)            //wheelDelta这个属性火狐中不支持            //在火狐中使用event.detail来获取滚动的方向            //向上滚 -3  向下滚 3            console.log(event.wheelDelta);            if (event.wheelDelta &gt; 0 || event.detail &lt; 0) {                //向上滚，box1变短                box.style.height = box.clientHeight - 10 + &quot;px&quot;;            } else {                //向下滚，box1变长                box.style.height = box.clientHeight + 10 + &quot;px&quot;;            }            /*            * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false            * 需要使用event来取消默认行为event.preventDefault();            * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错            */            event.preventDefault &amp;&amp; event.preventDefault();            return false;        }        //为火狐绑定滚轮事件        bind(box1, &quot;DOMMouseScroll&quot;, box1.onmousewheel);    }    function bind(obj, eventStr, callback) {        if (obj.addEventListener) {            //大部分浏览器兼容的方式            obj.addEventListener(eventStr, callback, false);        } else {            /*             * this是谁由调用方式决定             * callback.call(obj)             */            //IE8及以下            obj.attachEvent(&quot;on&quot; + eventStr, function () {                //在匿名函数中调用回调函数                callback.call(obj);            });        }    }&lt;/script&gt;</code></pre><h5 id="示例5：键盘事件"><a href="#示例5：键盘事件" class="headerlink" title="示例5：键盘事件"></a>示例5：键盘事件</h5><pre><code>    window.onload = function () {        document.onkeydown = function (event) {            event = event || window.event;            //通过keyCode来获取按键的编码（注意：keyCode已经从web标准中移除了）            //shiftKey altKey ctrlKey metaKey判断shift alt ctrl command是否被按下            console.log(event);            if (event.keyCode === 65) {                console.log(&#39;a&#39;);            }            //在文本框中输入内容，属于onkeydown的默认行为            //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中            return false        }        document.onkeyup = function (event) {        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript细节总结</title>
      <link href="/2018/04/03/2018-04-03-javascript-xi-jie-zong-jie/"/>
      <url>/2018/04/03/2018-04-03-javascript-xi-jie-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>在ES5中，JavaScript共有6种数据类型，其中前5种为基本数据类型，Object为引用数据类型：</p><pre class=" language-javascript"><code class="language-javascript">String  Number  Boolean  Null  Undefined Object</code></pre><p>需要注意的是,  NaN的typeof值是number；  Null的typeof值是object（注意结果的大小写）：</p><pre><code>//typeof 运行后对应的结果：string  number boolean object undefined object</code></pre><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><h5 id="其他类型转String"><a href="#其他类型转String" class="headerlink" title="其他类型转String"></a>其他类型转String</h5><p>注意：null和undefined调用toString方法会报错，但是调用String()方法则直接转换为相应的字面量字符串：</p><pre><code>var a = null;a.toString();//error:Cannot read property &#39;toString&#39; of nullvar b = undefined;b.toString(); //error: Cannot read property &#39;toString&#39; of undefined//如果是undefined类型调用String()方法：var result =  undefinedresult = String(result)console.log(result);// undefined (这个undefined是字符串类型的)console.log(typeof result);//stringresult += &#39;abc&#39;console.log(result); //undefinedabc//如果是undefined类型调用String()方法：var result =  nullresult = String(result)console.log(result);// null (这个null是字符串类型的)console.log(typeof result);//stringresult += &#39;abc&#39;console.log(result); //nullabc</code></pre><blockquote><p>对于Boolean和Number类型的，调用toString()和String()的结果都是一样的，true会转为“true”,123转为“123”。</p></blockquote><h5 id="其他类型转Number"><a href="#其他类型转Number" class="headerlink" title="其他类型转Number"></a>其他类型转Number</h5><p>通过Number()函数转换为数字的，要么转化为数字，要么转化为NaN。需要注意的是：undefined会转化为NaN，而null则转化为0。并且，如果是空字符串或者全是空格的字符串，转化结果也都是0。针对布尔值，如果为true，则转化为1，false则转化为0.如果是Object类型的，则转化为NaN。</p><pre><code>    var a =  &#39;123&#39;    a = Number(a)    console.log(a); //123    var b = &#39;abc&#39;    b = Number(b)    console.log(b);//NaN    var c = undefined    c = Number(c)    console.log(c);//NaN    var d = null    d = Number(d)    console.log(d);//0    var e = &#39;&#39;    e = Number(e)    console.log(e);//0    var f = &#39;     &#39;    f = Number(f)    console.log(f);//0    var g =  true    g = Number(g)    console.log(g);//1    var h = false    h = Number(h)    console.log(h);//0    var i = {}    i = Number(i)    console.log(i);//NaN</code></pre><p>通过parseInt来转为数字的，如果是以数字开头的字符串，那么就可以转化为数字，否则便会转化为NaN，在parseInt中，’123.456px’会转化为123，而在parseFloat中，’123.456px’则会转化为123.456;如果是非字符串如Boolean类型的true，则会先转化为字符串的”true”，再通过parseInt来转，由于不是已数字开头的字符串，自然会转为NaN:</p><pre><code>        var a =  &#39;123&#39;    a = parseInt(a)    console.log(a); //123    var a2 =  &#39;123px&#39;    a2 = parseInt(a2)    console.log(a2); //123    var a3 =  &#39;age:123&#39;    a3 = parseInt(a3)    console.log(a3); //NaN    var a4 =  &#39;abc123px456&#39;    a4 = parseInt(a4)    console.log(a4); //NaN    var a5 =  &#39;123.456px&#39;    a5 = parseInt(a5)    console.log(a5); //123    var a6 =  &#39;123.456px&#39;    a6 = parseFloat(a6)    console.log(a6); //123.456    var a7 =  &#39;123px456&#39;    a7 = parseInt(a7)    console.log(a7); //123    var b = &#39;abc&#39;    b = parseInt(b)    console.log(b);//NaN    var c = undefined    c = parseInt(c)    console.log(c);//NaN    var d = null    d = parseInt(d)    console.log(d);//NaN    var e = &#39;&#39;    e = parseInt(e)    console.log(e);//NaN    var f = &#39;     &#39;    f = parseInt(f)    console.log(f);//NaN    var g =  true    g = parseInt(g)    console.log(g);//NaN    var h = false    h = parseInt(h)    console.log(h);//NaN    var i = {}    i = parseInt(i)    console.log(i);//NaN</code></pre><h5 id="其他类型转Boolean"><a href="#其他类型转Boolean" class="headerlink" title="其他类型转Boolean"></a>其他类型转Boolean</h5><pre><code>    var a =  &#39;123&#39;    a = Boolean(a)    console.log(a); //true    var a2 =  123    a2 = Boolean(a2)    console.log(a2); //true    var a3 =  -123    a3 = Boolean(a3)    console.log(a3); //true    var a4 =  []    a4 = Boolean(a4)    console.log(a4); //true    var a5 =  &#39;&#39;    a5 = Boolean(a5)    console.log(a5); //false    var a6 =  Infinity    a6 = Boolean(a6)    console.log(a6); //true    var a7 =  &#39;    &#39;    a7 = Boolean(a7)    console.log(a7); //true    var b = {}    b = Boolean(b)    console.log(b);//true    var c = undefined    c = Boolean(c)    console.log(c);//false    var d = null    d = Boolean(d)    console.log(d);//false    var e = 0    e = Boolean(e)    console.log(e);//false    var f = NaN    f = Boolean(f)    console.log(f);//false</code></pre><blockquote><p>由上面的结果可以知道：空数组和空对象转化为布尔值的结果为true，而空字符串、null、undefined、NaN、0转化的结果为false。</p></blockquote><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>当对非Number类型的值进行运算时，会先转换为Number类型再进行运算,加法运算符比较特殊，除了做加法操作外，还能做拼接字符串的操作(任何值和字符串想加，都需要先将其转化为字符串再进行拼接)。所以，数字型字符串在不同运算符的表现是不一定相同的：</p><pre><code>    var a =  true + 1    console.log(a); //2    var a2 =  false + 1    console.log(a2); //1    var a3 =  10 + null    console.log(a3); //10    var a4 =  [&#39;123&#39;,&#39;456&#39;] + 10    console.log(a4); //123,45610    console.log(&#39;-----&#39;,typeof a4); //string    var A4 =  [&#39;123&#39;,&#39;456&#39;] - 10    console.log(A4); //NaN    console.log(&#39;-----&#39;,typeof A4); //number    var AA4 =  [] - 10    console.log(AA4); //-10    console.log(&#39;-----&#39;,typeof AA4); //number    var a5 =  &#39;&#39; + 10    console.log(a5); //10    console.log(typeof a5); //string    var A5 =  &#39;&#39; - 10    console.log(A5); //-10    console.log(typeof A5); //number    var AA5 =  &#39;110&#39; - 10    console.log(AA5); //100    console.log(&#39;+++++&#39;,typeof AA5); //number    var a6 =  Infinity + 1    console.log(a6); //Infinity    var a7 =  &#39;    &#39; + 1    console.log(a7); //&#39;   1&#39;    console.log(typeof  a7); //string    var A7 =  &#39;    &#39; - 1    console.log(A7); //-1    console.log(&#39;____&#39;,typeof  A7); //number    var AA7 =  &#39;abc&#39; - 1    console.log(AA7); //NaN    console.log(&#39;__+++__&#39;,typeof  AA7); //number    var b = {} + 1    console.log(b);//[object Object]1    var B = {} - 1    console.log(B);//NaN    var c = undefined + 1    console.log(c);//NaN    var d = NaN + 1    console.log(d);//NaN    var e = &#39;123&#39; + 123    console.log(e);//123123    var f = &#39;123&#39; + &#39;123&#39;    console.log(f);//123123</code></pre><h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h4><pre><code>    console.log(&#39;true&#39; == 1);//false    console.log(true == 1);//true    console.log(&#39;1&#39; == 1);//true    console.log(null == 0);//false    console.log(undefined == 0);//false    console.log(undefined == null);//true    console.log(NaN == NaN);//false</code></pre><blockquote><p>注意NaN不和任何数据相等，包括和自己相比较。</p></blockquote><h4 id="基本数据类型与引用数据类型的区别"><a href="#基本数据类型与引用数据类型的区别" class="headerlink" title="基本数据类型与引用数据类型的区别"></a>基本数据类型与引用数据类型的区别</h4><p>String/ Number/ Boolean/Undefined/Null是基本数据类型，Object是引用数据类型。</p><pre><code>    var a = 123;    var b = a;    a++;    console.log(a);//124    console.log(b);//123    var c = 110;    var d = c;    d++;    console.log(c);//110    console.log(d);//111    //*******************虽然很基础，但是很重要************************    var user = {};    user.age = 18;    user.name = &quot;LEG&quot;;    var myAge = user.age;    var myName = user.name;    console.log(myAge);//18    console.log(myName);//LEG    //更改值后不影响user对象。    myAge = 456;    myName = &quot;LXX&quot;;    console.log(user.name);//LEG    console.log(user.age);//18    //更改user对象值后也不影响myAge myName。    user.name = &quot;DLL&quot;;    user.age = 666;    console.log(myName);//LXX    console.log(myAge);//456    //*******************虽然很基础，但是很重要************************    var user = {};    user.age = 18;    user.name = &quot;LEG&quot;;    //引用数据类型被引用    var myUser = user;    console.log(myUser.name);//LEG    console.log(myUser.age);//18    //更改user对象值后会影响myUser。    user.name = &quot;DLL&quot;;    user.age = 666;    console.log(myUser.name);//DLL    console.log(myUser.age);//666    //更改myUser值后也会影响user。    myUser.name = &quot;LXX&quot;;    myUser.age = 333;    console.log(user.name);//LXX    console.log(user.age);//333    //*******************虽然很基础，但是很重要************************       var user = {        name: &#39;lxx&#39;,        age: 18,        edu: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],        female: true,        other: {            address: &#39;henan&#39;,            count: 4,            marry: false,            family: [&#39;father&#39;, &#39;mather&#39;,&#39;sister&#39;]        }    };    console.log(user);    //将user的属性值为基本数据类型的取出后更改，不影响user    var name = user.name;    var age = user.age;    var edu = user.edu;    var female = user.female;    name = &#39;DLL&#39;;    age = 19;    edu = [&#39;E&#39;, &#39;F&#39;, &#39;G&#39;];    female = false;    console.log(user);    //但是， 如果取出的值不是基本数据类型，列如user.other，是一个Object，那么更改值后会影响user    var other = user.other    other.address = &#39;hebei&#39;;    other.count = 9;    other.marry = true;    other.family = [&#39;G&#39;, &#39;GM&#39;];    //新增一个属性    other.data = &#39;shzyh&#39;;    console.log(user);    //此时我直接拿一个新的值来替换other,是不影响上面的对user.other的设置的，除非再执行一步user.other = other    other = {        test: &#39;999&#39;    }    // user.other = other    console.log(user);</code></pre><blockquote><p>基本数据类型之间的赋值，例如a=b,仅仅是将b的值赋值给了a，a和b的值仅仅是相同，一方更改值不会影响另一方。对象的属性值如果是基本数据类型，例如 a=user.name,那么赋值给a后，a和user.name也仅仅是值相同，一方更改值后也不会影响另一方。但是如果是other = user.other,通过更改other的值是会影响user.other的值的。虽然很基础，但是很重要。</p></blockquote><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>声明函数的几种方式：</p><pre><code>    //使用构造函数来创建函数    var test = new Function(&quot;console.log(&#39;LEG___&#39;);&quot;);    test();    console.log(typeof test); //function    //使用函数声明来创建函数。注意：因为函数也是对象，所以可以给test2添加属性。    function test2() {        console.log(&#39;LEG+++&#39;);    }    test2.age = 18;    console.log(typeof test2); //function    console.log(test2.age); //function    //使用函数表达式来创建函数    var test3 = function () {        console.log(&#39;LEG;;;;;;;;&#39;);    }    test3();</code></pre><p>立即执行函数：</p><pre><code>    (function (name) {        console.log(`我是${name}`);    })(&#39;LEG&#39;);</code></pre><p>函数在对象中使用：</p><pre><code>    var user = {        name: &#39;LEG&#39;,        age: 18,        print: function (content) {            console.log(content)        }    }    user.print(&#39;77777&#39;);</code></pre><p>在函数中，不使用var声明的变量都会成为全局变量：</p><pre><code>    var name = &#39;LEG&#39;;    function test() {        //未使用var声明变量，age是全局变量        age = 123;        //更改全局变量name的值        name = &#39;DLL&#39;;    }    test();    console.log(name);//DLL    console.log(age);//123</code></pre><pre><code>   //name和age都没有使用var声明，他们都是全局变量   name = &#39;LEG&#39;;    function test() {        name = &#39;DLL&#39;;    }    console.log(name);//LEG    test();    console.log(name);//DLL    age = 666;    console.log(age);//666</code></pre><p>在函数中，通过形参传递的值是局部变量：</p><pre><code>   var name = &#39;LEG&#39;;    function test(name) {        //name通过形参传递过来的，相当于在函数中声明了局部变量 var name = &#39;DLL&#39;        //如果迷糊name的传值，那么把形参换成abc是不是立即就秒懂了？？？        name = &#39;DLL&#39;;    }    test(name);    console.log(name);//LEG</code></pre><p>构造函数</p><pre><code>        function Person(name, age) {        this.name = name;        this.age = age;        this.print = function () {            console.log(this.name);            console.log(this.age);        }    }    var per = new Person(&#39;DLL&#39;, 29)    per.print()    console.log(per instanceof Person);</code></pre><blockquote><p>上面这种构造函数中的print函数是写在构造函数中的，如果创建多个person，那么print的函数就会创建多次。但是如果通过以下的方式，将print函数给抽出来，又会造成以下问题：1.抽取出来的函数会污染全局作用域的命名空间；2.定义在全局作用域中也会很不安全，会被不小心给覆盖掉。</p></blockquote><pre><code>    function Person(name, age) {        this.name = name;        this.age = age;        this.print = myPrint;    }    function myPrint() {        console.log(this.name);        console.log(this.age);    }    var per = new Person(&#39;DLL&#39;, 29)    per.print()    console.log(per instanceof Person);</code></pre><h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>我们创建的每一个函数，解析器都会向函数中添加一个属性叫prototype，prototype属性对应着一个对象，这个对象就叫原型对象。</p><p>如果函数作为普通的函数去调用prototype没有什么作用。但是如果是以构造函数的方式调用时，构造函数创建的每一个对象都会含有一个隐含属性__proto__，指向该构造函数的原型对象。</p><pre><code>    function Person(name, age) {        this.name = name;        this.age = age;        this.print = myPrint;    }    function myPrint() {        console.log(this.name);        console.log(this.age);    }    var per = new Person(&#39;DLL&#39;, 29)    console.log(Person.prototype);    console.log(per.__proto__);    //构造函数创建的对象的__proto__和构造函数的prototype是相同的    console.log(per.__proto__ === Person.prototype);//true</code></pre><blockquote><p>原型对象就相当于一个公共区域，同一个类的所有实例都可以访问到这个原型对象。因此，我们可以将对象中的共有内容，统一设置到原型对象中。当我们访问对象的属性或方法时，他会先在自身中寻找，如果没有找到，会再从原型对象中查找使用。所以，以后我们创建构造函数时，可以将这些对象共有的属性和方法放到原型对象中。</p></blockquote><pre><code>    function Person(name, age) {        this.name = name;        this.age = age;    }    //向原型对象中添加属性和函数    Person.prototype.test = 88888;    Person.prototype.print = function() {        console.log(this.name);        console.log(this.age);    }    var per = new Person(&#39;DLL&#39;, 29)    //我们可以直接使用通过原型对象添加的函数和属性    per.print()    console.log(per.test);</code></pre><h5 id="使用in和hasOwnProperty检查对象是否含有某个属性的区别"><a href="#使用in和hasOwnProperty检查对象是否含有某个属性的区别" class="headerlink" title="使用in和hasOwnProperty检查对象是否含有某个属性的区别"></a>使用in和hasOwnProperty检查对象是否含有某个属性的区别</h5><pre><code>    function Person(name, age) {        this.name = name;        this.age = age;    }    //向原型对象中添加属性和函数    Person.prototype.test = 88888;    Person.prototype.print = function() {        console.log(this.name);        console.log(this.age);    }    var per = new Person(&#39;DLL&#39;, 29)    //我们可以直接使用通过原型对象添加的函数和属性    per.print()    console.log(per.test);    //使用in来检查对象是否含有某个属性时，如果对象没有，但是原型对象中有，那么返回为true    console.log(&#39;test&#39;in per);    const result = per.hasOwnProperty(&#39;test&#39;)    //使用hasOwnProperty检查对象属性时，必须是自己含有该属性时才会返回为true    console.log(result);//false</code></pre><h5 id="Object的原型对象是null"><a href="#Object的原型对象是null" class="headerlink" title="Object的原型对象是null"></a>Object的原型对象是null</h5><pre><code>    console.log(per.hasOwnProperty(&#39;hasOwnProperty&#39;));//false    console.log(per.__proto__.hasOwnProperty(&#39;hasOwnProperty&#39;));//false    //per.__proto__.__proto__对应的原型对象就是Object    console.log(per.__proto__.__proto__.hasOwnProperty(&#39;hasOwnProperty&#39;));//true    //Object的原型对象是null，也就是说Object没有原型对象    console.log(per.__proto__.__proto__.__proto__);//null</code></pre><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><pre><code>    function Person(name, age) {        this.name = name;        this.age = age;    }    //如果我们希望在打印对象时不输出[object object]，我们可以为对象添加一个toString方法。    Person.prototype.toString = function () {        return `我的姓名是：${this.name}，我的年龄是${this.age}岁`;    }    var per = new Person(&#39;DLL&#39;, 29);    //当我们直接在页面中打印一个对象时，输出的是对象的toString()方法的返回值    console.log(per);    document.write(per)</code></pre><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>array的类型是object，并且如果数组发生越界，不会报错error，而是取出的值为undefined：</p><pre><code>      let arr = []    console.log(typeof arr) //object    console.log(arr[100]) //undefined</code></pre><p>修改length的值，如果length长度大于arr的原长度，那么多余的长度会在数组中空出来；如果小于原数组的长度，那么原数组会被截取掉：</p><pre><code>    let arr = [1,2,3,4,5]    arr.length = 10    console.log(arr)//[1,2,3,4,5,,,,,,]    console.log(arr[6])//undefined    let arr2 = [1,2,3,4,5]    arr2.length = 3    console.log(arr2) //[1,2,3]</code></pre><p>array作为函数的参数进行传递,直接操作array（比如push，pop等操作）会影响arr；但是如果通过赋值的形式，则不会影响arr。</p><pre><code>    let arr = [1,2,3,4,5]    function test(array) {        array.push(1)    }    test(arr)    console.log(arr) //[1, 2, 3, 4, 5, 1]</code></pre><p>slice与splice的区别：</p><pre><code>        //slice(start, end) 截取数组，不影响原数组    var array = [&#39;夏&#39;,&#39;商&#39;,&#39;周&#39;,&#39;齐&#39;,&#39;楚&#39;,&#39;燕&#39;,&#39;韩&#39;,&#39;赵&#39;,&#39;魏&#39;,&#39;秦&#39;]    var result = array.slice(1,4)    console.log(result);//[&quot;商&quot;, &quot;周&quot;, &quot;齐&quot;]    console.log(array);//[&quot;夏&quot;, &quot;商&quot;, &quot;周&quot;, &quot;齐&quot;, &quot;楚&quot;, &quot;燕&quot;, &quot;韩&quot;, &quot;赵&quot;, &quot;魏&quot;, &quot;秦&quot;]    //如果传负数-4，表示截取到最后，倒数后4个数不算在内    var result1 = array.slice(1, -4)    console.log(result1);//[&quot;商&quot;, &quot;周&quot;, &quot;齐&quot;, &quot;楚&quot;, &quot;燕&quot;]var result2 = array.slice(-1, 4)    console.log(result2);//[&quot;商&quot;, &quot;周&quot;, &quot;齐&quot;, &quot;楚&quot;, &quot;燕&quot;]    //splice(start,deleteCount,items)，返回值是被删除掉的数组(计数包括从start开始)    var array = [&#39;夏&#39;,&#39;商&#39;,&#39;周&#39;,&#39;齐&#39;,&#39;楚&#39;,&#39;燕&#39;,&#39;韩&#39;,&#39;赵&#39;,&#39;魏&#39;,&#39;秦&#39;]    //返回的是删除后的数组    var result = array.splice(1,4)    console.log(result);//[&quot;商&quot;, &quot;周&quot;, &quot;齐&quot;, &quot;楚&quot;]    console.log(array);//[&quot;夏&quot;, &quot;燕&quot;, &quot;韩&quot;, &quot;赵&quot;, &quot;魏&quot;, &quot;秦&quot;]    var array2 = [&#39;夏&#39;,&#39;商&#39;,&#39;周&#39;,&#39;齐&#39;,&#39;楚&#39;,&#39;燕&#39;,&#39;韩&#39;,&#39;赵&#39;,&#39;魏&#39;,&#39;秦&#39;]    //还可以传入第三个参数，来替换值    var result2 = array2.splice(3, 7, &#39;春秋&#39;, &#39;战国&#39;)    console.log(result2);//[&quot;齐&quot;, &quot;楚&quot;, &quot;燕&quot;, &quot;韩&quot;, &quot;赵&quot;, &quot;魏&quot;, &quot;秦&quot;]    console.log(array2);//[&quot;夏&quot;, &quot;商&quot;, &quot;周&quot;, &quot;春秋&quot;, &quot;战国&quot;]    //如果第二个参数deleteCount值为0，splice则可以实现插入的功能    var array3 = [&#39;夏&#39;,&#39;商&#39;,&#39;周&#39;,&#39;齐&#39;,&#39;楚&#39;,&#39;燕&#39;,&#39;韩&#39;,&#39;赵&#39;,&#39;魏&#39;,&#39;秦&#39;]    //还可以传入第2个参数为0    var result3 = array3.splice(3, 0, &#39;大周&#39;, &#39;小周&#39;, &#39;996&#39;)    console.log(result3);//[]    console.log(array3);// [&quot;夏&quot;, &quot;商&quot;, &quot;周&quot;, &quot;大周&quot;, &quot;小周&quot;, &quot;996&quot;, &quot;齐&quot;, &quot;楚&quot;, &quot;燕&quot;, &quot;韩&quot;, &quot;赵&quot;, &quot;魏&quot;, &quot;秦&quot;]</code></pre><p>js实现边遍历边删除的操作：</p><pre><code> //错误示范（array执行pop后会影响array.length的值） var array = [&#39;夏&#39;,&#39;商&#39;,&#39;周&#39;,&#39;齐&#39;,&#39;楚&#39;,&#39;燕&#39;,&#39;韩&#39;,&#39;赵&#39;,&#39;魏&#39;,&#39;秦&#39;]    for (var i = 0; i &lt; array.length; i++) {        array.pop()    }    console.log(array)//[&quot;夏&quot;, &quot;商&quot;, &quot;周&quot;, &quot;齐&quot;, &quot;楚&quot;]    var array = [&#39;夏&#39;,&#39;商&#39;,&#39;周&#39;,&#39;齐&#39;,&#39;楚&#39;,&#39;燕&#39;,&#39;韩&#39;,&#39;赵&#39;,&#39;魏&#39;,&#39;秦&#39;]    for (var i = 0; i &lt; array.length; i++) {        array.pop()        i--;    }    console.log(array)//[]    //那么同理可以实现遍历删除重复数组元素的操作：    var array = [1,1,1,2,3,3,3,3,4,4,5,6,7,7]    for (var i = 0; i&lt; array.length; i++) {        for (var j = i+1; j &lt; array.length; j++) {            if (array[i] === array[j]) {                array.splice(j,1)                j--            }        }     }    console.log(array) //[1, 2, 3, 4, 5, 6, 7]</code></pre><p>数组使用sort排序(会影响原数组)：</p><pre><code>    var array = [11,21,1,52]    //a - b 如果大于0，则交换位置，小于等于0，则不交换位置（例如：11-22）    let result = array.sort(function (a, b) {        return a - b;    })    console.log(array) //[1, 11, 21, 52]    console.log(result) //[1, 11, 21, 52]</code></pre><h4 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h4><p>call和apply方法都是函数对象的方法，需要函数对象来调用：</p><pre><code>    function test1() {        console.log(&#39;我被调用了。。。&#39;);    }    test1()    test1.call()    test1.apply()</code></pre><p>在调用call和apply方法时，可以将一个对象指定为函数的调用者：</p><pre><code>    var age = 110;    var user = {        age: 120    }    function test() {        console.log(this.age);    }    //直接调用test函数，则使用的age属性为全局的age属性。    test() // 110    //指定user，则使用user对象中的age属性    test.apply(user) // 120    test.call(user) //120</code></pre><p>不同对象之间也可以调用call和apply：</p><pre><code>    var user = {        age: 120,        print: function () {            console.log(this.age);        }    }    var user2 = {        age: 119,        print: function () {            console.log(this.age);        }    }    user2.print() // 119    user2.print.call(user) //120    user2.print.apply(user) //120</code></pre><p>传递参数时，call和apply的方式会有不同：</p><pre><code>    var desc = &#39;我还是个汪&#39;    var user = {        desc: &#39;我不是单身&#39;,    }    function  print(age, name) {        console.log(`我叫${name},今年${age}岁了！${this.desc}`);    }    //传递的是一个个的属性    print.call(user, 18, &#39;周杰伦&#39;) //我叫周杰伦,今年18岁了！我不是单身    //传递的是数组    print.apply(user, [18, &#39;周杰伦&#39;])//我叫周杰伦,今年18岁了！我不是单身    print(19,&#39;程序员&#39;)//我叫程序员,今年19岁了！我还是个汪</code></pre><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>在调用函数时，浏览器每次都会传递进来2个隐含的参数，一个是this，另一个就是arguments。</p><pre><code>    function test() {        console.log(arguments);    }    test()// [object Arguments]</code></pre><blockquote><p>arguments是类数组对象。它同数组类似，它也可以通过索引获取数据，它也可以获取length长度。在调用函数时，如果函数有参数，那么我们传递的参数都会被保存在arguments中。我们可以通过arguments.length来获取传递参数的长度。所以，我们即使不定义函数的形参，也可以获取传递给函数的实参。</p></blockquote><pre><code>    function test() {        console.log(arguments.length);    }    test()// 0    test(&#39;lxx&#39;)// 1    test(&#39;lxx&#39;, 123, false)// 3</code></pre><p>我们可以通过arguments.callee来获取当前正在调用的函数对象:</p><pre><code>    function test(name) {        console.log(arguments.length);//3        console.log(arguments.callee === test);//true        console.log(arguments.callee);        // function test(name) {        //     console.log(arguments.length);        //     console.log(arguments.callee === test);        //     console.log(arguments.callee);        // }    }    test(&#39;lxx&#39;, 123, false)</code></pre><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>基本使用：</p><pre><code>    let reg = new RegExp(&#39;a&#39;)    let str = &#39;abcdefg&#39;    let result = reg.test(str)    console.log(result); //true</code></pre><p>忽略大小写：</p><pre><code>    let reg = new RegExp(&#39;a&#39;, &#39;i&#39;)    let str = &#39;Abcdefg&#39;    let result = reg.test(str)    console.log(result); //true</code></pre><p>使用字面量来创建正则表达式：</p><pre><code>        //语法：  var 变量 = /正则表达式/匹配模式   let reg = /a/i    let str = &#39;Abcdefg&#39;    let result = reg.test(str)    console.log(result); //true</code></pre><p>正则表达式中 |表示或：</p><pre><code>        //匹配a或者b，忽略大小写        let reg = /a|b/i    let str = &#39;efgda&#39;    let result = reg.test(str)    console.log(result); //true</code></pre><p>使用[ab]也可以表示或：</p><pre><code>    //是否包含字母    /[a-z]/i    /[A-z]/  (注意：如果使用这种方式来忽略大小写，必须式大写A，小写z)  let reg = /[a-z]/i    let str = &#39;123A&#39;    let result = reg.test(str)    console.log(result); //true</code></pre><pre><code>//是否是字符串abc adc aec中的一个/a[bde]c///除了a和b，是否包含别的    let reg = /[^ab]/    let str = &#39;ac&#39;    let result = reg.test(str)    console.log(result); //true    //除了数字外，是否包含别的    /[^0-9]/</code></pre><p>在字符串中使用正则表达式：</p><pre><code>    let str = &#39;abcd1e3fgh77ij&#39;    let result = str.split(/[0-9]/)    console.log(result); //[&quot;abcd&quot;, &quot;e&quot;, &quot;fgh&quot;, &quot;&quot;, &quot;ij&quot;]    //搜索字符串中是否含有指定字符     let result2 = str.search(/[e-g]/)    console.log(result2); //5     //提取所有的字母，默认找到一个符合条件的就停止，所以要设置全局匹配    let result3 = str.match(/[A-z]/g)    console.log(result3); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;]        let result4 = str.replace(/[0-9]/g, &#39;--&gt;&#39;)    console.log(result4); //abcd--&gt;e--&gt;fgh--&gt;--&gt;ij</code></pre><p>设置次数：</p><pre><code>//a出现3次/a{3}///ab出现3次/(ab){3}///b出现1-3次/ab{1,3}c///b至少出现3次/ab{3,}c///b至少出现1次 相当于 /ab{1,}c//ab{+}c///b出现0次或多次  相当于 /ab{0,}c//ab{*}c///b出现0次或者1次  相当于 /ab{0,1}c//ab{?}c/</code></pre><p>设置位置：</p><pre><code>//以a开头：/^a///以a结尾：/a$///以a开头或者以a结尾：/^a|a$///验证手机号：/^1[3-9][0-9]{9}$/</code></pre><p>特殊字符：</p><pre><code>//在正则表达式中， “.”表示任意字符，如果要检查字符串中是否含有“.”，则需要使用&quot;\.&quot;：        let str = &#39;abc.efg&#39;    let regExp = /\./    console.log(regExp.test(str)) //true//注意，在使用正则表达式中的构造方法来创建时，由于参数是字符串，而在字符串中“\”又是转义字符//所以，在构造方法中，需要使用“\\”,例如，我们查询字符串是否以“.”结尾：    let str = &#39;.abc.efg.&#39;    let regExp = /\.$/    console.log(regExp.test(str)) //true    let regExp2 = new RegExp(&#39;\\.$&#39;)    console.log(regExp2.test(str)) //true//如果我们要查询是否已“\\”开头，则分别需要这样写：        let str = &#39;\\\\abc.efg.&#39;    let regExp = /^\\/    console.log(regExp.test(str)) //true    let regExp2 = new RegExp(&#39;^\\\\&#39;)    console.log(regExp2.test(str)) //true    //在正则表达式中，\w代表任意字母，数字，“_”下划线这三种，相当于[A-z0-9_]：     let str = &#39;_1abc.efg.&#39;        let regExp = /^\w/        console.log(regExp.test(str)) //true        let regExp2 = new RegExp(&#39;^\\w&#39;)        console.log(regExp2.test(str)) //true    //在正则表达式中，\W代表不是字母，数字，“_”下划线这三种的任意字符,相当于[^A-z0-9_]：    let str = &#39;_1abc.efg.&#39;    let regExp = /\W$/    console.log(regExp.test(str)) //true    let regExp2 = new RegExp(&#39;\\W$&#39;)    console.log(regExp2.test(str)) //true        \d 任意数字        \D 除了数字           \s 空格           \S 除了空格           \b 单词边界           \B 除了单词边界       let str = &#39;grandfather&#39;    let regExp = /father/    console.log(regExp.test(str)) //true    let regExp2 = /\bfather\b/    console.log(regExp2.test(str)) //false    //去除字符串中前后的空格    let str = &#39;   hello!  grandfather     &#39;    let regExp = /^\s*|\s*$/g    let result = str.replace(regExp, &#39;&#39;)    //电子邮件    // lxxwork0827@163.com    // sz.phealth@company.com.cn    // 任意字母下划线  .任意字母下划线  @    任意字母数字 .任意字母{2-5}  .任意字母{2-5}    /^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中常用的选择器</title>
      <link href="/2018/01/16/2018-01-16-css-zhong-chang-yong-de-xuan-ze-qi/"/>
      <url>/2018/01/16/2018-01-16-css-zhong-chang-yong-de-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><blockquote><p>就是标签的名字:</p></blockquote><pre><code>h1,p {    color:red;    font-size:50px;}</code></pre><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><pre><code>#pp {    color:red;    font-size:50px;}&lt;p id=&quot;pp&quot;&gt;我是段落&lt;/p&gt;</code></pre><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><pre><code>.h3 {    color:red;    font-size:50px;}.zhongyao {    text-decoration:underline;}&lt;p class=&quot;teshu zhongyao&quot;&gt;我是段落&lt;/p&gt;&lt;h3 class=&quot;teshu&quot;&gt;我是h3&lt;/h3&gt;</code></pre><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>空格就表示后代 .div1 p 表示div的后代所有的 p，后代不代表是儿子：</p><pre><code>.div p {    color：red;}&lt;div class = &#39;div1&#39;&gt;    &lt;p&gt;我是p&lt;/p&gt;&lt;/div&gt;&lt;!--p全部变红--&gt;&lt;div class = &#39;div1&#39;&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;p&gt;我是p&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;p&gt;我是p&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;p&gt;我是p&lt;/p&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;</code></pre><blockquote><p><strong>即使在第2个 li 中加入了类标记，但是 p 标签全部会变红。可以看出，只要是 div1 的后代中有 p，那么均会起作用</strong></p></blockquote><p><strong>只希望第2个 li 中的 p 标签会变红：</strong></p><pre><code>.div1 .li1 p {            color: red;        }&lt;div class = &#39;div1&#39;&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;p&gt;我是pp&lt;/p&gt;        &lt;/li&gt;        &lt;li class=&quot;li1&quot;&gt;            &lt;p&gt;我是pp&lt;/p&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;p&gt;我是pp&lt;/p&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;</code></pre><p><strong>下面的 p 标签依旧会变红：</strong></p><pre><code>div div p {    color: red; }&lt;div class = &#39;div1&#39;&gt;    &lt;div class = &#39;div2&#39;&gt;        &lt;div class = &#39;div3&#39;&gt;            &lt;div class = &#39;div4&#39;&gt;            &lt;p&gt;我是什么颜色？？？&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="交集选择器（从IE7开始兼容）"><a href="#交集选择器（从IE7开始兼容）" class="headerlink" title="交集选择器（从IE7开始兼容）"></a>交集选择器（从IE7开始兼容）</h4><p>使类为 special 的h3标签变红：</p><pre><code>&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;交集选择器练习&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        h3.special {            color: red;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h3 class=&quot;special&quot;&gt;我是 h&lt;/h3&gt;&lt;h3 class=&quot;special&quot;&gt;我是 h&lt;/h3&gt;&lt;p class=&quot;special&quot;&gt;我是 p&lt;/p&gt;&lt;p&gt;我是 p&lt;/p&gt;&lt;/body&gt;</code></pre><blockquote><p>说明：h3和.special 之间没有空格，有空格就是后代选择器了。</p></blockquote><p>可以连续交集：h3.special.imp</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;交集选择器练习&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        h3.special.imp {            color: red;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h3 class=&quot;special&quot;&gt;我是 h&lt;/h3&gt;&lt;h3 class=&quot;special imp&quot;&gt;我是 h&lt;/h3&gt;&lt;p class=&quot;special&quot;&gt;我是 p&lt;/p&gt;&lt;p&gt;我是 p&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><p>用，表示并集。</p><pre><code>h3,li {    color:red;}</code></pre><h3 id="CSS3的一些选择器"><a href="#CSS3的一些选择器" class="headerlink" title="CSS3的一些选择器"></a>CSS3的一些选择器</h3><h4 id="儿子选择器（IE7开始兼容）"><a href="#儿子选择器（IE7开始兼容）" class="headerlink" title="儿子选择器（IE7开始兼容）"></a>儿子选择器（IE7开始兼容）</h4><pre><code>div&gt;p {    color:red;}</code></pre><h4 id="序选择器（IE8开始兼容）"><a href="#序选择器（IE8开始兼容）" class="headerlink" title="序选择器（IE8开始兼容）"></a>序选择器（IE8开始兼容）</h4><pre><code>ul li:nth-child(n+2) {    color:red;}ul li:first-child {//选择第一个li    color:red;}ul li:last-child {//选择最后一个li    color:red;}</code></pre><h4 id="下一个兄弟选择器（IE7开始兼容）"><a href="#下一个兄弟选择器（IE7开始兼容）" class="headerlink" title="下一个兄弟选择器（IE7开始兼容）"></a>下一个兄弟选择器（IE7开始兼容）</h4><pre><code>h3+p {    color:red;}//表示紧跟着 h3后面的 p 会变红。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML的语法</title>
      <link href="/2018/01/15/2018-01-15-html-de-yu-fa/"/>
      <url>/2018/01/15/2018-01-15-html-de-yu-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="HTML历史版本说明"><a href="#HTML历史版本说明" class="headerlink" title="HTML历史版本说明"></a>HTML历史版本说明</h4><h5 id="1-语法声明头"><a href="#1-语法声明头" class="headerlink" title="1.语法声明头"></a>1.语法声明头</h5><ul><li>任何一个标准的HTML页面，第一行一定是以&lt;!DOCTYPE…开头的语句。DocType Declaration。此标签是告知浏览器文档是使用 HTML或 XHTML 规范。</li><li>现在学习的是HTML4.0.1这个版本，这个版本是 IE6开始兼容的。HTML5是 IE9开始兼容的。但是 IE6、7、8还不能过早的淘汰，所以这几年（2015年底的观点）的网页还是用 HTML4.0.1来制作。</li><li>HTML4.0.1中有两大种规范，每种又有3种小规范。即共6种规范。</li><li>HTML4.0.1中规定了普通和 XHTML两大种规范：<ul><li>HTML觉得自己的一些规定不太严谨，比如标签是否应该用大写。所以 HTML 又制定了一个严格版本 XHTML。</li></ul></li></ul><table><thead><tr><th>小规范</th><th>描述</th><th>HTML4.0.1</th><th>XHTML1.0</th></tr></thead><tbody><tr><td>Strict</td><td>表示严格的。有些标签不能使用。比如 u 标签，让文本加上下划线，这和 HTML 的本质有冲突，所以在 strict 中不能使用 u 标签。</td><td></td><td></td></tr><tr><td>Transitional</td><td>普通的</td><td></td><td></td></tr><tr><td>Frameset</td><td>带有框架的页面</td><td></td><td></td></tr><tr><td>##### 2、字符集</td><td></td><td></td><td></td></tr><tr><td>- 字符集用 meta 标签定义，meta 表示“元”，“元配置”就表示项目的基本配置。</td><td></td><td></td><td></td></tr><tr><td>```</td><td></td><td></td><td></td></tr><tr><td>&lt;meta http-equiv=”Content-Type”content=”text/html;charset=UTF-8”</td><td></td><td></td><td></td></tr><tr><td>```</td><td></td><td></td><td></td></tr><tr><td>- 中文能够使用的字符集有2种：UTF-8和gb2312（GBK 也合法）.</td><td></td><td></td><td></td></tr><tr><td>##### 3、关键字和页面描述</td><td></td><td></td><td></td></tr><tr><td>- meta 除了可以设置字符集，还可以设置关键字和页面描述</td><td></td><td></td><td></td></tr><tr><td>- 页面描述：只要Description，那么百度搜索结果就能显示这些语句，这个技术叫 SEO（search engine optimization）搜索引擎优化</td><td></td><td></td><td></td></tr></tbody></table><pre><code>&lt;meta name=&quot;Description&quot; content=&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot; /&gt;</code></pre><ul><li>关键词：提高搜索命中率</li></ul><pre><code>&lt;meta name=&quot;Keywords&quot; content=&quot;网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信,数码,汽车,手机,财经,科技,相册&quot; /&gt;</code></pre><ul><li>基本骨架</li></ul><pre><code> &lt;!DOCTYPE HTML&gt; &lt;html&gt;    &lt;head&gt;&lt;/head&gt;    &lt;body&gt;&lt;/body&gt; &lt;/html&gt;</code></pre><hr><h3 id="HTML-基本语法"><a href="#HTML-基本语法" class="headerlink" title="HTML 基本语法"></a>HTML 基本语法</h3><ul><li>1、HTML标签是分等级的。HTML 将标签分为容器级和文本级。容器级可以放任何东西。文本级只能放文字、图片和表单元素。</li><li>2、P 标签是文本级标签。</li><li>3、H 是容器级标签。理论上可以放置p，ul，但不建议使用。</li><li>4、页面可以插入图片的类型为：JPG，JPEG，GIF，png，bmp。不支持的类型为 PSD，ai。&lt;img为单标签，src 是 source 的缩写，Alt 是alternate，替代的意思。当图片无法显示的时候，显示该文字。</li></ul><pre><code>&lt;img src=&quot;imgs/2.png&quot; alt=&quot;图片加载失败&quot;&gt;</code></pre><ul><li><p>5、超链接：a 为 anchor，表示为锚，href是hypertext  reference。title 为鼠标悬停文本。target 为新建一个空白标签页打开，默认在当前标签页打开。</p><pre><code>&lt;a href=&quot;20180105hef.html&quot; title=&quot;点击有惊喜&quot;target=&quot;_blank&quot;&gt;前往&lt;/a&gt;</code></pre></li><li><p>6、页面内锚点跳转：可以使用 name，也可以使用 id</p><pre><code>&lt;p&gt;&lt;a href=&quot;#wizg&quot;title=&quot;点击有惊喜&quot;&gt;看我的简历&lt;/a&gt;&lt;/p&gt;&lt;a name=&quot;wizg&quot;&gt;我爱中国的理由&lt;/a&gt;</code></pre></li><li><p>7、跨页面内锚点跳转：</p><pre><code>&lt;a href=&quot;20180105_缩进.html#wizg&quot;&gt;为人民服务&lt;/a&gt;</code></pre></li><li><p>8、a 是个文本级标签。</p><h4 id="body属性"><a href="#body属性" class="headerlink" title="body属性"></a>body属性</h4></li></ul><pre><code>&lt;body bgcolor=&quot;red&quot; background=&quot;1.png&quot;&gt;</code></pre><h4 id="font"><a href="#font" class="headerlink" title="font"></a>font</h4><pre><code>&lt;font size=&quot;15&quot; color=&quot;red&quot;&gt;    &lt;i&gt; 斜体        &lt;u&gt;下划线            &lt;b&gt;加粗                &lt;s&gt;删除线                    &lt;sub&gt;下标线                        刘星星要努力学习                    &lt;/sub&gt;                &lt;/s&gt;            &lt;/b&gt;        &lt;/u&gt;    &lt;/i&gt;&lt;/font&gt;</code></pre><ul><li>上标和下标的作用：（设置摄氏度和化学式）</li></ul><pre><code>&lt;font size=&quot;15&quot; color=&quot;red&quot;&gt;    今天25&lt;sup&gt;o&lt;/sup&gt;C&lt;/font&gt;&lt;font size=&quot;15&quot; color=&quot;red&quot;&gt;    H&lt;sub&gt;2&lt;/sub&gt;O&lt;/font&gt;</code></pre><h4 id="div和span标记"><a href="#div和span标记" class="headerlink" title="div和span标记"></a>div和span标记</h4><ul><li>div是双标记，没有任何意义的块元素。div里面可以放任何元素</li><li>span是没有任何元素的行内元素。<blockquote><p>块元素：不管内容多少，都只占浏览器的一行</p></blockquote></li></ul><h4 id="图片标记"><a href="#图片标记" class="headerlink" title="图片标记"></a>图片标记</h4><ul><li>如果需要按照原来的比例进行缩小或者放大，只需单独设置宽或者高即可。</li></ul><pre><code>&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;1.png&quot; alt=&quot;desktop&quot; width=&quot;500&quot; border=&quot;2&quot;&gt;&lt;/div&gt;</code></pre><h4 id="图片热点"><a href="#图片热点" class="headerlink" title="图片热点"></a>图片热点</h4><ul><li>作用：在图片中添加可以点击的链接</li><li>shape:rect circle poly<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>desktop<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">usemap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goto<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0,0,200,200<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.baidu.com<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>点击跳转<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span></code></pre><h4 id="滚动标记"><a href="#滚动标记" class="headerlink" title="滚动标记"></a>滚动标记</h4></li><li>behavior属性的参数值为alternate、scroll、slide中的一个，分别表示文字来回滚动、单方向循环滚动、只滚动一次，需要注意的是：如果在<marquee>标签中同时出现了direction和behavior属性，那么scroll和slide的滚动方向将依照direction属性中参数的设置。<pre><code></code></pre></marquee></li></ul><p><marquee behavior="slide" direction="right">我来回滚动</marquee></p><pre><code>#### 多媒体标记- 不好用，一般放flash（.swf）文件</code></pre><embed src="1.png" type>```#### 锚点链接- 当前页面跳转当前页面：```<a name="top"></a><a href="#top">回到顶部</a>```- 当前页面跳转另一页面(./表示当前目录)：```<a name="top"></a><a href="./new.html#top">前往news</a>```]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML入门</title>
      <link href="/2018/01/14/2018-01-14-html-ru-men/"/>
      <url>/2018/01/14/2018-01-14-html-ru-men/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h4><blockquote><p>HTML:HyperTextMarkup Language,超文本标记语言。即描述文档语义的语言。HTML能够通过标签给文本增加语义，这是 HTML 唯一能够做的。这些标签在浏览器中是看不到的，所以称为“超文本”，也就是“超文本标记语言”了。</p><p>现在的标准是，HTML 负责描述页面的语义，CSS负责描述页面的样式，js负责描述页面的动态效果。 </p><p>HTML:超文本标记语言，从语义的角度描述页面结构。</p><p>CSS:层叠样式表，     从审美的角度描述页面样式。</p><p>JS:JavaScript，      从交互的角度描述页面行为。</p></blockquote><p>比如问： h1标签有什么作用？</p><p>答：给文本增加主标题的语义。</p><h5 id="涨姿势的系统名称"><a href="#涨姿势的系统名称" class="headerlink" title="涨姿势的系统名称"></a>涨姿势的系统名称</h5><blockquote><p>ERP: Enterprise resouce planning 企业资源计划<br>CRM：custom relationship management 客户管理系统<br>CMS: content management system 内容管理系统 </p></blockquote><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><blockquote><p>无序列表，用来表示一个列表的语义，表示每个项和项之间是不分先后排名的。ul：unordered list。li：list item，列表项</p><pre><code>        ul {            list-style: none;        }</code></pre></blockquote><ul>    <li></li></ul>```##### 有序列表<blockquote><p>ol：ordered list。li：list item，列表项。ol 用的场景不多，一般都是用 ul。li 是容器级标签，但不能说 ol 是容器级标签。</p><pre><code></code></pre></blockquote><ol>    <li></li></ol>```##### 定义列表<blockquote><p>定义列表也是一个组标签。不过比较复杂，共3个标签。dl: definition list dt:definition title dd:definition description。</p><pre><code></code></pre></blockquote><dl>    <dt>北京< /dt>    <dd>国家的首都</dd></dt></dl>```<h4 id="表单的使用"><a href="#表单的使用" class="headerlink" title="表单的使用"></a>表单的使用</h4><pre><code>&lt;form action=&quot;提交地址&quot; method=&quot;提交方式&quot;&gt;&lt;/form&gt;</code></pre><h5 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h5><p>input标签的type常用的有：</p><p>1.文本类型.属性有：disabled（不可操作）、readonly（只读）、placeholder（默认提示文字):</p><pre><code>&lt;input type=&quot;text&quot;&gt;</code></pre><p>2.密码框 password:</p><pre><code>密码：&lt;input type=&quot;password&quot;&gt;</code></pre><p>3.单选框radio：</p><pre><code>性别：&lt;input type=&quot;radio&quot;&gt;男　　  &lt;input type=&quot;radio&quot;&gt;女</code></pre><p>4.复选框checkbox：</p><pre><code>爱好：&lt;input type=&quot;checkbox&quot;&gt;编程　　　&lt;input type=&quot;checkbox&quot;&gt;跑步　　  &lt;input type=&quot;checkbox&quot;&gt;看书</code></pre><h5 id="下拉列表-select"><a href="#下拉列表-select" class="headerlink" title="下拉列表 select"></a>下拉列表 select</h5><p>select和 ul ol dl 一样，都是组标签：</p><pre><code>&lt;select&gt;    &lt;option&gt;河南&lt;/option&gt;    &lt;option&gt;河北&lt;/option&gt;    &lt;option&gt;湖南&lt;/option&gt;    &lt;option&gt;湖北&lt;/option&gt;    &lt;option&gt;江西&lt;/option&gt;    &lt;option&gt;广东&lt;/option&gt;&lt;/select&gt;</code></pre><h5 id="留言框textarea"><a href="#留言框textarea" class="headerlink" title="留言框textarea"></a>留言框textarea</h5><pre><code>&lt;textarea name=&#39;&#39; id=&#39;&#39; cols=&#39;30&#39; rows=&#39;10&#39;&gt;&lt;/textarea&gt;</code></pre><h5 id="按钮Button"><a href="#按钮Button" class="headerlink" title="按钮Button"></a>按钮Button</h5><p>普通button：</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;点我获取更多&quot;&gt;</code></pre><p>提交按钮 submit：</p><pre><code>&lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;&gt;</code></pre><p>重置按钮reset:</p><pre><code>&lt;input type=&quot;reset&quot; value=&quot;清空&quot;&gt;</code></pre><h5 id="label便签"><a href="#label便签" class="headerlink" title="label便签"></a>label便签</h5><p>现象：选择性别时，点击文字不能够勾选对应的选项。</p><p>原因：男 和女 两个汉字和 input元素没有关系。</p><pre><code>请选择您的性别：&lt;input type=&#39;radio&#39; name=&#39;sex&#39;/&gt;男&lt;input type=&#39;radio&#39; name=&#39;sex&#39;/&gt;女</code></pre><p>解决办法：</p><blockquote><p>因为label和input并没有嵌套关系，如果需要使input和label绑定到一起，需要在input中绑定id，在label中使用for来绑定。</p></blockquote><pre><code>请选择您的性别：&lt;input type=&#39;radio&#39; name=&#39;sex&#39; id=&#39;nan&#39; checked=&#39;checked&#39;/&gt;&lt;label for=&#39;nan&#39;&gt;男&lt;/label&gt;&lt;input type=&#39;radio&#39; name=&#39;sex&#39; id=&#39;nv&#39;/&gt;&lt;label for=&#39;nv&#39;&gt;女&lt;/label&gt;</code></pre><blockquote><p> 如果是嵌套关系，则不需要通过id来绑定了。当然，加上去也没有关系。</p></blockquote><pre><code> &lt;label &gt;男&lt;input type=&quot;radio&quot;  name=&quot;sex&quot;/&gt;&lt;/label&gt;    &lt;label &gt;女&lt;input type=&quot;radio&quot;  name=&quot;sex&quot; checked/&gt;&lt;/label&gt;</code></pre><h4 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h4><p>想在页面输出&lt;h1&gt;这样的字符，但 HTML 会把其解析为一个标签。那么就需要用到字符实体了：</p><pre><code>&amp;lt; &lt;      less than 小于的意思&amp;gt; &gt;      greater than 大于的意思&amp;nbsp;      空格&amp;amp;       &amp;&quot;           &amp;quot;</code></pre><h4 id="HTML-的废弃标签介绍"><a href="#HTML-的废弃标签介绍" class="headerlink" title="HTML 的废弃标签介绍"></a>HTML 的废弃标签介绍</h4><pre><code>&lt;font size=&#39;7&#39; color=&#39;red&#39;&gt;哈哈&lt;/font&gt;   最大到7</code></pre><p>标签b u i del em 这些标签现在都作为 CSS 的钩子使用，而不是原来的语意：</p><pre><code>&lt;b&gt;加粗&lt;/b&gt;</code></pre><pre><code>&lt;u&gt;下划线&lt;/u&gt;</code></pre><pre><code>&lt;i&gt;倾斜&lt;/i&gt;</code></pre><pre><code>&lt;del&gt;删除线&lt;/del&gt;</code></pre><pre><code>&lt;hr/&gt; 画一个水平线 </code></pre><pre><code>&lt;em&gt;强调&lt;/em&gt;   倾斜的字体 &lt;strong&gt;强调&lt;/strong&gt; 加粗的字体</code></pre><h5 id="总结文本标签："><a href="#总结文本标签：" class="headerlink" title="总结文本标签："></a>总结文本标签：</h5><pre><code>    加粗：b（&lt;b&gt;内容&lt;/b&gt;），strong（&lt;strong&gt;内容&lt;/strong&gt;）    倾斜：i（&lt;i&gt;内容&lt;/i&gt;），em（&lt;em&gt;内容&lt;/em&gt;）    删除线：del（&lt;del&gt;内容&lt;/del&gt;），s（&lt;s&gt;内容&lt;/s&gt;）    下划线：u（&lt;u&gt;内容&lt;/u&gt;），ins（&lt;ins&gt;内容&lt;ins&gt;）    变大：big：&lt;big&gt;内容&lt;/big&gt;；115%    变小：small：&lt;small&gt;内容&lt;/small&gt;；85%    上标：sup：&lt;sup&gt;内容&lt;/sup&gt;    下标：sub：&lt;sub&gt;内容&lt;/sub&gt;    字体：font（&lt;font&gt;内容&lt;/font&gt;）属性【color颜色，size大小，face样式】书名为：&amp;lt;坏蛋是怎样炼成的&amp;gt;价格是&amp;yen;55,&amp;copy;清华大学</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通讯录的基本使用</title>
      <link href="/2018/01/09/2018-01-09-tong-xun-lu-de-ji-ben-shi-yong/"/>
      <url>/2018/01/09/2018-01-09-tong-xun-lu-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h4 id="获取系统的通讯录参考博客"><a href="#获取系统的通讯录参考博客" class="headerlink" title="获取系统的通讯录参考博客"></a><a href="https://www.jianshu.com/p/55d1c90f62c8" target="_blank" rel="noopener">获取系统的通讯录参考博客</a></h4><h4 id="参考博客2"><a href="#参考博客2" class="headerlink" title="参考博客2"></a><a href="https://www.jianshu.com/p/6acad14cf3c9" target="_blank" rel="noopener">参考博客2</a></h4><pre><code>////  ViewController.m//  通讯录Demo////  Created by szphsw4 on 2018/1/4.//  Copyright © 2018年 PH. All rights reserved.//#import &quot;ViewController.h&quot;#import &lt;AddressBookUI/ABPeoplePickerNavigationController.h&gt;#import &lt;AddressBook/ABPerson.h&gt;#import &lt;AddressBookUI/ABPersonViewController.h&gt;@interface ViewController ()&lt;ABPeoplePickerNavigationControllerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];}- (IBAction)testForIos9Before {// 创建联系人选择控制器ABPeoplePickerNavigationController *pvc = [[ABPeoplePickerNavigationController alloc] init];pvc.peoplePickerDelegate = self;//在iOS8之后，需要添加nav.predicateForSelectionOfPerson = [NSPredicate predicateWithValue:false];这一段代码，否则选择联系人之后会直接dismiss，不能进入详情选择电话。pvc.predicateForSelectionOfPerson = [NSPredicate predicateWithValue:false];if (ABAddressBookGetAuthorizationStatus() == kABAuthorizationStatusNotDetermined){ABAddressBookRef bookRef = ABAddressBookCreate();ABAddressBookRequestAccessWithCompletion(bookRef, ^(bool granted, CFErrorRef error) {if (granted){NSLog(@&quot;授权成功!&quot;);[self presentViewController:pvc animated:YES completion:nil];}else{NSLog(@&quot;授权失败!&quot;);}});} else if (ABAddressBookGetAuthorizationStatus() == kABAuthorizationStatusAuthorized){[self presentViewController:pvc animated:YES completion:nil];}}//// 选择某个联系人时调用//- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController*)peoplePicker didSelectPerson:(ABRecordRef)person {//    NSLog(@&quot;选中联系人&quot;);//    CFStringRef firstName = ABRecordCopyValue(person, kABPersonFirstNameProperty);//    CFStringRef lastName = ABRecordCopyValue(person, kABPersonLastNameProperty);//    NSString *fir = CFBridgingRelease(firstName);//    NSString *las = CFBridgingRelease(lastName);//    NSLog(@&quot;%@---%@&quot;, fir, las);//    ABMultiValueRef multi = ABRecordCopyValue(person, kABPersonPhoneProperty);//    CFIndex count = ABMultiValueGetCount(multi);//    for (int i = 0; i  &lt; count; i++)//    {//        NSString *label = (__bridge_transfer NSString *)ABMultiValueCopyLabelAtIndex(multi, i);//        NSString *phone =(__bridge_transfer NSString *)  ABMultiValueCopyValueAtIndex(multi, i);//        NSLog(@&quot;%@---%@&quot;, label, phone);//    }//}////点击联系人//- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController*)peoplePicker didSelectPerson:(ABRecordRef)person {//    ABPersonViewController *personViewController = [[ABPersonViewController alloc] init];//    personViewController.displayedPerson = person;//    [peoplePicker pushViewController:personViewController animated:YES];//}//取消选择- (void)peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)peoplePicker {NSLog(@&quot;取消选择&quot;);[peoplePicker dismissViewControllerAnimated:YES completion:nil];}- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier {ABMultiValueRef phone = ABRecordCopyValue(person, kABPersonPhoneProperty);long index = ABMultiValueGetIndexForIdentifier(phone,identifier);NSString *phoneNO = (__bridge NSString *)ABMultiValueCopyValueAtIndex(phone, index);if ([phoneNO hasPrefix:@&quot;+&quot;]) {phoneNO = [phoneNO substringFromIndex:3];}phoneNO = [phoneNO stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;];NSLog(@&quot;___%@&quot;, phoneNO);}@end</code></pre><hr><h5 id="教学代码"><a href="#教学代码" class="headerlink" title="教学代码"></a>教学代码</h5><pre><code>////  ViewController.m//  01-通信录(有UI界面)////  Created by apple on 15-1-23.//  Copyright (c) 2015年 itcast. All rights reserved.//#import &quot;ViewController.h&quot;#import &lt;AddressBookUI/AddressBookUI.h&gt;@interface ViewController () &lt;ABPeoplePickerNavigationControllerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];}- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{// 1.创建ABPeoplePickerNavigationController控制器ABPeoplePickerNavigationController *ppnc = [[ABPeoplePickerNavigationController alloc] init];// 2.设置代理ppnc.peoplePickerDelegate = self;// 3.弹出控制器[self presentViewController:ppnc animated:YES completion:nil];}#pragma mark - ABPeoplePickerNavigationController的代理方法// =================================iOS8=================================/***  选中某一个联系人的时候会调用该方法**  @param person       选中的联系人*/- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person{// 1.取出联系人的姓名NSString *firstName = (__bridge_transfer NSString *)ABRecordCopyValue(person, kABPersonFirstNameProperty);NSString *lastName = (__bridge_transfer NSString *)ABRecordCopyValue(person, kABPersonLastNameProperty);NSLog(@&quot;firstName:%@ lastName:%@&quot;, firstName, lastName);// 2.取出联系人的电话ABMultiValueRef phones = ABRecordCopyValue(person, kABPersonPhoneProperty);CFIndex phoneCount = ABMultiValueGetCount(phones);for (int i = 0; i &lt; phoneCount; i++) {NSString *phoneLabel = (__bridge_transfer NSString *)ABMultiValueCopyLabelAtIndex(phones, i);NSString *phoneValue = (__bridge_transfer NSString *)ABMultiValueCopyValueAtIndex(phones, i);NSLog(@&quot;%@--%@&quot;, phoneLabel, phoneValue);}// 3.释放不需要的对象CFRelease(phones);}/***  选中某一个联系人的某一个属性的时候会调用该方法**  @param person       选中的联系人*  @param property     选中的属性*  @param identifier   属性对应的标识符*/- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier{}// =================================iOS7=================================- (BOOL)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker shouldContinueAfterSelectingPerson:(ABRecordRef)person{// 退出控制器[peoplePicker dismissViewControllerAnimated:YES completion:nil];return NO;}- (BOOL)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker shouldContinueAfterSelectingPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier{return YES;}/***  当点击取消按钮的时候会调用该方法*/- (void)peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)peoplePicker{[peoplePicker dismissViewControllerAnimated:YES completion:nil];}@end</code></pre><hr><h5 id="无界面"><a href="#无界面" class="headerlink" title="无界面"></a>无界面</h5><pre><code>////  ViewController.m//  02-通信录(无界面)////  Created by apple on 15-1-23.//  Copyright (c) 2015年 itcast. All rights reserved.//#import &quot;ViewController.h&quot;#import &lt;AddressBook/AddressBook.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad {[super viewDidLoad];}- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{// 1.创建一个通信录对象ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, NULL);// 2.获取通信录中所有联系人CFArrayRef peopleArray = ABAddressBookCopyArrayOfAllPeople(addressBook);CFIndex peopleCount = CFArrayGetCount(peopleArray);for (int i = 0; i &lt; peopleCount; i++) {// 3.获取到联系人ABRecordRef person = CFArrayGetValueAtIndex(peopleArray, i);// 4.获取联系人的姓名NSString *firstName = (__bridge_transfer NSString *)ABRecordCopyValue(person, kABPersonFirstNameProperty);NSString *lastName = (__bridge_transfer NSString *)ABRecordCopyValue(person, kABPersonLastNameProperty);NSLog(@&quot;%@ -- %@&quot;, firstName, lastName);// 5.获取联系人的电话信息ABMultiValueRef phones = ABRecordCopyValue(person, kABPersonPhoneProperty);CFIndex phoneCount = ABMultiValueGetCount(phones);for (CFIndex i = 0; i &lt; phoneCount; i++) {NSString *phoneLabel = (__bridge_transfer NSString *)ABMultiValueCopyLabelAtIndex(phones, i);NSString *phoneValue = (__bridge_transfer NSString *)ABMultiValueCopyValueAtIndex(phones, i);NSLog(@&quot;%@--%@&quot;, phoneLabel, phoneValue);}// 6.释放不需要的对象CFRelease(phones);}// 7.释放不需要的对象CFRelease(addressBook);CFRelease(peopleArray);}@end</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> 通讯录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中cocoapods的使用总结</title>
      <link href="/2017/11/01/2017-11-01-ios-zhong-cocoapods-de-shi-yong-zong-jie/"/>
      <url>/2017/11/01/2017-11-01-ios-zhong-cocoapods-de-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="cocoapods的使用"><a href="#cocoapods的使用" class="headerlink" title="cocoapods的使用"></a>cocoapods的使用</h2><p>我们可以从<a href="https://guides.cocoapods.org/using/getting-started.html" target="_blank" rel="noopener">官网</a>获取更为完整的信息,也可以从GitHub上<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="noopener">了解更多</a>。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>打开终端：</p><pre><code>sudo gem install cocoapodscd ~vim .bash_profile//配置 .bash_profileexport GEM_HOME=$HOME/.gemexport PATH=$GEM_HOME/bin:$PATH</code></pre><p>更新操作也是同样的命令：</p><pre><code>sudo gem install cocoapods</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>cd到xcode项目的根目录下初始化Proflie文件：</p><pre><code>pod init </code></pre><p>添加所需要的依赖：</p><pre><code>target &#39;MyApp&#39; do  pod &#39;AFNetworking&#39;, &#39;~&gt; 3.0&#39;  pod &#39;FBSDKCoreKit&#39;, &#39;~&gt; 4.9&#39;end</code></pre><p>运行<code>pod install</code>即可。</p><h4 id="pod-install-vs-pod-update"><a href="#pod-install-vs-pod-update" class="headerlink" title="pod install vs. pod update"></a>pod install vs. pod update</h4><p>很多人以为，<code>pod install</code>仅仅在自己第一次创建项目的时候使用，而后续的操作更新都是使用 <code>pod update</code>。但实际上这种想法并不完全正确。</p><h5 id="pod-install"><a href="#pod-install" class="headerlink" title="pod install"></a>pod install</h5><p>当你为项目添加新的pods依赖或者删除已有pods的时候，你应该使用<code>pod install</code>。也就是说，除了初始化项目时需要<code>pod install</code>外，当你在以后的开发中操作了Profile文件的时候，你应该使用<code>pod install</code>。</p><blockquote><p>当第一次运行Podfile文件时，会自动生成一个Podfile.lock文件，Podfile.lock会记录你使用的pods的版本并进行版本track。以后每次运行pod install命令的时候，它都会去按照Podfile.lock文件去下载指定版本的依赖（不会尝试检查是否有新的依赖版本）。对于新增的依赖，由于没有添加到Podfile.lock中，会匹配最新的依赖（如果没有指定新加入的依赖版本的话）然后更新到Podfile.lock中。</p></blockquote><h5 id="pod-update"><a href="#pod-update" class="headerlink" title="pod update"></a>pod update</h5><p>我们使用<code>pod update</code>的场景，只在我们需要更新依赖到新的版本的时候。比如，我们可以使用<code>pod update [PODNAME]</code>来指定更新某个依赖。当你使用该命令时，CocoaPods会忽略Podfile.lock中的版本，去将Pod更新到尽肯能新的版本（根据你在Podfile中做的版本限制情况）。如果没有指定更新pods的名字，而是直接运行<code>pod update</code>，那么cocoaPods会根据Podfile更新每一个依赖到尽可能新的版本。</p><h4 id="镜像问题"><a href="#镜像问题" class="headerlink" title="镜像问题"></a>镜像问题</h4><p>如果下载速度过慢，可以尝试切换镜像，例如<a href="https://mirror.tuna.tsinghua.edu.cn/help/CocoaPods/" target="_blank" rel="noopener">清华大学开源镜像站</a>。cocoapods切换镜像的方法：</p><pre><code> cd ~/.cocoapods/repos  pod repo remove master  git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master</code></pre><p>最后进入自己的工程，在自己工程的podFile第一行加上：</p><pre><code>source &#39;https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git&#39;</code></pre><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><a href="http://www.jianshu.com/p/6d8604f0b94c" target="_blank" rel="noopener">环境配置</a></h4><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>vim podfile</td><td>添加文件</td></tr><tr><td>pod search AFN</td><td>搜索</td></tr><tr><td>Podfile.lock</td><td>该文件用于保存已经安装的Pods依赖库的版本</td></tr><tr><td>pod update –no-repo-update</td><td>更新</td></tr><tr><td>pod env</td><td>查看已经安装的cocoapods版本。</td></tr><tr><td>pod outdated</td><td>查看Podfile文件中的依赖库的最新版本。</td></tr></tbody></table><pre><code>platform :ios,&#39;8.0&#39;target ‘BSPH’ dopod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;end</code></pre><hr><h3 id="建立远程仓库（2020年4月更新）"><a href="#建立远程仓库（2020年4月更新）" class="headerlink" title="建立远程仓库（2020年4月更新）"></a>建立远程仓库（2020年4月更新）</h3><p>首先，需要建立一个远程仓库，你可以选择码云或者其他代码托管平台。这里使用github做演示：</p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/39D78FA08ADC4AFE8F7A095070E3CF40/35048" alt="image"></p><p>打开终端，选择自己想要的目录<br>输入命令<code>pod lib create CoRep</code> ，通过pod创建一个项目，如下:</p><pre><code>pod lib create CoRep</code></pre><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/4AF7FCD5315945F1B35A73DE7E80A4EE/35055" alt="image"><br>稍后，会让你配置一些信息,当然后续你还有机会更改：</p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/C84C9EEF5D2D479489AB9DF74CE2EC10/35069" alt="image"></p><pre><code>你要使用哪个平台？ iOS你要使用哪种语言？ ObjC是否要使用示例？ YES使用哪个测试框架？ None是否要UI测试？ No类名前缀是啥？ HHY</code></pre><p>配置完成后，会自动启动xcode，我们可以看下创建的文件目录：</p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/3033FBB5BC474E9C9B16477C5962BAEC/35053" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/70567C1A33E64551882EF4BF6BA0BDF6/35086" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/8C2980F96F174081801AE2736BF93239/35090" alt="image"></p><blockquote><p>其中Example就是我们选择YES时创建的示例工程，CoRep就是我们存放仓库代码的位置，里面默认创建有Assets和Classes两个文件夹，我们的代码文件就放在Classes里，里面有一个叫做ReplaceMe.m的文件，提示我们后续替换掉它。图片资源文件则可以放在Assets里。另外还有生成的License证书和REAME文件。注意：CoRep.podspec是比较重要的一个文件，这是我们关联远程仓库的一个配置文件，我们刚才输入的配置，我们后续可以在里面进行部分修改。</p></blockquote><p>下一步，将要上传的文件放到Classes目录下：</p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/67A10AD5A9664ED1847E1D7BD78E9D8F/35088" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/3E4A90989E184254B0720F7C98D80EA9/35092" alt="image"></p><p>添加后，我们可以使用创建的测试项目进行测试。运行<code>pod install</code>，就可以引入我们之前的文件了。</p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/47B8117BE65640B69DED25D478E0255F/35094" alt="image"></p><h4 id="提交到Github仓库"><a href="#提交到Github仓库" class="headerlink" title="提交到Github仓库"></a>提交到Github仓库</h4><p>在测试项目中没有问题的话，下一步就将项目提交到github，然后打上tag：</p><pre><code>git tag 0.0.1git push origin 0.0.1</code></pre><h4 id="配置并验证CoRep-podspec文件"><a href="#配置并验证CoRep-podspec文件" class="headerlink" title="配置并验证CoRep.podspec文件"></a>配置并验证<code>CoRep.podspec</code>文件</h4><p>下一步，我们修改CoRep.podspec文件的配置：</p><pre><code>## Be sure to run `pod lib lint CoRep.podspec&#39; to ensure this is a# valid spec before submitting.## Any lines starting with a # are optional, but their use is encouraged# To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html#Pod::Spec.new do |s|  s.name             = &#39;CoRep&#39;  s.version          = &#39;0.0.1&#39;   s.summary          = &#39;CoRep&#39;# This description is used to generate tags and improve search results.#   * Think: What does it do? Why did you write it? What is the focus?#   * Try to keep it short, snappy and to the point.#   * Write the description between the DESC delimiters below.#   * Finally, don&#39;t worry about the indent, CocoaPods strips it!  s.description      = &#39;CoRep remote&#39; # 仓库主页地址  s.homepage         = &#39;https://github.com/smileasy/&#39;  # s.screenshots     = &#39;www.example.com/screenshots_1&#39;, &#39;www.example.com/screenshots_2&#39;  s.license          = { :type =&gt; &#39;MIT&#39;, :file =&gt; &#39;LICENSE&#39; }  s.author           = { &#39;刘二拐&#39; =&gt; &#39;lxxwork0827@163.com&#39; }  s.source           = { :git =&gt; &#39;https://github.com/smileasy/CoRep.git&#39;, :tag =&gt; &quot;#{s.version}&quot; }  # s.social_media_url = &#39;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#39;  s.ios.deployment_target = &#39;8.0&#39;  s.source_files = &#39;CoRep/Classes/**/*&#39;  # s.resource_bundles = {  #   &#39;CoRep&#39; =&gt; [&#39;CoRep/Assets/*.png&#39;]  # }  # s.public_header_files = &#39;Pod/Classes/**/*.h&#39;  # s.frameworks = &#39;UIKit&#39;, &#39;MapKit&#39;  # s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;end</code></pre><blockquote><p>这里的s.version，请跟我们在项目中打的tag保持一致。</p></blockquote><p>下一步，就是要将我们修改的<code>CoRep.podspec</code>文件上传到官方的Specs Repo上。</p><p>第一步，我们要验证我们的配置文件是否通过验证，输入命令：</p><pre><code>pod lib lint --allow-warnings</code></pre><p>等待返回结果。如果返回的结果是<code>CoRep passed validation.</code>，则证明验证没有问题。这里我们加了<code>--allow-warnings</code>，为的是让警告也通过验证，不然过不了验证。</p><h4 id="上传到cocoapods"><a href="#上传到cocoapods" class="headerlink" title="上传到cocoapods"></a>上传到cocoapods</h4><p>第一步，我们需要查看是否有注册过Cocoapods账号：</p><pre><code>pod trunk me</code></pre><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/16054FB1324C493F9B97DA1EE55014B1/35139" alt="image"></p><blockquote><p>如果报错<code>You need to register a session first.</code>，则说明我们需要注册。</p></blockquote><p>按照格式<code>pod trunk  register 邮箱地址 &#39;用户名&#39; --description=&#39;描述信息&#39;</code>输入注册命令：</p><pre><code>pod trunk register smileasy@foxmail.com &#39;smileasy&#39; --description=&#39;Cocoapods DESCRIPTION&#39;</code></pre><p>然后到自己的邮箱验证，再次<code>trunk me</code>,就可以看到成功的信息了。</p><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/AA8336123D404C4094483FD377DE3F75/35145" alt="image"></p><p>下一步，上传我们的<code>CoRep.podspec</code>：</p><pre><code>pod trunk push CoRep.podspec --allow-warnings</code></pre><p><img src="https://note.youdao.com/yws/public/resource/731f775e4394ed68a36c3d9ffab6fb48/xmlnote/1E113684A8F4495981378E63D148C897/35153" alt="image"></p><p>到这，我们建立Cocoapods远程仓库就完成了<a href="https://www.jianshu.com/p/9975a364b476" target="_blank" rel="noopener">参考博客</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVFoundation系统学习(一)</title>
      <link href="/2017/09/14/2017-09-14-avfoundation-xi-tong-xue-xi-1/"/>
      <url>/2017/09/14/2017-09-14-avfoundation-xi-tong-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer">## ```AVFoundation```系统学习<p>最近零零散散的看了点关于<code>AVFoundation</code>的资料，觉得很不系统，决定系统的学习一下。<a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/WhatisCoreAudio/WhatisCoreAudio.html#//apple_ref/doc/uid/TP40003577-CH3-SW10" target="_blank" rel="noopener">官方文档</a>，请点击这里查看。</p><ul><li>通过下面的图，我们可以知道<code>AVFoundation</code>的整体结构：</li></ul><p><img src="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Art/frameworksBlockDiagram_2x.png" alt="image"></p><h4 id="使用AVFoundation来播报文字"><a href="#使用AVFoundation来播报文字" class="headerlink" title="使用AVFoundation来播报文字"></a>使用<code>AVFoundation</code>来播报文字</h4><p>1、导入框架：</p><pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;</code></pre><p>2、初始化<code>AVSpeechSynthesizer</code></p><pre><code>@property (strong, nonatomic) AVSpeechSynthesizer *synthesizer;_synthesizer = [[AVSpeechSynthesizer alloc] init];</code></pre><p>3、初始化<code>AVSpeechUtterance</code>播报文字：</p><ul><li>我们在播放之前，还需要配置voice，这里我配置的是中文：</li></ul><pre><code>    _synthesizer = [[AVSpeechSynthesizer alloc] init];    NSString *str = @&quot;日照香炉生紫烟&quot;;    AVSpeechUtterance *utterance =    [[AVSpeechUtterance alloc] initWithString:str];    AVSpeechSynthesisVoice *voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;zh-CN&quot;];    utterance.voice = voice;    utterance.rate = 0.5f;    utterance.pitchMultiplier = 0.8f;    utterance.postUtteranceDelay = 0.1f;    [self.synthesizer speakUtterance:utterance];</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object-C </tag>
            
            <tag> 基础总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识iOS中的AudioToolbox框架</title>
      <link href="/2017/08/03/2017-08-03-chu-shi-ios-zhong-de-audiotoolbox-kuang-jia/"/>
      <url>/2017/08/03/2017-08-03-chu-shi-ios-zhong-de-audiotoolbox-kuang-jia/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><p><a href="http://www.cnblogs.com/kenshincui/p/4186022.html" target="_blank" rel="noopener">参考博客</a></p><ul><li>AudioToolbox.framework是一套基于C语言的框架，使用它来播放音效其本质是将短音频注册到系统声音服务（System Sound Service）。System Sound Service是一种简单、底层的声音播放服务，但是它本身也存在着一些限制：<ul><li>音频播放时间不能超过30s</li><li>数据必须是PCM或者IMA4格式</li><li>音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre class=" language-objc"><code class="language-objc">#import "ViewController.h"#import <AudioToolbox/AudioToolbox.h>@interface ViewController ()</code></pre></li></ul></li></ul><p>@end</p><p>@implementation ViewController</p><ul><li>(void)viewDidLoad {<br>  [super viewDidLoad];<br>  [self playSoundEffect:@”videoRing.caf”];<br>}</li><li>(void)playSoundEffect:(NSString <em>)name{<br>   NSString <em>audioFile = [[NSBundle mainBundle]pathForResource:name ofType:nil];<br>   NSURL *fileUrl = [NSURL fileURLWithPath:audioFile];<br>   //获得系统声音ID<br>   SystemSoundID soundID = 0;<br>   /</em></em><pre><code>* inFileUrl:音频文件url* outSystemSoundID:声音id（此函数会将音效文件加入到系统音频服务中并返回一个长整形ID）*/</code></pre>   AudioServicesCreateSystemSoundID((__bridge CFURLRef _Nonnull)(fileUrl), &amp;soundID);<br>   //如果需要在播放完之后执行某些操作，可以调用如下方法注册一个播放完成回调函数<br>   AudioServicesAddSystemSoundCompletion(soundID, NULL, NULL, soundCompleteCallback, NULL);<br>   //2.播放音频<br>   AudioServicesPlaySystemSound(soundID);//播放音效<br>   AudioServicesPlayAlertSound(soundID);//播放音效并震动<br>}<br>/**<ul><li>播放完成回调函数</li><li></li><li>@param soundID    系统声音ID</li><li>@param clientData 回调时传递的数据</li><li>/<br>void soundCompleteCallback(SystemSoundID soundID,void * clientData){<br>  NSLog(@”播放完成…”);<br>  AudioServicesDisposeSystemSoundID(soundID);<br>  CFRelease(clientData);<br>  CFRunLoopStop(CFRunLoopGetCurrent());<br>}<br>@end<pre><code></code></pre></li></ul></li></ul><hr><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><ul><li>如果播放较大的音频或者要对音频有精确的控制则System Sound Service可能就很难满足实际需求了，通常这种情况会选择使用AVFoundation.framework中的AVAudioPlayer来实现。AVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。首先简单看一下AVAudioPlayer常用的属性和方法：</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>@property(readonly, getter=isPlaying) BOOL playing</td><td>是否正在播放，只读</td></tr><tr><td>@property(readonly) NSUInteger numberOfChannels</td><td>音频声道数，只读</td></tr><tr><td>@property(readonly) NSTimeInterval duration</td><td>音频时长</td></tr><tr><td>@property(readonly) NSURL *url</td><td>音频文件路径，只读</td></tr><tr><td>@property(readonly) NSData *data</td><td>音频数据，只读</td></tr><tr><td>@property float pan</td><td>立体声平衡，如果为-1.0则完全左声道，如果0.0则左右声道平衡，如果为1.0则完全为右声道</td></tr><tr><td>@property float volume</td><td>音量大小，范围0-1.0</td></tr><tr><td>@property BOOL enableRate</td><td>是否允许改变播放速率</td></tr><tr><td>@property float rate</td><td>播放速率，范围0.5-2.0，如果为1.0则正常播放，如果要修改播放速率则必须设置enableRate为YES</td></tr><tr><td>@property NSTimeInterval currentTime</td><td>当前播放时长</td></tr><tr><td>@property(readonly) NSTimeInterval deviceCurrentTime</td><td>输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加</td></tr><tr><td>@property NSInteger numberOfLoops</td><td>循环播放次数，如果为0则不循环，如果小于0则无限循环，大于0则表示循环次数</td></tr><tr><td>对象方法</td><td>说明</td></tr><tr><td>—</td><td>—</td></tr><tr><td>- (instancetype)initWithContentsOfURL:(NSURL <em>)url error:(NSError *</em>)outError</td><td>使用文件URL初始化播放器，注意这个URL不能是HTTP URL，AVAudioPlayer不支持加载网络媒体流，只能播放本地文件</td></tr><tr><td>- (instancetype)initWithData:(NSData <em>)data error:(NSError *</em>)outError</td><td>使用NSData初始化播放器，注意使用此方法时必须文件格式和文件后缀一致，否则出错，所以相比此方法更推荐使用上述方法或- (instancetype)initWithData:(NSData <em>)data fileTypeHint:(NSString *)utiString error:(NSError *</em>)outError方法进行初始化</td></tr><tr><td>- (BOOL)prepareToPlay;</td><td>加载音频文件到缓冲区，注意即使在播放之前音频文件没有加载到缓冲区程序也会隐式调用此方法。</td></tr><tr><td>- (BOOL)play;</td><td>播放音频文件</td></tr><tr><td>- (BOOL)playAtTime:(NSTimeInterval)time</td><td>在指定的时间开始播放音频</td></tr><tr><td>- (void)pause;</td><td>暂停播放</td></tr><tr><td>- (void)stop;</td><td>停止播放</td></tr><tr><td>- (void)updateMeters</td><td>更新音频测量值，注意如果要更新音频测量值必须设置meteringEnabled为YES，通过音频测量值可以即时获得音频分贝等信息</td></tr><tr><td>- (float)peakPowerForChannel:(NSUInteger)channelNumber;</td><td>获得指定声道的分贝峰值，注意如果要获得分贝峰值必须在此之前调用updateMeters方法</td></tr><tr><td>- (float)averagePowerForChannel:(NSUInteger)channelNumber</td><td>获得指定声道的分贝平均值，注意如果要获得分贝平均值必须在此之前调用updateMeters方法</td></tr><tr><td>@property(nonatomic, copy) NSArray *channelAssignments</td><td>获得或设置播放声道</td></tr><tr><td>代理方法</td><td>说明</td></tr><tr><td>—</td><td>—</td></tr><tr><td>- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag</td><td>音频播放完成</td></tr><tr><td>- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error</td><td>音频解码发生错误</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 音频框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简单的录音功能</title>
      <link href="/2017/08/01/2017-08-01-ios-shi-xian-yi-ge-jian-dan-de-lu-yin-gong-neng/"/>
      <url>/2017/08/01/2017-08-01-ios-shi-xian-yi-ge-jian-dan-de-lu-yin-gong-neng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="AVAudioRecorder"><a href="#AVAudioRecorder" class="headerlink" title="AVAudioRecorder"></a>AVAudioRecorder</h2><p><a href="http://www.cnblogs.com/kenshincui/p/4186022.html" target="_blank" rel="noopener">参考博客</a></p><ul><li>在AVFoundation框架中还要一个AVAudioRecorder类专门处理录音操作，它同样支持多种音频格式。与AVAudioPlayer类似，你完全可以将它看成是一个录音机控制类，下面是常用的属性和方法：</li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>@property(readonly, getter=isRecording) BOOL recording;</td><td>是否正在录音，只读</td></tr><tr><td>@property(readonly) NSURL *url</td><td>录音文件地址，只读</td></tr><tr><td>@property(readonly) NSDictionary *settings</td><td>录音文件设置，只读</td></tr><tr><td>@property(readonly) NSTimeInterval currentTime</td><td>录音时长，只读，注意仅仅在录音状态可用</td></tr><tr><td>@property(readonly) NSTimeInterval deviceCurrentTime</td><td>输入设置的时间长度，只读，注意此属性一直可访问</td></tr><tr><td>@property(getter=isMeteringEnabled) BOOL meteringEnabled;</td><td>是否启用录音测量，如果启用录音测量可以获得录音分贝等数据信息</td></tr><tr><td>@property(nonatomic, copy) NSArray *channelAssignments</td><td>当前录音的通道</td></tr><tr><td>对象方法</td><td>说明</td></tr><tr><td>- (instancetype)initWithURL:(NSURL <em>)url settings:(NSDictionary *)settings error:(NSError *</em>)outError</td><td>录音机对象初始化方法，注意其中的url必须是本地文件url，settings是录音格式、编码等设置</td></tr><tr><td>- (BOOL)prepareToRecord</td><td>准备录音，主要用于创建缓冲区，如果不手动调用，在调用record录音时也会自动调用</td></tr><tr><td>- (BOOL)record</td><td>开始录音</td></tr><tr><td>- (BOOL)recordAtTime:(NSTimeInterval)time</td><td>在指定的时间开始录音，一般用于录音暂停再恢复录音</td></tr><tr><td>- (BOOL)recordForDuration:(NSTimeInterval) duration</td><td>按指定的时长开始录音</td></tr><tr><td>- (BOOL)recordAtTime:(NSTimeInterval)time forDuration:(NSTimeInterval) duration</td><td>在指定的时间开始录音，并指定录音时长</td></tr><tr><td>- (void)pause;</td><td>暂停录音</td></tr><tr><td>- (void)stop;</td><td>停止录音</td></tr><tr><td>- (BOOL)deleteRecording;</td><td>删除录音，注意要删除录音此时录音机必须处于停止状态</td></tr><tr><td>- (void)updateMeters;</td><td>更新测量数据，注意只有meteringEnabled为YES此方法才可用</td></tr><tr><td>- (float)peakPowerForChannel:(NSUInteger)channelNumber;</td><td>指定通道的测量峰值，注意只有调用完updateMeters才有值</td></tr><tr><td>- (float)averagePowerForChannel:(NSUInteger)channelNumber</td><td>指定通道的测量平均值，注意只有调用完updateMeters才有值</td></tr><tr><td>代理方法</td><td>说明</td></tr><tr><td>- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag</td><td>完成录音</td></tr><tr><td>- (void)audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)recorder error:(NSError *)error</td><td>录音编码发生错误</td></tr><tr><td>- AVAudioRecorder很多属性和方法跟AVAudioPlayer都是类似的,但是它的创建有所不同，在创建录音机时除了指定路径外还必须指定录音设置信息，因为录音机必须知道录音文件的格式、采样率、通道数、每个采样点的位数等信息，但是也并不是所有的信息都必须设置，通常只需要几个常用设置。关于录音设置详见帮助文档中的“AV Foundation Audio Settings Constants”。</td><td></td></tr><tr><td>- 在这个示例中将实行一个完整的录音控制，包括录音、暂停、恢复、停止，同时还会实时展示用户录音的声音波动，当用户点击完停止按钮还会自动播放录音文件。程序的构建主要分为以下几步：</td><td></td></tr><tr><td>- 1.设置音频会话类型为AVAudioSessionCategoryPlayAndRecord，因为程序中牵扯到录音和播放操作。</td><td></td></tr><tr><td>- 2.创建录音机AVAudioRecorder，指定录音保存的路径并且设置录音属性，注意对于一般的录音文件要求的采样率、位数并不高，需要适当设置以保证录音文件的大小和效果。</td><td></td></tr><tr><td>- 3.设置录音机代理以便在录音完成后播放录音，打开录音测量保证能够实时获得录音时的声音强度。（注意声音强度范围-160到0,0代表最大输入）</td><td></td></tr><tr><td>- 4.创建音频播放器AVAudioPlayer，用于在录音完成之后播放录音。</td><td></td></tr><tr><td>- 5.创建一个定时器以便实时刷新录音测量值并更新录音强度到UIProgressView中显示</td><td></td></tr><tr><td>- 6.添加录音、暂停、恢复、停止操作，需要注意录音的恢复操作其实是有音频会话管理的，恢复时只要再次调用record方法即可，无需手动管理恢复时间等</td><td></td></tr></tbody></table><pre><code>////  ViewController.m//  AVAudioRecorder////  Created by Kenshin Cui on 14/03/30.//  Copyright (c) 2014年 cmjstudio. All rights reserved.//#import &quot;ViewController.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;#define kRecordAudioFile @&quot;myRecord.caf&quot;@interface ViewController ()&lt;AVAudioRecorderDelegate&gt;@property (nonatomic,strong) AVAudioRecorder *audioRecorder;//音频录音机@property (nonatomic,strong) AVAudioPlayer *audioPlayer;//音频播放器，用于播放录音文件@property (nonatomic,strong) NSTimer *timer;//录音声波监控（注意这里暂时不对播放进行监控）@property (weak, nonatomic) IBOutlet UIButton *record;//开始录音@property (weak, nonatomic) IBOutlet UIButton *pause;//暂停录音@property (weak, nonatomic) IBOutlet UIButton *resume;//恢复录音@property (weak, nonatomic) IBOutlet UIButton *stop;//停止录音@property (weak, nonatomic) IBOutlet UIProgressView *audioPower;//音频波动@end@implementation ViewController#pragma mark - 控制器视图方法- (void)viewDidLoad {    [super viewDidLoad];    [self setAudioSession];}#pragma mark - 私有方法/** *  设置音频会话 */-(void)setAudioSession{    AVAudioSession *audioSession=[AVAudioSession sharedInstance];    //设置为播放和录音状态，以便可以在录制完之后播放录音    [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];    [audioSession setActive:YES error:nil];}/** *  取得录音文件保存路径 * *  @return 录音文件路径 */-(NSURL *)getSavePath{    NSString *urlStr=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];    urlStr=[urlStr stringByAppendingPathComponent:kRecordAudioFile];    NSLog(@&quot;file path:%@&quot;,urlStr);    NSURL *url=[NSURL fileURLWithPath:urlStr];    return url;}/** *  取得录音文件设置 * *  @return 录音设置 */-(NSDictionary *)getAudioSetting{    NSMutableDictionary *dicM=[NSMutableDictionary dictionary];    //设置录音格式    [dicM setObject:@(kAudioFormatLinearPCM) forKey:AVFormatIDKey];    //设置录音采样率，8000是电话采样率，对于一般录音已经够了    [dicM setObject:@(8000) forKey:AVSampleRateKey];    //设置通道,这里采用单声道    [dicM setObject:@(1) forKey:AVNumberOfChannelsKey];    //每个采样点位数,分为8、16、24、32    [dicM setObject:@(8) forKey:AVLinearPCMBitDepthKey];    //是否使用浮点数采样    [dicM setObject:@(YES) forKey:AVLinearPCMIsFloatKey];    //....其他设置等    return dicM;}/** *  获得录音机对象 * *  @return 录音机对象 */-(AVAudioRecorder *)audioRecorder{    if (!_audioRecorder) {        //创建录音文件保存路径        NSURL *url=[self getSavePath];        //创建录音格式设置        NSDictionary *setting=[self getAudioSetting];        //创建录音机        NSError *error=nil;        _audioRecorder=[[AVAudioRecorder alloc]initWithURL:url settings:setting error:&amp;error];        _audioRecorder.delegate=self;        _audioRecorder.meteringEnabled=YES;//如果要监控声波则必须设置为YES        if (error) {            NSLog(@&quot;创建录音机对象时发生错误，错误信息：%@&quot;,error.localizedDescription);            return nil;        }    }    return _audioRecorder;}/** *  创建播放器 * *  @return 播放器 */-(AVAudioPlayer *)audioPlayer{    if (!_audioPlayer) {        NSURL *url=[self getSavePath];        NSError *error=nil;        _audioPlayer=[[AVAudioPlayer alloc]initWithContentsOfURL:url error:&amp;error];        _audioPlayer.numberOfLoops=0;        [_audioPlayer prepareToPlay];        if (error) {            NSLog(@&quot;创建播放器过程中发生错误，错误信息：%@&quot;,error.localizedDescription);            return nil;        }    }    return _audioPlayer;}/** *  录音声波监控定制器 * *  @return 定时器 */-(NSTimer *)timer{    if (!_timer) {        _timer=[NSTimer scheduledTimerWithTimeInterval:0.1f target:self selector:@selector(audioPowerChange) userInfo:nil repeats:YES];    }    return _timer;}/** *  录音声波状态设置 */-(void)audioPowerChange{    [self.audioRecorder updateMeters];//更新测量值    float power= [self.audioRecorder averagePowerForChannel:0];//取得第一个通道的音频，注意音频强度范围时-160到0    CGFloat progress=(1.0/160.0)*(power+160.0);    [self.audioPower setProgress:progress];}#pragma mark - UI事件/** *  点击录音按钮 * *  @param sender 录音按钮 */- (IBAction)recordClick:(UIButton *)sender {    if (![self.audioRecorder isRecording]) {        [self.audioRecorder record];//首次使用应用时如果调用record方法会询问用户是否允许使用麦克风        self.timer.fireDate=[NSDate distantPast];    }}/** *  点击暂定按钮 * *  @param sender 暂停按钮 */- (IBAction)pauseClick:(UIButton *)sender {    if ([self.audioRecorder isRecording]) {        [self.audioRecorder pause];        self.timer.fireDate=[NSDate distantFuture];    }}/** *  点击恢复按钮 *  恢复录音只需要再次调用record，AVAudioSession会帮助你记录上次录音位置并追加录音 * *  @param sender 恢复按钮 */- (IBAction)resumeClick:(UIButton *)sender {    [self recordClick:sender];}/** *  点击停止按钮 * *  @param sender 停止按钮 */- (IBAction)stopClick:(UIButton *)sender {    [self.audioRecorder stop];    self.timer.fireDate=[NSDate distantFuture];    self.audioPower.progress=0.0;}#pragma mark - 录音机代理方法/** *  录音完成，录音完成后播放录音 * *  @param recorder 录音机对象 *  @param flag     是否成功 */-(void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag{    if (![self.audioPlayer isPlaying]) {        [self.audioPlayer play];    }    NSLog(@&quot;录音完成!&quot;);}@end</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 音频入门案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D touch的基本使用</title>
      <link href="/2017/07/30/2017-07-30-3dtouch-de-ji-ben-shi-yong/"/>
      <url>/2017/07/30/2017-07-30-3dtouch-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="3D-touch介绍"><a href="#3D-touch介绍" class="headerlink" title="3D touch介绍"></a>3D touch介绍</h2><ul><li>3D touch 是ios9+、iphone6s+的新功能，简单的说3Dtouch就是用力按压，通过3Dtouch增加了一组手势交互方式。3D touch主要常见的使用：</li><li>1：Home Screen Quick Actions （主屏快捷行为入口）</li><li>2：peek and pop （预览和弹出）</li><li>3：Force Properties （按压力度）</li><li>4: Web view peek and pop API (HTML链接预览功能)<h2 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h2></li><li>在主屏用力按压app图标，可以弹出一个快捷菜单，可以直接进入app的某个功能。文字和图片会因为app在主屏的位置（如左上或右下）决定弹出菜单的位置以及文字在左还是icon在左。</li><li>有两种方法可以实现Home Screen Quick Actions，一种是使用.plist文件静态声明，另一种是使用 UIApplicationShortcutItem 对象构造。 静态构造的quick actions可以在你的app第一次安装时候就有效果，而动态构造方法必须在第一次运行之后才能有效果，当然，好处就quick actions可以 随时更新和修改。<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW36" target="_blank" rel="noopener">官方文档</a></li></ul><pre class=" language-objc"><code class="language-objc"><key>UIApplicationShortcutItems</key><array><dict><!--标题--><key>UIApplicationShortcutItemTitle</key><string>New Message</string><!--副标题--><key>UIApplicationShortcutItemSubtitle</key><string>open-favorites</string><!--使用系统图标类型--><key>UIApplicationShortcutItemIconType</key><string>UIApplicationShortcutIconTypeCompose</string><!--  选项自定义icon--><!-- <key>UIApplicationShortcutItemIconFile</key><string></string>--><!-- icon文件的路径，必须使用项目内的资源文件 --><!--  app应用标识--><key>UIApplicationShortcutItemType</key><string>com.mycompany.myapp.newmessage</string><!--  可以用来传递一些数据--><key>UIApplicationShortcutItemUserInfo</key><dict><key>key2</key><string>value2</string></dict></dict><dict><key>UIApplicationShortcutItemIconFile</key><string>open-favorites</string><key>UIApplicationShortcutItemTitle</key><string>Favorites</string><key>UIApplicationShortcutItemType</key><string>com.mycompany.myapp.openfavorites</string><key>UIApplicationShortcutItemUserInfo</key><dict><key>key1</key><string>value1</string></dict></dict></array></code></pre><ul><li>代码添加</li></ul><pre class=" language-objc"><code class="language-objc">- (void)add3DTouch {UIApplicationShortcutIcon *icon1 = [UIApplicationShortcutIcon iconWithTemplateImageName:@"1"];UIMutableApplicationShortcutItem *item1 = [[UIMutableApplicationShortcutItem alloc]initWithType:@"item1" localizedTitle:@"钢铁侠" localizedSubtitle:@"最新大片" icon:icon1 userInfo:@{@"sub":@"最新大片1"}];UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon iconWithTemplateImageName:@"2"];UIMutableApplicationShortcutItem *item2 = [[UIMutableApplicationShortcutItem alloc]initWithType:@"item1" localizedTitle:@"黑寡妇" localizedSubtitle:@"最新大片" icon:icon2 userInfo:@{@"sub":@"最新大片2"}];UIApplicationShortcutIcon *icon3 = [UIApplicationShortcutIcon iconWithTemplateImageName:@"3"];UIMutableApplicationShortcutItem *item3 = [[UIMutableApplicationShortcutItem alloc]initWithType:@"item1" localizedTitle:@"美国队长" localizedSubtitle:@"最新大片" icon:icon3 userInfo:@{@"sub":@"最新大片3"}];UIApplicationShortcutIcon *icon4 = [UIApplicationShortcutIcon iconWithTemplateImageName:@"4"];UIMutableApplicationShortcutItem *item4 = [[UIMutableApplicationShortcutItem alloc]initWithType:@"item1" localizedTitle:@"雷神" localizedSubtitle:@"最新大片" icon:icon4 userInfo:@{@"sub":@"最新大片4"}];[[UIApplication sharedApplication]setShortcutItems:@[item1,item2,item3,item4]];}</code></pre><ul><li>选择不同的shortCutItem会调用该方法：</li></ul><pre class=" language-objc"><code class="language-objc">- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler {if ([shortcutItem.type isEqualToString:@"playItem"]) {NSLog(@"点击了playItem");//        FirstViewController *fvc = [[FirstViewController alloc] init];//        [self.window.rootViewController showViewController:fvc sender:nil];}if ([shortcutItem.type isEqualToString:@"shareItem"]) {NSLog(@"点击了shareItem");//        SecondViewController *svc = [[SecondViewController alloc] init];//        [self.window.rootViewController showViewController:svc sender:nil];}[_viewController.navigationController popToRootViewControllerAnimated:NO];_viewController.shortcutName =shortcutItem.localizedTitle;_viewController.info = shortcutItem.userInfo;[[NSNotificationCenter defaultCenter] postNotificationName:@"ShortCut" object:nil];}</code></pre><ul><li>向tableView中添加3DTouch,需要实现以下方法：</li></ul><pre class=" language-objc"><code class="language-objc">- (nullable UIViewController *)previewingContext:(id <UIViewControllerPreviewing>)previewingContext viewControllerForLocation:(CGPoint)location {NSIndexPath * indexPath =[_tableViewList indexPathForRowAtPoint:location];UITableViewCell * cell = [_tableViewList cellForRowAtIndexPath:indexPath];if (!cell) {return nil;}DetailViewController *detailVC =[[DetailViewController alloc]initWithTitle:[_arrayData objectAtIndex:indexPath.row]];detailVC.preferredContentSize = CGSizeMake(0, 0);previewingContext.sourceRect = cell.frame;return detailVC;//    UIViewController *vc = [[UIViewController alloc]init];//    vc.view.backgroundColor = [UIColor redColor];//    previewingContext.sourceRect = cell.frame;//    vc.preferredContentSize = CGSizeMake(200, 200);//    return vc;}</code></pre><pre><code>- (void)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit{[self.navigationController pushViewController:viewControllerToCommit animated:NO];}</code></pre><ul><li>实现上滑弹出选项,需要在目的控制器中实现：</li></ul><pre class=" language-objc"><code class="language-objc">- (NSArray <id <UIPreviewActionItem>> *)previewActionItems {UIPreviewAction *action = [UIPreviewAction actionWithTitle:@"赞" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {NSLog(@"点击了赞");}];UIPreviewAction *action2 = [UIPreviewAction actionWithTitle:@"吐槽" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {NSLog(@"点击了吐槽");}];return @[action,action2];}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> 3DTouch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中音频的理论知识</title>
      <link href="/2017/07/27/2017-07-27-ios-zhong-yin-pin-de-li-lun-zhi-shi/"/>
      <url>/2017/07/27/2017-07-27-ios-zhong-yin-pin-de-li-lun-zhi-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><a href="http://www.jianshu.com/p/8c7a616b30f1" target="_blank" rel="noopener">参考简书</a></p><ul><li>声波是一种机械波，是一种模拟信号。</li><li>PCM，全称脉冲编码调制，是一种模拟信号的数字化的方法。</li><li>采样精度（bit pre sample)，每个声音样本的采样位数。</li><li>采样频率（sample rate）每秒钟采集多少个声音样本。</li><li>声道（channel）：相互独立的音频信号数，单声道（mono）立体声（Stereo）</li><li>语音帧（frame），In audio data a frame is one sample across all channels.<h4 id="线性PCM："><a href="#线性PCM：" class="headerlink" title="线性PCM："></a>线性PCM：</h4><a href="http://www.jianshu.com/p/423726cc9090" target="_blank" rel="noopener">参考博客</a></li></ul><ul><li>这是表示线性脉冲编码调制，主要是描写用于将模拟声音数据转换成数字格式的技术。简单地说也就是未压缩的数据。因为数据是未压缩的，所以我们便可以最快速地播放出音频，而如果空间不是问题的话这便是iPhone音频的优先代码选择。<h4 id="音频文件计算大小"><a href="#音频文件计算大小" class="headerlink" title="音频文件计算大小"></a>音频文件计算大小</h4></li><li>声卡对声音的处理质量可以用三个基本参数来衡量，即采样频率、采样位数和声道数。</li><li>采样频率:<br>是指单位时间内的采样次数。采样频率越大，采样点之间的间隔就越小，数字化后得到的声音就越逼真，但相应的数据量就越大。声卡一般提供11.025kHz、22.05kHz和44.1kHz等不同的采样频率。</li><li>采样位数：<br>是记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。</li><li>声道数：是指处理的声音是单声道还是立体声。单声道在声音处理过程中只有单数据流，而立体声则需要左、右声道的两个数据流。显然，立体声的效果要好，但相应的数据量要比单声道的数据量加倍。</li><li>声音数据量的计算公式为：</li></ul><pre><code>数据量（字节/秒）= (采样频率（Hz）× 采样位数（bit）× 声道数)/ 8</code></pre><p>单声道的声道数为1，立体声的声道数为2。</p><pre><code>【例1】请计算对于5分钟双声道、16位采样位数、44.1kHz采样频率声音的不压缩数据量是多少？根据公式：数据量=（采样频率×采样位数×声道数×时间）/8得，数据量(MB)=[44.1×1000×16×2×（5×60）] /（8×1024×1024）=50.47MB计算时要注意几个单位的换算细节：时间单位换算：1分=60秒采样频率单位换算：1kHz=1000Hz数据量单位换算：1MB=1024×1024=1048576B</code></pre><pre><code>【例2】请计算对于双声道立体声、采样频率为44.1kHz、采样位数为16位的激光唱盘（CD-A），用一个650MB的CD-ROM可存放多长时间的音乐？已知音频文件大小的计算公式如下：文件的字节数/每秒=采样频率（Hz）X采样位数（位）X声道数/8根据上面的公式计算一秒钟时间内的不压缩数据量：(44.1×1000×16×2)/8=0.168MB/s那么，一个650MB的CD-ROM可存放的时间为：（650/0.168）/（60×60）=1.07小时。</code></pre><hr><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a href="http://msching.github.io/blog/2014/07/07/audio-in-ios/" target="_blank" rel="noopener">参考博客</a></p><ul><li>目前我们在计算机上进行音频播放都需要依赖于音频文件，音频文件的生成过程是将声音信息采样、量化和编码产生的数字信号的过程，人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，因此音频文件格式的最大带宽是20KHZ。根据奈奎斯特的理论，只有采样频率高于声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在40~50KHZ，比如最常见的CD音质采样率44.1KHZ。</li><li>对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation），简称PCM。PCM数据是最原始的音频数据完全无损，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，其中有无损压缩（ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种。</li><li>目前最为常用的音频格式是MP3，MP3是一种有损压缩的音频格式，设计这种格式的目的就是为了大幅度的减小音频的数据量，它舍弃PCM音频数据中人类听觉不敏感的部分，从下面的比较图我们可以明显的看到MP3数据相比PCM数据明显矮了一截（图片引自imp3论坛）。</li><li>MP3格式中的码率（BitRate）代表了MP3数据的压缩质量，现在常用的码率有128kbit/s、160kbit/s、320kbit/s等等，这个值越高声音质量也就越高。MP3编码方式常用的有两种固定码率(Constant bitrate，CBR)和可变码率(Variable bitrate，VBR)。</li><li>MP3格式中的数据通常由两部分组成，一部分为ID3用来存储歌名、演唱者、专辑、音轨数等信息，另一部分为音频数据。音频数据部分以帧(frame)为单位存储，每个音频都有自己的帧头，如图所示就是一个MP3文件帧结构图（图片同样来自互联网）。MP3中的每一个帧都有自己的帧头，其中存储了采样率等解码必须的信息，所以每一个帧都可以独立于文件存在和播放，这个特性加上高压缩比使得MP3文件成为了音频流播放的主流格式。帧头之后存储着音频数据，这些音频数据是若干个PCM数据帧经过压缩算法压缩得到的，对CBR的MP3数据来说每个帧中包含的PCM数据帧是固定的，而VBR是可变的。<h2 id="iOS音频播放概述"><a href="#iOS音频播放概述" class="headerlink" title="iOS音频播放概述"></a>iOS音频播放概述</h2></li><li>了解了基础概念之后我们就可以列出一个经典的音频播放流程（以MP3为例）：<ul><li>1.读取MP3文件</li><li>2.解析采样率、码率、时长等信息，分离MP3中的音频帧</li><li>3.对分离出来的音频帧解码得到PCM数据</li><li>4.对PCM数据进行音效处理（均衡器、混响器等，非必须）</li><li>5.把PCM数据解码成音频信号</li><li>6.把音频信号交给硬件播放</li><li>7.重复1-6步直到播放完成</li></ul></li><li>在iOS系统中apple对上述的流程进行了封装并提供了不同层次的接口（<a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/CoreAudioEssentials/CoreAudioEssentials.html#//apple_ref/doc/uid/TP40003577-CH10-SW1" target="_blank" rel="noopener">图片引自官方文档</a>）。</li></ul><p><img src="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/Art/core_audio_layers_2x.png" alt="CoreAudio的接口层次"></p><ul><li><p>下面对其中的中高层接口进行功能说明：</p><ul><li>Audio File Services：读写音频数据，可以完成播放流程中的第2步；</li><li>Audio File Stream Services：对音频进行解码，可以完成播放流程中的第2步；</li><li>Audio Converter services：音频数据转换，可以完成播放流程中的第3步；</li><li>Audio Processing Graph Services：音效处理模块，可以完成播放流程中的第4步；</li><li>Audio Unit Services：播放音频数据：可以完成播放流程中的第5步、第6步；</li><li>Extended Audio File Services：Audio File Services和Audio Converter services的结合体；</li><li>AVAudioPlayer/AVPlayer(AVFoundation)：高级接口，可以完成整个音频播放的过程（包括本地文件和网络流播放，第4步除外）；</li><li>Audio Queue Services：高级接口，可以进行录音和播放，可以完成播放流程中的第3、5、6步；</li><li>OpenAL：用于游戏音频播放，暂不讨论</li></ul></li><li><p>可以看到apple提供的接口类型非常丰富，可以满足各种类别类需求：</p><ul><li>如果你只是想实现音频的播放，没有其他需求AVFoundation会很好的满足你的需求。它的接口使用简单、不用关心其中的细节；</li><li>如果你的app需要对音频进行流播放并且同时存储，那么AudioFileStreamer加AudioQueue能够帮到你，你可以先把音频数据下载到本地，一边下载一边用NSFileHandler等接口读取本地音频文件并交给AudioFileStreamer或者AudioFile解析分离音频帧，分离出来的音频帧可以送给AudioQueue进行解码和播放。如果是本地文件直接读取文件解析即可。（这两个都是比较直接的做法，这类需求也可以用AVFoundation+本地server的方式实现，AVAudioPlayer会把请求发送给本地server，由本地server转发出去，获取数据后在本地server中存储并转送给AVAudioPlayer。另一个比较trick的做法是先把音频下载到文件中，在下载到一定量的数据后把文件路径给AVAudioPlayer播放，当然这种做法在音频seek后就回有问题了。）</li><li>如果你正在开发一个专业的音乐播放软件，需要对音频施加音效（均衡器、混响器），那么除了数据的读取和解析以外还需要用到AudioConverter来把音频数据转换成PCM数据，再由AudioUnit+AUGraph来进行音效处理和播放（但目前多数带音效的app都是自己开发音效模块来坐PCM数据的处理，这部分功能自行开发在自定义性和扩展性上会比较强一些。PCM数据通过音效器处理完成后就可以使用AudioUnit播放了，当然AudioQueue也支持直接使对PCM数据进行播放。）。下图描述的就是使用AudioFile + AudioConverter + AudioUnit进行音频播放的流程（<a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/ARoadmaptoCommonTasks/ARoadmaptoCommonTasks.html#//apple_ref/doc/uid/TP40003577-CH6-SW1" target="_blank" rel="noopener">图片引自官方文档</a>）。</li></ul></li></ul><p><img src="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/Art/reading_audio_file_2x.png" alt="image"></p><hr><h2 id="AudioSession简介"><a href="#AudioSession简介" class="headerlink" title="AudioSession简介"></a>AudioSession简介</h2><ul><li>AudioSession这个玩意的主要功能包括以下几点（<a href="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875" target="_blank" rel="noopener">图片来自官方文档</a>）：<ul><li>1.确定你的app如何使用音频（是播放？还是录音？）</li><li>2.为你的app选择合适的输入输出设备（比如输入用的麦克风，输出是耳机、手机功放或者airplay）</li><li>3.协调你的app的音频播放和系统以及其他app行为（例如有电话时需要打断，电话结束时需要恢复，按下静音按钮时是否歌曲也要静音等）<br><img src="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Art/ASPG_intro_2x.png" alt="image"></li></ul></li><li>AudioSession相关的类有两个：</li><li>==AudioToolBox中的AudioSession==</li><li>==AVFoundation中的AVAudioSession==</li><li>其中AudioSession在SDK 7中已经被标注为depracated，而AVAudioSession这个类虽然iOS 3开始就已经存在了，但其中很多方法和变量都是在iOS 6以后甚至是iOS 7才有的。所以各位可以依照以下标准选择:</li><li>如果最低版本支持iOS 5，可以使用AudioSession，也可以使用AVAudioSession；</li><li>如果最低版本支持iOS 6及以上，请使用AVAudioSession</li><li>==注意：在使用MPMusicPlayerController时不必关心AudioSession的问题。==</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 音频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的时间计算</title>
      <link href="/2017/07/10/2017-07-10-shi-jian-ji-suan/"/>
      <url>/2017/07/10/2017-07-10-shi-jian-ji-suan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre class=" language-objc"><code class="language-objc">    NSDate *date1=[NSDate date];//获得当前日期    NSLog(@"%@",date1); //结果：2014-07-16 07:25:28 +0000    NSDate *date2=[NSDate dateWithTimeIntervalSinceNow:100];//在当前日期的基础上加上100秒，注意在ObjC中多数时间单位都是秒    NSLog(@"%@",date2); //结果：2014-07-16 07:27:08 +0000    NSDate *date3=[NSDate distantFuture];//随机获取一个将来的日期    NSLog(@"%@",date3); //结果：4001-01-01 00:00:00 +0000    NSTimeInterval time=[date2 timeIntervalSinceDate:date1];//日期之差,返回单位为秒    NSLog(@"%f",time); //结果：100.008833    NSDate *date5=[date1 earlierDate:date3];//返回比较早的日期    NSLog(@"%@",date5); //结果：2014-07-16 07:25:28 +0000    //日期格式化    NSDateFormatter *formater1=[[NSDateFormatter alloc]init];    formater1.dateFormat=@"yy-MM-dd HH:mm:ss";    NSString *datestr1=[formater1 stringFromDate:date1];    NSLog(@"%@",datestr1); //结果：14-07-16 15:25:28    //字符串转化为日期    NSDate *date6=[formater1 dateFromString:@"14-02-14 11:07:16"];    NSLog(@"%@",date6); //结果：2014-02-14 03:07:16 +0000</code></pre><h2 id="比较两个时间的大小"><a href="#比较两个时间的大小" class="headerlink" title="比较两个时间的大小"></a>比较两个时间的大小</h2><pre class=" language-objc"><code class="language-objc">    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];    dateFormatter.dateFormat = @"yyyy-MM-dd HH:mm";    NSString *dateStr1 = @"2017-07-10 8:30";    NSString *dateStr2 = @"2017-07-10 8:21";    NSComparisonResult result = [[dateFormatter dateFromString:dateStr1] compare:[dateFormatter dateFromString:dateStr2]];//    NSOrderedAscending = -1L, 升序//    NSOrderedSame,//    NSOrderedDescending降序    NSLog(@"%zd",result);</code></pre><hr><h2 id="计算时间-NSDateComponents"><a href="#计算时间-NSDateComponents" class="headerlink" title="计算时间(NSDateComponents)"></a>计算时间(NSDateComponents)</h2><pre class=" language-objc"><code class="language-objc">NSCalendar *cal = [NSCalendar currentCalendar];NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];dateFormatter.dateFormat = @"yyyy-MM-dd HH:mm";NSString *dateStr1 = @"2017-06-18 8:30";NSDateComponents *components = [cal components:( NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | kCFCalendarUnitWeekday) fromDate:[dateFormatter dateFromString:dateStr1]];NSLog(@"%zd____%zd____%zd____%zd",components.year,components.month,components.day,components.weekday);</code></pre><ul><li>打印结果：</li><li>通过compoent可以得到对应的年月日，==关键是weekday==，是指当天为本星期的第几天，其中星期天为1，星期六为7.</li></ul><pre><code>2017-06-12 10:07:49.506 DateComponentDemo[1187:37235] 2017____6____18____1</code></pre><h4 id="计算两个时间的时间差："><a href="#计算两个时间的时间差：" class="headerlink" title="计算两个时间的时间差："></a>计算两个时间的时间差：</h4><pre class=" language-objc"><code class="language-objc">1、计算两个时间的时间差：NSCalendar *calendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSCalendarIdentifierGregorian];    NSDateComponents *comp = [calendar components:NSCalendarUnitDay fromDate:[NSDate date] toDate:[NSDate date] options:0];    NSLog(@"%zd",comp.day);</code></pre><h4 id="时间加减"><a href="#时间加减" class="headerlink" title="时间加减"></a>时间加减</h4><pre class=" language-objc"><code class="language-objc">//2、时间加减：NSDate *tempDate = [self.currentCalendar dateByAddingUnit:NSCalendarUnitDay value:i toDate:lastDate options:0];</code></pre><p><img src="https://note.youdao.com/yws/public/resource/66d455629a523b950bc25d22cccf27e7/xmlnote/WEBRESOURCE8da79e3e8142718b3cd14ccde85452e9/1982?ynotemdtimestamp=1564920075150" alt="image"></p><h3 id="本地化时间"><a href="#本地化时间" class="headerlink" title="本地化时间"></a>本地化时间</h3><pre class=" language-objc"><code class="language-objc">NSDate* now = [NSDate date];        NSLocale* cn = [NSLocale currentLocale];        str = [now descriptionWithLocale:cn];        NSLog(@"%@",str);//Friday, July 6, 2018 at 11:05:17 AM China Standard Time</code></pre><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><pre class=" language-objc"><code class="language-objc">// 获取当前时间- (NSString *)currentDateStr{    NSDate *currentDate = [NSDate date];//获取当前时间，日期    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];    //设定时间格式,这里可以设置成自己需要的格式    // [dateFormatter setDateFormat:@"YYYY/MM/dd hh:mm:ss SS"];    [dateFormatter setDateFormat:@"YYYY/MM/dd hh:mm:ss SS"];    NSString *dateString = [dateFormatter stringFromDate:currentDate];    return dateString;}</code></pre><h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><pre class=" language-objc"><code class="language-objc">// 时间戳转时间- (NSString *)getDateStringWithDate:(NSString *)dataStr{    // dataStr时间戳    NSTimeInterval time=[dataStr doubleValue]+28800;//因为时差问题要加8小时 == 28800 sec    NSDate *detaildate=[NSDate dateWithTimeIntervalSince1970:time];//    NSLog(@"date:%@",[detaildate description]);     //实例化一个NSDateFormatter对象    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];    //设定时间格式,这里可以设置成自己需要的格式//    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];    [dateFormatter setDateFormat:@"MM月dd日 HH:mm"];    NSString *currentDateStr = [dateFormatter stringFromDate: detaildate];    return currentDateStr;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的UITextField使用总结</title>
      <link href="/2017/07/05/2017-07-05-ios-zhong-de-uitextfield-shi-yong-zong-jie/"/>
      <url>/2017/07/05/2017-07-05-ios-zhong-de-uitextfield-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1、基本设置"><a href="#1、基本设置" class="headerlink" title="1、基本设置"></a>1、<a href="https://blog.csdn.net/tskyfree/article/details/8121915/" target="_blank" rel="noopener">基本设置</a></h2><h3 id="键盘类型"><a href="#键盘类型" class="headerlink" title="键盘类型"></a>键盘类型</h3><p><img src="https://note.youdao.com/yws/public/resource/88b56338a6fa36ed006f9e0494fea967/xmlnote/WEBRESOURCEfdb05f77d57955be154b08770bf841a3/1707" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/88b56338a6fa36ed006f9e0494fea967/xmlnote/WEBRESOURCEe702c7a6f240e5ad17aa90c723069017/1705" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/88b56338a6fa36ed006f9e0494fea967/xmlnote/WEBRESOURCEcd69d01adb01f0fb601fc7a2f735b6a9/1706" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/88b56338a6fa36ed006f9e0494fea967/xmlnote/WEBRESOURCEc5e0ccbe6b3a7194b10a65b20bbc0d5a/1704" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/88b56338a6fa36ed006f9e0494fea967/xmlnote/WEBRESOURCEf7da05951fcb8c16bda518522ff687b0/1709" alt="image"></p><h3 id="要显示中文，还得设置info-plist中"><a href="#要显示中文，还得设置info-plist中" class="headerlink" title="要显示中文，还得设置info.plist中"></a>要显示中文，还得设置info.plist中</h3><p>Localization native development region  为 cn</p><pre><code>UITextField *textF = [[UITextField alloc]init];//需要先把样式给取消掉textF.borderStyle = UITextBorderStyleNone;//然后再设置背景图片textF.background = [UIImage imageNamed:@&quot;chat_send_nor&quot;]; //设置背景  text.disabledBackground = [UIImage imageNamed:@&quot;cc.png&quot;];//光标如果太靠近边框，可以进行如下设置UIView *leftView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 10, 0)];textF.leftView = leftView;textF.leftViewMode = UITextFieldViewModeAlways;//占位文字颜色[textF setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];textF.tintColor = [UIColor blackColor];</code></pre><h3 id="输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容"><a href="#输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容" class="headerlink" title="输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容"></a>输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容</h3><pre><code> //输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容  text.clearButtonMode = UITextFieldViewModeAlways;   typedef enum {    UITextFieldViewModeNever,  重不出现    UITextFieldViewModeWhileEditing, 编辑时出现    UITextFieldViewModeUnlessEditing,  除了编辑外都出现    UITextFieldViewModeAlways   一直出现} UITextFieldViewMode;</code></pre><h3 id="是否纠错"><a href="#是否纠错" class="headerlink" title="是否纠错"></a>是否纠错</h3><pre><code> //是否纠错  text.autocorrectionType = UITextAutocorrectionTypeNo;typedef enum {    UITextAutocorrectionTypeDefault, 默认    UITextAutocorrectionTypeNo,   不自动纠错    UITextAutocorrectionTypeYes,  自动纠错} UITextAutocorrectionType;</code></pre><h3 id="再次编辑就清空"><a href="#再次编辑就清空" class="headerlink" title="再次编辑就清空"></a>再次编辑就清空</h3><pre><code> //再次编辑就清空  text.clearsOnBeginEditing = YES;</code></pre><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><pre><code> //内容对齐方式  text.textAlignment = UITextAlignmentLeft;//内容的垂直对齐方式  UITextField继承自UIControl,此类中有一个属性contentVerticalAlignment_countryTextF.contentVerticalAlignment = UIControlContentVerticalAlignmentTop;</code></pre><h3 id="内容填充"><a href="#内容填充" class="headerlink" title="内容填充"></a>内容填充</h3><pre><code> //设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动    textFied.adjustsFontSizeToFitWidth = YES;//设置自动缩小显示的最小字体大小  text.minimumFontSize = 20;  _countryTextF.font = [UIFont systemFontOfSize:25];</code></pre><h3 id="首字母是否大写"><a href="#首字母是否大写" class="headerlink" title="首字母是否大写"></a>首字母是否大写</h3><pre><code> //首字母是否大写  text.autocapitalizationType = UITextAutocapitalizationTypeNone;typedef enum {    UITextAutocapitalizationTypeNone, 不自动大写    UITextAutocapitalizationTypeWords,  单词首字母大写    UITextAutocapitalizationTypeSentences,  句子的首字母大写    UITextAutocapitalizationTypeAllCharacters, 所有字母都大写} UITextAutocapitalizationType;</code></pre><h3 id="最右侧加图片是以下代码-左侧类似"><a href="#最右侧加图片是以下代码-左侧类似" class="headerlink" title="最右侧加图片是以下代码   左侧类似"></a>最右侧加图片是以下代码   左侧类似</h3><pre><code>//最右侧加图片是以下代码   左侧类似    UIImageView *image=[[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;right.png&quot;]];    text.rightView=image;    text.rightViewMode = UITextFieldViewModeAlways; typedef enum {    UITextFieldViewModeNever,    UITextFieldViewModeWhileEditing,    UITextFieldViewModeUnlessEditing,    UITextFieldViewModeAlways} UITextFieldViewMode;</code></pre><h3 id="设置键盘背景颜色"><a href="#设置键盘背景颜色" class="headerlink" title="设置键盘背景颜色"></a>设置键盘背景颜色</h3><pre><code>    self.countryTextF.keyboardAppearance = UIKeyboardAppearanceDark;    self.birthDayTextF.keyboardAppearance = UIKeyboardAppearanceLight;</code></pre><h3 id="shift按键"><a href="#shift按键" class="headerlink" title="shift按键"></a>shift按键</h3><pre><code> textView.autocapitalizationType = UITextAutocapitalizationTypeNone;//shift不能自动有效 textView.autocapitalizationType = UITextAutocapitalizationTypeWords;//单词开头的情况下自动有效，就是每输入一个单词在开头的时候自动大写，第二个字母开始就自动小写 textView.autocapitalizationType = UITextAutocapitalizationTypeSentences;//文章开头有效 textView.autocapitalizationType = UITextAutocapitalizationTypeAllCharacters;//一直有效（就是一直大写）</code></pre><h3 id="自动矫正功能"><a href="#自动矫正功能" class="headerlink" title="自动矫正功能"></a>自动矫正功能</h3><pre><code> _countryTextF.autocorrectionType =  UITextAutocorrectionTypeYes;</code></pre><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、<uitextfielddelegate></uitextfielddelegate></h2><pre><code>//是否允许开始编辑- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField{    return YES;}//开始编辑时调用(成为第一响应者)// became first responder- (void)textFieldDidBeginEditing:(UITextField *)textField{    //NSLog(@&quot;%s&quot;,__func__);}//是否允许结束编辑- (BOOL)textFieldShouldEndEditing:(UITextField *)textField{    return YES;}//当结束编辑时调用- (void)textFieldDidEndEditing:(UITextField *)textField{    NSLog(@&quot;%s&quot;,__func__);}//是否允许改变文本框内容(拦截用户输入)- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{    return NO;}</code></pre><h3 id="监听return处理（没有内容则无法点击）"><a href="#监听return处理（没有内容则无法点击）" class="headerlink" title="监听return处理（没有内容则无法点击）"></a>监听return处理（没有内容则无法点击）</h3><pre><code>self.countryTextF.enablesReturnKeyAutomatically = YES；</code></pre><pre><code>    self.countryTextF.returnKeyType = UIReturnKeyNext;    self.birthDayTextF.returnKeyType = UIReturnKeyGoogle;    self.cityTextF.returnKeyType = UIReturnKeyContinue;    - (BOOL)textFieldShouldReturn:(UITextField *)textField {    NSLog(@&quot;%s&quot;,__func__);    return YES;}typedef enum { UIReturnKeyDefault, 默认 灰色按钮，标有Return UIReturnKeyGo, 标有Go的蓝色按钮UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索UIReturnKeyJoin,标有Join的蓝色按钮UIReturnKeyNext,标有Next的蓝色按钮 UIReturnKeyRoute,标有Route的蓝色按钮 UIReturnKeySearch,标有Search的蓝色按钮 UIReturnKeySend,标有Send的蓝色按钮UIReturnKeyYahoo,标有Yahoo的蓝色按钮 UIReturnKeyYahoo,标有Yahoo的蓝色按钮 UIReturnKeyEmergencyCall, 紧急呼叫按钮 } UIReturnKeyType;</code></pre><h2 id="3、监听文字改变"><a href="#3、监听文字改变" class="headerlink" title="3、监听文字改变"></a>3、监听文字改变</h2><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><pre><code>[textField addTarget:self action:@selector(textEditingChanged:) forControlEvents:UIControlEventEditingChanged];- (void)textEditingChanged:(UITextField *)textField {     NSLog(@&quot;%@&quot;,textField.text);}</code></pre><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(changeTextField:) name:UITextFieldTextDidChangeNotification object:textF];- (void)changeTextField:(NSNotification *)notification {     UITextField *textField = [notification object];     NSLog(@&quot;%@&quot;,textField.text);}</code></pre><h4 id="代理监听"><a href="#代理监听" class="headerlink" title="代理监听"></a>代理监听</h4><ul><li>此代理只能输出==上次已有==的字符(本次点击键盘输入的文字不会被输出)，所以我认为此代理==适合做输入字符串内容的控制==<h5 id="只能输入数字"><a href="#只能输入数字" class="headerlink" title="只能输入数字"></a>只能输入数字</h5>```</li><li>(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {<br>  NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:@”0123456789”] invertedSet];<br>  NSString *filteredStr = [[string componentsSeparatedByCharactersInSet:charSet] componentsJoinedByString:@””];<br>  if ([string isEqualToString:filteredStr]) {<pre><code>  return YES;</code></pre>  }<br>  return NO;<pre><code>##### 输入固定位数</code></pre></li><li>(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {<br>  NSString *numberString = [textField.text stringByReplacingCharactersInRange:range withString:string];<br>  if (numberString.length &gt; 5) {<pre><code>  textField.text = [numberString substringToIndex:5];  return NO;</code></pre>  }<br>  return YES;<br>}<pre><code></code></pre></li></ul><pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {    if (textField == self.liveThemeTextField) {    //这里的if时候为了获取删除操作,如果没有此if会造成当达到字数限制后删除键也不能使用的后果.        if (range.length == 1 &amp;&amp; string.length == 0) {            return YES;        }        //so easy        else if (self.liveThemeTextField.text.length &gt;= 30) {            self.liveThemeTextField.text = [textField.text substringToIndex:30];            return NO;        }    }    return YES;}</code></pre><hr><h3 id="swift（2018年更新）"><a href="#swift（2018年更新）" class="headerlink" title="swift（2018年更新）"></a>swift（2018年更新）</h3><blockquote><p>当用户输入达到最大限制字数的时候,此时的删除按钮不能使用</p></blockquote><pre><code>    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {        if range.length == 1 &amp;&amp; string.count == 0 {            return true         }        if (textField.text?.count ?? 0) &gt; 10 {            return false        }        return true    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UI样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记（一）</title>
      <link href="/2017/07/01/2017-07-01-java-xue-xi-bi-ji-yi/"/>
      <url>/2017/07/01/2017-07-01-java-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="Java开发环境"><a href="#Java开发环境" class="headerlink" title="Java开发环境"></a>Java开发环境</h3><ul><li>编译期：Java经过编译，生成.class字节码文件。</li><li>运行期：JVM加载.class文件并运行。</li><li>JVM：Java虚拟机，加载并运行.class</li><li>JRE: Java运行时环境，除了包含JVM以外还包含了运行Java程序所必须的环境。</li><li>JDK: Java开发工具包。除了包含JRE以外，还包含了开发Java程序所必须的命令工具。<h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5></li></ul><table><thead><tr><th>类型</th><th>字节空间</th></tr></thead><tbody><tr><td>boolean</td><td>1字节（8位）</td></tr><tr><td>char</td><td>2字节（16位）</td></tr><tr><td>int</td><td>4字节（32位）</td></tr><tr><td>float</td><td>4字节（32位）</td></tr><tr><td>double</td><td>8字节（64位）</td></tr><tr><td>long</td><td>8字节（64位）</td></tr><tr><td>举例float:</td><td></td></tr><tr><td>-2^31 ~ 2^31 - 1</td><td></td></tr><tr><td>##### 舍入误差</td><td></td></tr><tr><td>Java中默认的浮点型位Double。如果不加f而使用float会报错误：</td><td></td></tr><tr><td>```java</td><td></td></tr><tr><td>float price2 =  2.5f;</td><td></td></tr><tr><td>```</td><td></td></tr><tr><td>2进制中无法精确表示1/10，就像10进制中无法精确表示1/3一样。</td><td></td></tr></tbody></table><p>所以2进制表示10进制时会有舍入误差，对于一些需要精确运算的场合会导致代码的缺陷：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span><span class="token keyword">double</span> price3 <span class="token operator">=</span> <span class="token number">2.9</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>price <span class="token operator">-</span> price3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0.10000000000000009</span></code></pre><h5 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h5><pre><code>//导入import java.util.Scanner;Scanner scan = new Scanner(System.in);int age = scan.nextInt();System.out.println(age);</code></pre><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h5 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h5><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//数组的定义</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        array1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        array1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        array1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array3<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"_____"</span> <span class="token operator">+</span> array1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array4<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            array4<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"_____"</span> <span class="token operator">+</span> array4<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">167</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//复制数组元素：</span>        <span class="token comment" spellcheck="true">//原数组 -- 起始下标--目的数组--起始下标---复制原数组的元素长度</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> arr2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//复制数组元素：</span>        <span class="token comment" spellcheck="true">//需要导入import java.util.Arrays;</span>        <span class="token comment" spellcheck="true">//原数组---目标数组初始化的长度</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h5><pre><code>        //对数组进行排序        //对数组进行升序排序        Arrays.sort(arr3);        //对arr1进行冒泡排序        //冒泡排序：Bubble sort        for (int i = 0; i &lt; arr1.length - 1;i++) {//5个数需要比较四轮            for (int j = 0; j&lt; arr1.length - 1 - i; j++) {                if(arr1[i] &gt; arr1[i + 1]) {                    int temp = arr1[i];                    arr1[i] = arr1[i + 1];                    arr1[i + 1] = temp;                }            }        }        for (int i = 0; i &lt; arr1.length; i++) {            System.out.println(&quot;冒泡排序：&quot; + arr1[i]);        }        //判断是否为质数        int  tempInt = 37;        boolean isPrimeNumber = true;        //简单判断就是 i &lt;= tempInt / 2;        //此处用的是平方根        for(int i = 0;i &lt;= Math.sqrt(tempInt); i++) {            if(tempInt % i == 0) {                isPrimeNumber = false;                break;            }        }        if(isPrimeNumber) {              System.out.println(&quot;是质数&quot;);        }else {            System.out.println(&quot;不是质数&quot;);        }</code></pre><hr><h4 id="Java的继承"><a href="#Java的继承" class="headerlink" title="Java的继承"></a>Java的继承</h4><pre class=" language-JAVA"><code class="language-JAVA">public class OverloadLearn {    public static void main(String[] args) {        Person people = new Person();        people.logUserInfo(); //父类的调用        Student aStudent = new Student();        aStudent.logUserInfo();//子类的调用        aStudent.logFinal();        //父类的指针指向子类的对象（多态）向上造型        Person aPeople = new Student();        aPeople.logUserInfo();//子类的调用        }}class Person {    int age;    String name;    void logUserInfo() {        System.out.println("父类的调用");    }}class Student extends Person {    String school;    //被static final修饰的为常量，声明即需要初始化，不能被改变    static final String address = "中华人民共和国";     void logUserInfo() {//         super.logUserInfo();        System.out.println("子类的调用");    }     void logFinal() {         System.out.println(address);     }}</code></pre><h5 id="抽象类的继承"><a href="#抽象类的继承" class="headerlink" title="抽象类的继承"></a>抽象类的继承</h5><pre><code>//有抽象方法，必须要声明为抽象类。并且抽象类不能够被实例化//抽象类就是被用来继承的。abstract class Shape {    double c;    abstract double area();//抽象方法}//必须实现父类的抽象方法class Square extends Shape {    double area() {        System.out.println(&quot;这是子类实现的一个抽象方法&quot;);        return 56.6;    }}</code></pre><h5 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h5><p>定义接口，继承抽象类：</p><pre><code>//定义接口interface MyInterfaceOne {    public static final double PI = 3.1415;    int number = 25;//接口中默认为 public static final    public abstract void showLog();//抽象方法    void showMyLog();//默认就是 public abstract    //error:常量必须要初始化//    int a ;}interface MyInterfaceSecond {    int age = 24;    void showMySecondLog();}abstract class MyAbstractClass {    abstract void showMyAbstractMethod();}//定义的类需要实现所声明的接口的方法//接口和类是并列的关系//接口也是可以继承的,类实现MyInterfaceThree的方法时，也需要实现MyInterfaceSecond接口的方法//interface MyInterfaceThree extends MyInterfaceSecond {//    //}class InterfaceClass extends MyAbstractClass implements MyInterfaceOne,MyInterfaceSecond{    //继承抽象类的方法（必须实现）    void showMyAbstractMethod() {        System.out.println(&quot;_____继承抽象类的方法&quot;);    }    //注意：必须要加public（必须要实现）    public void showLog() {        System.out.println(&quot;这是showLog方法&quot;);    }    public void showMyLog() {        System.out.println(&quot;这是showMyLog方法&quot;);    }    public void showMySecondLog() {        System.out.println(&quot;这是showMySecondLog方法&quot;);    }}</code></pre><p>实现：</p><pre><code>InterfaceClass myClass = new InterfaceClass();myClass.showMyAbstractMethod();myClass.showLog();myClass.showMyLog();myClass.showMySecondLog();</code></pre><h5 id="内部类的定义"><a href="#内部类的定义" class="headerlink" title="内部类的定义"></a>内部类的定义</h5><pre><code>//内部类和外部类class Mather {//外部类    private String Name;    Baby createBaby() {        return new Baby();    }    class Baby {//内部类        public void showMatherName() {            System.out.println(Name);            System.out.println(Mather.this.Name);//            System.out.println(this.Name);error         }    }}</code></pre><pre><code>    public static void main(String[] args) {        Mather myMather = new Mather();//        Baby ba = new Baby();error : 内部类不能在外部实现    }</code></pre><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><pre><code>    public static void main(String[] args) {        int number = 44;        //error: 接口不能实例化//        MyInterface interface = new MyInterface();Error        //匿名类的定义和实现        MyInterface myInterf = new MyInterface(){            public void show() {                System.out.println(&quot;调用了show方法&quot;);            }            //error:在MyInterface中未定义，是不允许新添加方法的。//            public void myShow() {//                System.out.println(&quot;调用了myShow方法&quot;);//            }            public void showNumber() {                System.out.println(number);            }        };        myInterf.show();        myInterf.showNumber();//        myInterf.myShow();error }interface MyInterface {        public void show();    public void showNumber();}}</code></pre><hr><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><pre><code>public static void main(String[] args) {        String str = &quot;Hello world&quot;;        // 没有则返回-1        int index = str.indexOf(&quot;w&quot;);        System.out.println(&quot;_____&quot; + index);        // 重载方法从指定的位置查找        int index1 = str.indexOf(&quot;w&quot;, 3);        System.out.println(&quot;_____&quot; + index1);        String str2 = &quot;0123456789&quot;;        // 字符串的截取        // 从index3 到index5（不包括5）        String sub = str2.substring(3, 5);        System.out.println(&quot;_____&quot; + sub);// 34        // 从index4开始到结束        sub = str2.substring(4);        System.out.println(&quot;_____&quot; + sub);// 456789        int indexOfNumber = str2.indexOf(&quot;3&quot;);        System.out.println(&quot;indexOfNumber&quot; + indexOfNumber);//        String myUrl = &quot;http://www.baidu.com&quot;;        if (myUrl.startsWith(&quot;http&quot;)) {            System.out.println(&quot;http开头&quot;);            int start = myUrl.indexOf(&quot;.&quot;) + 1;            int end = myUrl.indexOf(&quot;.&quot;, start);            String subStr = myUrl.substring(start, end);            System.out.println(&quot;=====&quot; + subStr);// baidu        } else {        }        // 获取inex为4的字符        char myChar = str2.charAt(4);        System.out.println(&quot;=====&quot; + myChar);// 4        String info = &quot;上海自来水来自海上&quot;;        boolean isTrue = true;        // 判断是否为回文        for (int i = 0; i &lt; info.length(); i++) {            if (info.charAt(i) != info.charAt(info.length() - 1 - i)) {                isTrue = false;                break;            }        }        if (isTrue) {            System.out.println(&quot;是回文&quot;);        } else {            System.out.println(&quot;不是回文&quot;);        }        // 改变大小写        String str3 = &quot;Hello World 我爱Java&quot;;        String upperStr = str3.toUpperCase();        System.out.println(upperStr);// HELLO WORLD 我爱JAVA        String lowerStr = str3.toLowerCase();        System.out.println(lowerStr);// hello world 我爱java        // 数字转字符串        int a = 1;        double b = 2.2;        String StrA = String.valueOf(a);        String StrB = String.valueOf(b);        System.out.println(StrA);//        System.out.println(StrB);// 2.2        String tempStr = &quot;中华人民共和国&quot;;        // 可变字符串        //StringBuffer:考虑了线程安全 StringBuilder没有//        StringBuffer strBuffer = new StringBuffer(null);        StringBuilder strBuilder = new StringBuilder(tempStr);        System.out.println(strBuilder);        // 初始化一个空的可变字符串        StringBuilder strNull = new StringBuilder();        System.out.println(strNull);        // 可变字符串转换为不可变字符串        String unStringBuilderStr = strBuilder.toString();        System.out.println(unStringBuilderStr);        // 可变字符串的拼接（在末尾追加）        strBuilder.append(&quot;万岁！！！&quot;);//中华人民共和国万岁！！！        System.out.println(strBuilder);        //可变字符串的替换        strBuilder.replace(0, 7, &quot;世界人民大团结&quot;);        System.out.println(strBuilder);//世界人民大团结万岁！！！        //删除指定范围的字符串(含头不含尾)        strBuilder.delete(9, 11);        System.out.println(strBuilder);//世界人民大团结万岁！        // 可变字符串的插入（在前边插入）        strBuilder.insert(0, &quot;中华人民共和国万岁!&quot;);        System.out.println(strBuilder);//中华人民共和国万岁!世界人民大团结万岁！        //翻转字符串        strBuilder.reverse();        System.out.println(strBuilder);//！岁万结团大民人界世!岁万国和共民人华中    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系统总结学习(三)</title>
      <link href="/2017/06/06/2017-06-06-git-xi-tong-zong-jie-xue-xi-san/"/>
      <url>/2017/06/06/2017-06-06-git-xi-tong-zong-jie-xue-xi-san/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>我们知道,Git 保存的不是文件差异或者变化量，而只是一系列文件快照。 在 Git 中提交时，会保存一个提交(commit)对象，它包含一个指向暂存内容快照的指针，作者和相关附 属信息，以及一定数量(也可能没有)指向该提交对象直接祖先的指针:第一次提交是没有直接祖先的，普通 提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。 </p><p>当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录(本例中就是项目根目录)的校验和， 然后在 Git 仓库中将这些目录保存为树(tree)对象。之后 Git 创建的提交对象，除了包含相关提交信息以 外，还包含着指向这个树对象(项目根目录)的指针，如此它就可以在将来需要的时候，重现此次快照的内容 了。 </p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作 为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次 提交的时候都会自动向前移动。 </p><p>那么，Git 又是如何创建一个新的分支的呢?答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 git branch 命令: </p><pre><code>git branch testing</code></pre><p>那么，Git 是如何知道你当前在哪个分支上工作的呢?其实答案也很简单，它保存着一个名为 HEAD 的特别 指针。 Git 中，它是一个指向你正在工作中的本地分支的指针。运行 git branch 命令，仅仅是建立了一个新的分支， 但不会自动切换到这个分支中去，所以 要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支: </p><pre><code>git checkout testing</code></pre><p>如果,此时我们执行命令<code>git checkout master</code>,它会把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支 所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。 </p><h3 id="基本的分支与合并"><a href="#基本的分支与合并" class="headerlink" title="基本的分支与合并"></a>基本的分支与合并</h3><h4 id="新建并切换到此分支"><a href="#新建并切换到此分支" class="headerlink" title="新建并切换到此分支"></a>新建并切换到此分支</h4><pre><code>git checkout -b dev_bug_1</code></pre><blockquote><p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生 冲突从而阻止 Git 为你转换分支。转换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种 问题的办法(分别叫做 stashing 和 amending)。 </p></blockquote><p>如果此时把dev_bug_1合并到 master 分支并发布到生产服务器。用 git merge 命 令来进行合并: </p><pre><code>git checkout mastergit merge dev_bug_1</code></pre><p>请注意，合并时出现了 “Fast forward”(快进)提示。由于当前 master 分支所在的 commit 是要并入 的 hotfix 分支的直接上游(所谓上游,可以理解为随着时间流逝,我们进行的提交记录中,越早的记录,就相当于该分支的上游)，我们把dev_bug_1合并到master,master的指针原先在”过去”的上游,  Git 在合并两者后，master相当于”快速向前”(快速向距离最后一次提交的时间靠近了)推进了,又因为没有什么分歧需要解决，所以这个过程叫做快 进(Fast forward)。 </p><pre><code>~/Desktop/gitDemo(dev_bug_1) » git checkout master                                                          liuxingxing@liuxingxingdeMacBook-ProSwitched to branch &#39;master&#39;Your branch is up to date with &#39;origin/master&#39;.-------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master) » git merge dev_bug_1                                                             liuxingxing@liuxingxingdeMacBook-ProUpdating 0d78f5a..3e3fc9cFast-forward README  | 1 + Text.md | 5 ++++- git     | 0 3 files changed, 5 insertions(+), 1 deletion(-) create mode 100644 git</code></pre><blockquote><p>快 进(Fast forward)可以理解为视频的播放进度中快进的操作.</p></blockquote><h4 id="删除-分支"><a href="#删除-分支" class="headerlink" title="删除 分支"></a>删除 分支</h4><p>合并后,dev_bug_1和master指向相同的提交，现在假设dev_bug_1没什么用了，可以先删掉它:</p><pre><code>~/Desktop/gitDemo(master) » git branch -d dev_bug_1                                                         Deleted branch dev_bug_1 (was 3e3fc9c).</code></pre><h4 id="冲突的合并"><a href="#冲突的合并" class="headerlink" title="冲突的合并"></a>冲突的合并</h4><p>有时候合并操作并不会如此顺利。如果你修改了两个待合并分支里同一个文件的同一部分，Git 就无法干净 地把两者合到一起(逻辑上说，这种问题只能由人来解决)。 Git 仍然会合并，但不会提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅 .任何包含未解决冲突的文件都会以未合并(unmerged)状态列出。Git 会在有冲突的文件里加入标准的冲突 解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分: </p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; =======&lt;div id=&quot;footer&quot;&gt;please contact us at support@github.com &lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></pre><blockquote><p>可以看到 ======= 隔开的上半部分，是 HEAD(即 master 分支，在运行 merge 命令时检出的分支)中的内 容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。 在 解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决(resolved)。因为一旦暂存，就表示 冲突已经解决。 然后就可以用 git commit 来完成这次合并 提交。 </p></blockquote><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>查看当前所有分支的清单 :</p><pre><code>git branch</code></pre><p>若要查看各个分支最后一次 commit 信息，运行 git branch -v: </p><pre><code>git branch -v</code></pre><p>要从该清单中筛选出你已经(或尚未)与当前分支合并的分支，可以用 –merge 和 –no-merged 选项 :</p><pre><code>git branch --mergegit branch --no-merge</code></pre><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>从远程分支检出的本地分支，称为跟踪分支(tracking branch)。跟踪分支是一种和远程分支有直接联系的 本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在 这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。 </p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>要想和其他人分享某个分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同 步到你引入的远程分支中，除非你明确执行推送操作 .如果你有个叫 dev_test 的分支需要和他人一起开发， 可以运行 git push (远程仓库名) (分支名): </p><pre><code>~/Desktop/DLL/MyDesk/hubSource/blog(dev_test) » git push origin dev_test                                    liuxingxing@liuxingxingdeMacBook-ProEnumerating objects: 30, done.Counting objects: 100% (30/30), done.Delta compression using up to 12 threadsCompressing objects: 100% (15/15), done.Writing objects: 100% (18/18), 5.02 KiB | 5.02 MiB/s, done.Total 18 (delta 11), reused 0 (delta 0)remote: Resolving deltas: 100% (11/11), completed with 4 local objects.To github.com:smileasy/hubSource.git   3e0867a..31dfae8  dev_test -&gt; dev_test</code></pre><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>如果不再需要某个远程分支了 ,可以用这个非常无厘头的语法来删除它:git push [远程名] :[分支名]。如果想在服务器上删 除 dev_liuxingxing 分支 :</p><pre><code>~/Desktop/DLL/MyDesk/hubSource/blog(dev_test*) » git push origin :dev_liuxingxing                           liuxingxing@liuxingxingdeMacBook-ProTo github.com:smileasy/hubSource.git - [deleted]         dev_liuxingxing</code></pre><blockquote><p>有种方便记忆这条命令的方法:记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如 果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。 </p></blockquote><p>当然,你也可以直接使用delete来删除分支,上面的命令如果不小心记错了,就会发生误删的情况:</p><pre><code>git branch -d dev_leg_0923git push origin --delete dev_leg_0923</code></pre><h4 id="更改本地和远程分支名称"><a href="#更改本地和远程分支名称" class="headerlink" title="更改本地和远程分支名称"></a>更改本地和远程分支名称</h4><p>如果你想将dev_leg分支改名为dev_liuxingxing,可以使用下面2条命令来完成操作:</p><pre><code>git branch -m dev_leg dev_liuxingxinggit push origin dev_liuxingxing</code></pre><h3 id="储藏-Stashing"><a href="#储藏-Stashing" class="headerlink" title="储藏(Stashing)"></a>储藏(Stashing)</h3><p>储藏(Stashing) 可以将你的更改保存到一个未完结变更的堆栈中，随时可以重新应用:</p><pre><code>~/Desktop/gitDemo(master*) » git stashSaved working directory and index state WIP on master: 3e3fc9c 修改文件</code></pre><p>要查看现有的储藏，你可以使用 git stash list: </p><pre><code>git stash list</code></pre><p>应用储藏:</p><pre><code>git stash apply</code></pre><blockquote><p>git stash apply会使用栈顶的存储.</p></blockquote><p>如果你想应用更 早的储藏，你可以通过名字指定它，像这样:git stash apply stash@{1} :</p><pre><code>git stash apply stash@{1}</code></pre><p>apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 git stash drop，加上 你希望移除的储藏的名字: </p><pre><code>~/Desktop/gitDemo(master*) » git stash drop stash@{1}Dropped stash@{1} (2e9346692e3aa4f58b0f0e868f9381af209f6b62)</code></pre><p>你也可以运行 git stash pop 来重新应用储藏，同时立刻将其从堆栈中移走。 </p><h4 id="从储藏中创建分支"><a href="#从储藏中创建分支" class="headerlink" title="从储藏中创建分支"></a>从储藏中创建分支</h4><p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会 碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化 解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分 支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。 </p><pre><code>~/Desktop/gitDemo(master) » git stash branch dev_branchSwitched to a new branch &#39;dev_branch&#39;On branch dev_branchChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   Text.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)Dropped refs/stash@{0} (abaf4f5a6e22d8fa51d3c9f93652133279d7b946)</code></pre><h3 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h3><p>很多时候，在 Git 上工作的时候，你也许会由于某种原因想要修订你的提交历史。 </p><h4 id="改变最近一次提交"><a href="#改变最近一次提交" class="headerlink" title="改变最近一次提交"></a>改变最近一次提交</h4><p>改变最近一次提交也许是最常见的重写历史的行为。对于你的最近一次提交，你经常想做两件基本事情:改 变提交说明，或者改变你刚刚通过增加，改变，删除而记录的快照。 </p><p>如果你只想修改最近一次提交说明，这非常简单: </p><pre><code>git commit --amend</code></pre><blockquote><p>这会把你带入文本编辑器，里面包含了你最近一次提交说明，供你修改。当你保存并退出编辑器，这个编辑 器会写入一个新的提交，里面包含了那个说明，并且让它成为你的新的最近一次提交。 如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，可能因为你最初提交时，忘了添加一 个新建的文件，这个过程基本上一样。你通过修改文件然后对其运行git add或对一个已被记录的文件运行git rm，随后的git commit –amend会获取你当前的暂存区并将它作为新提交对应的快照。 使用这项技术的时候你必须小心，因为修正会改变提交的SHA-1值。这个很像是一次非常小的rebase——不 要在你最近一次提交被推送后还去修正它。 </p></blockquote><h4 id="修改多个提交说明"><a href="#修改多个提交说明" class="headerlink" title="修改多个提交说明"></a>修改多个提交说明</h4><p>要修改历史中更早的提交， 例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给git rebase -i提供一个参数，指明你想 要修改的提交的父提交，例如HEAD<del>2或者HEAD</del>3。可能记住~3更加容易，因为你想修改最近三次提交;但是请记 住你事实上所指的是四次提交之前，即你想修改的提交的父提交。 </p><pre><code>~/Desktop/gitDemo(devtest) » git rebase -i HEAD~3Successfully rebased and updated refs/heads/devtest.</code></pre><blockquote><p>再次提醒这是一个衍合命令——HEAD~3..HEAD范围内的每一次提交都会被重写，无论你是否修改说明。不要涵 盖你已经推送到中心服务器的提交——这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手势识别 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系统总结学习(二)</title>
      <link href="/2017/06/03/2017-06-03-git-xi-tong-zong-jie-xue-xi-er/"/>
      <url>/2017/06/03/2017-06-03-git-xi-tong-zong-jie-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><h4 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h4><p>查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。在克隆完某个<br>项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库:</p><pre><code>git remote// 显示对应的克隆地址git remote -v</code></pre><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,运行 git remote add [shortname] [url],现在,我们为gitDemo添加远程仓库:</p><pre><code>~/Desktop/gitDemo(master*) » git add origin git@github.com:smileasy/GitLearn.git                                                liuxingxing@liuxingxingdeMacBook-Profatal: pathspec &#39;origin&#39; did not match any files---------------------------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git remote add origin git@github.com:smileasy/GitLearn.git                                         liuxingxing@liuxingxingdeMacBook-Pro---------------------------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git remote                                                                                         liuxingxing@liuxingxingdeMacBook-Proorigin---------------------------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git remote -v                                                                                      liuxingxing@liuxingxingdeMacBook-Proorigin    git@github.com:smileasy/GitLearn.git (fetch)origin    git@github.com:smileasy/GitLearn.git (push)</code></pre><p>此时我想将代码提交到远程仓库,直接运行git push提示报错:</p><pre><code>~/Desktop/gitDemo(master) » git push                                                                                            liuxingxing@liuxingxingdeMacBook-Profatal: The current branch master has no upstream branch.To push the current branch and set the remote as upstream, use    git push --set-upstream origin master</code></pre><p>根据提示信息,使用git push –set-upstream origin master:</p><pre><code>~/Desktop/gitDemo(master) » git push --set-upstream origin master                                                               liuxingxing@liuxingxingdeMacBook-ProEnumerating objects: 27, done.Counting objects: 100% (27/27), done.Delta compression using up to 12 threadsCompressing objects: 100% (19/19), done.Writing objects: 100% (27/27), 46.25 KiB | 9.25 MiB/s, done.Total 27 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To github.com:smileasy/GitLearn.git * [new branch]      master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.</code></pre><h4 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h4><p>用下面的命令从远程仓库抓取数据到本地:</p><pre><code>git fetch [remote-name]</code></pre><blockquote><p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。git fetch origin 会抓取从你上 次克隆以来别人上传到此远程仓库中的所有更新(或是上次 fetch 以来别人提交的更新)。有一点很重要， 需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好 了，才能手工合并。更多的是,可以使用 git pull 命令 自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快 且好。</p></blockquote><h4 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h4><p>使用git push [remote-name] [branch-name]可以将本地仓库中的数据推送到远程仓库.</p><pre><code>git push origin master</code></pre><h4 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h4><p>我们可以通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息:</p><pre><code>~/Desktop/gitDemo(master) » git remote show                                                       liuxingxing@liuxingxingdeMacBook-Proorigin---------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master) » git remote show origin                                                liuxingxing@liuxingxingdeMacBook-Pro* remote origin  Fetch URL: git@github.com:smileasy/GitLearn.git  Push  URL: git@github.com:smileasy/GitLearn.git  HEAD branch: master  Remote branch:    master tracked  Local branch configured for &#39;git pull&#39;:    master merges with remote master  Local ref configured for &#39;git push&#39;:    master pushes to master (up to date)</code></pre><blockquote><p>最后两行告诉我们，运行 git push 时缺省推送的分支是什么.</p></blockquote><h4 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h4><p>我们现在只有一个master分支,如果要测试远程仓库的删除和重命名,则需要先创建新的分支test.我们需要先checkout 一个新的本地分支,然后再关联一个远程分支:</p><pre><code>~/Desktop/gitDemo(master) » git checkout -b test                                   liuxingxing@liuxingxingdeMacBook-ProSwitched to a new branch &#39;test&#39;------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(test) » git push -u origin test                                  liuxingxing@liuxingxingdeMacBook-ProTotal 0 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for &#39;test&#39; on GitHub by visiting:remote:      https://github.com/smileasy/GitLearn/pull/new/testremote:To github.com:smileasy/GitLearn.git * [new branch]      test -&gt; testBranch &#39;test&#39; set up to track remote branch &#39;test&#39; from &#39;origin&#39;.</code></pre><blockquote><p>-u 参数表示将本地的dev分支和远程的origin/dev分支之间建立跟踪关联。</p></blockquote><p>查看远程分支列表:</p><pre><code>git branch -r</code></pre><p>用 git remote rename 命令修改某个远程仓库的简短名称，比如想把 test分支 改成 dev_test，可以这么运行:</p><pre><code>~/Desktop/gitDemo(test) » git remote rename test dev_test                                                        liuxingxing@liuxingxingdeMacBook-Profatal: No such remote: &#39;test&#39;</code></pre><p>移除 对应的远端仓库(删除分支dev_leg_0923):</p><pre><code> git push origin --delete dev_leg_0923</code></pre><p>更改分支名称(将dev_leg分支改名为dev_liuxingxing):</p><pre><code>git branch -m dev_leg dev_liuxingxinggit push origin dev_liuxingxing</code></pre><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>我们在发布某个软件版本的时候，经常需要打标签. </p><h4 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h4><pre><code>git tag</code></pre><p>在 Git 自身项目仓库中，有着超过 240 个标签，如果你 只对 1.4.2 系列的版本感兴趣，可以运行下面的命令: </p><pre><code>git tag -l &#39;v1.4.2.*&#39;</code></pre><h4 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h4><p>Git 使用的标签有两种类型:轻量级的(lightweight)和含附注的(annotated)。轻量级标签就像是个不 会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立 对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使 用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息;当 然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 </p><h4 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h4><p>创建一个含附注类型的标签非常简单，用 -a (译注:取 annotated 的首字母)指定标签名字即可: </p><pre><code>git tag -a release1.0 -m &#39;发布1.0版本到生产环境&#39;</code></pre><p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果在此选项后没有给出具 体的说明内容，Git 会启动文本编辑软件供你输入。 </p><p>可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。 </p><pre><code>git show release1.0</code></pre><h4 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h4><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s (译注: 取 Signed 的首 字母)即可: </p><pre><code>git tag -s release1.1 -m &#39;使用私钥打标签&#39;</code></pre><blockquote><p>此条命令我并没有验证</p></blockquote><h4 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h4><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可: </p><pre><code>git tag v1.4-lw</code></pre><h4 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h4><p>你甚至可以在后期对早先的某次提交加注标签 :</p><pre><code>git log --pretty=oneline   //获取校验和git tag -a version1.2 ab2205fca1   //为指定的提交打上version1.2标签</code></pre><h4 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h4><p>默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其 命令格式如同推送分支，运行 git push origin [tagname] 即可: </p><pre><code>~/Desktop/gitDemo(devtest*) » git push origin version1.2                                                    liuxingxing@liuxingxingdeMacBook-ProEnumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 186 bytes | 186.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To github.com:smileasy/GitLearn.git * [new tag]         version1.2 -&gt; version1.2</code></pre><p>如果要一次推送所有(本地新增的)标签上去，可以使用 –tags 选项: </p><pre><code>~/Desktop/gitDemo(devtest*) » git push origin --tags                                                        liuxingxing@liuxingxingdeMacBook-ProTotal 0 (delta 0), reused 0 (delta 0)To github.com:smileasy/GitLearn.git * [new tag]         list -&gt; list * [new tag]         show -&gt; show</code></pre><h3 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h3><h4 id="Git-命令别名"><a href="#Git-命令别名" class="headerlink" title="Git 命令别名"></a>Git 命令别名</h4><pre><code>git config --global alias.co checkoutgit config --global alias.sta status</code></pre><p>取消暂存文件时的输入比较繁琐，可以自己设置一下 :</p><pre><code>git config --global alias.unstage &#39;reset HEAD&#39; </code></pre><p>使用:</p><pre><code>~/Desktop/gitDemo(devtest*) » git config --global alias.unstage &#39;reset HEAD&#39;                                liuxingxing@liuxingxingdeMacBook-Pro-------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(devtest*) » git status                                                                    liuxingxing@liuxingxingdeMacBook-ProOn branch devtestYour branch is up to date with &#39;origin/devtest&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   git-------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(devtest*) » git unstage git                                                               liuxingxing@liuxingxingdeMacBook-Pro-------------------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(devtest*) » git sta                                                                       liuxingxing@liuxingxingdeMacBook-ProOn branch devtestYour branch is up to date with &#39;origin/devtest&#39;.Untracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    gitnothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre><blockquote><p>如果文件已经处于可以被commit的状态,需要你先reset HEAD掉文件,使文件处于未存储的状态,然后才能通过git checkout – 文件名 来丢弃对文件的修改.   git config –global alias.unstage ‘reset HEAD’ 相当于以下2个命令:</p></blockquote><pre><code>git unstage fileA$ git reset HEAD fileA</code></pre><p>另外，我们还经常设置 last 命令 来看最后一次的提交信息 :</p><pre><code>git config --global alias.last &#39;log -1 HEAD&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git系统总结学习(一)</title>
      <link href="/2017/06/01/2017-06-01-git-xi-tong-zong-jie-xue-xi-yi/"/>
      <url>/2017/06/01/2017-06-01-git-xi-tong-zong-jie-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>使用Git时，对于任何一个文件，在 Git 内都只有三种状态:已提交 (committed)，已修改(modified)和已暂存(staged)。已提交表示该文件已经被安全地保存在本地数据库中了;已修改表示修改了某个文件，但还没有提交保存;已暂存表示把已修改的文件放在下次提交时要保存 的清单中。</p><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>你可以使用<code>git config</code>来配置Git。你可以从三个不同的地方来更改Git的环境变量。</p><h4 id="使用git-config-system"><a href="#使用git-config-system" class="headerlink" title="使用git config --system"></a>使用<code>git config --system</code></h4><p><code>git config --system</code>是针对系统中对所有用户都普遍适用的配置。个人认为对于本地环境下的个人用户，使用场景并没有那么多。</p><h4 id="使用git-config-global"><a href="#使用git-config-global" class="headerlink" title="使用git config --global"></a>使用<code>git config --global</code></h4><p><code>git config --global</code>是针对用户目录下的配置，该配置只适用于该用户。我们可以通过该命令来设置自己本地环境的相关信息。</p><h4 id="当前项目的-git-目录中的配置文件"><a href="#当前项目的-git-目录中的配置文件" class="headerlink" title="当前项目的 git 目录中的配置文件"></a>当前项目的 git 目录中的配置文件</h4><p>我们知道，在自己项目的根目录下有一个隐藏的.git目录，我们可以针对该项目进行单独的配置。在这里的git配置可以覆盖global和system的配置信息。</p><h4 id="举例：配置你个人的用户名称和电子邮件地址"><a href="#举例：配置你个人的用户名称和电子邮件地址" class="headerlink" title="举例：配置你个人的用户名称和电子邮件地址"></a>举例：配置你个人的用户名称和电子邮件地址</h4><p>查看原来的设置：</p><pre><code>~/Desktop » git config --global user.name                                                           liuxingxing@liuxingxingdeMacBook-Pro刘星星~/Desktop » git config --global  user.email                                                         liuxingxing@liuxingxingdeMacBook-Prolxxwork0827@163.com</code></pre><p>更改配置：</p><pre><code>~/Desktop » git config --global user.name &quot;liuxingxing&quot;~/Desktop » git config --global  user.email &quot;smileasy@foxmail.com&quot;</code></pre><blockquote><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默 认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重 新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p></blockquote><h4 id="更改其他配置"><a href="#更改其他配置" class="headerlink" title="更改其他配置"></a>更改其他配置</h4><p>文本编辑器：</p><pre><code>~/Desktop » git config --global core.editor emacs</code></pre><p>差异分析工具：</p><pre><code>~/Desktop » git config --global merge.tool vimdiff</code></pre><h4 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h4><pre><code>~/Desktop » git config --list</code></pre><hr><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h4 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h4><pre><code>$ git clone git://github.com/liuxingxing.git</code></pre><p>这会在当前目录下创建一个名为 “liuxingxing” 的目录，其中内含一个 .git 的目录，并从同步后的仓库中拉出所有的数据，取出最新版本的文件拷贝。如果希望在克隆的时候，自己定义要新建的项目目录名称为”smileay”，可以在上面的 命令最后指定:</p><pre><code>$ git clone git://github.com/liuxingxing.git  smileay</code></pre><h4 id="从当前目录初始化"><a href="#从当前目录初始化" class="headerlink" title="从当前目录初始化"></a>从当前目录初始化</h4><p>现在我们有个项目,名叫gitDemo,里面有个文件叫做README.md.现在我们希望对该项目使用 Git 管理，只需到此项目所在的目录，执行:</p><pre><code>git init</code></pre><p>如果当前目录下的文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟 踪，然后提交:</p><pre><code>$ git add README.md$ git commit -m &#39;initial project version&#39;</code></pre><h4 id="已跟踪或未跟踪"><a href="#已跟踪或未跟踪" class="headerlink" title="已跟踪或未跟踪"></a>已跟踪或未跟踪</h4><p>请记住，工作目录下面的所有文件都不外乎这两种状态:已跟踪或未跟踪。已跟踪的文件是指本来就被纳入 版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者 已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。 初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。在编辑过某些文件之后，Git将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，然后等 最后一次性提交暂存区域的所有文件更新，如此重复。</p><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>要确定哪些文件当前处于什么状态，可以用 git status 命令:</p><pre><code>~/Desktop/gitDemo(master) » git status                                                           On branch masterNo commits yetnothing to commit (create/copy files and use &quot;git add&quot; to track)</code></pre><blockquote><p>这说明现在的工作目录相当干净。换句话说，当前没有任何跟踪着的文件，也没有任何文件在上次提交后 更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在的分支是 master，这是默认的分支名称，实际是可以修改.</p></blockquote><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>现在,我们将一个叫learn.png 文件添加到项目中.然后再运行<code>git status</code>查看状态:<br>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 learn.png 文件，可以运行:</p><pre><code>~/Desktop/gitDemo(master) » git status                                                              On branch masterNo commits yetUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    learn.pngnothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre><blockquote><p>可以看到,learn.png被标记为Untracked files.Untracked files表示Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它这么做，因而不用担心把临时文件什么的也归入版本管理。git提示你可以通过git add&lt;文件名&gt;来将其纳入版本管理.</p></blockquote><p>我们使用命令 git add 开始跟踪learn.png文件:</p><pre><code>~/Desktop/gitDemo(master*) » git add learn.png                                                      liuxingxing@liuxingxingdeMacBook-Pro-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterNo commits yetChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)    new file:   learn.png</code></pre><blockquote><p>可以看到learn.png被添加到 “Changes to be committed”下面了.我们需要知道,在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此 时此刻的版本将被留存在历史记录中。git add 后可以接要跟踪的文件或目录的路径。如果是目录的话，就说明要递归跟踪所 有该目录下的文件。</p></blockquote><h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>现在我们将README.md文件里面的内容做做修改以用来测试,然后再次运行 status 命令:</p><pre><code>-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    new file:   learn.pngChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   README.md------------------------------------------</code></pre><blockquote><p>文件 README.md 出现在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变 化，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令(这是个多功能命令，根据目标文件的状 态不同，此命令的效果也不同:可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时 把有冲突的文件标记为已解决状态等)。现在让我们运行 git add 将 README.md 放到暂存区，然后再看 看 git status 的输出:</p></blockquote><pre><code>-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git add README.md                                                      liuxingxing@liuxingxingdeMacBook-Pro-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   README.md    new file:   learn.png-------------------------------------------------------------------------------------------------------------------------------------</code></pre><blockquote><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。</p></blockquote><p>假设此时，你想要在 README.md 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 git status 看看:</p><pre><code>-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   README.md    new file:   learn.pngChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   README.md----------------------------------------------------------------------------------------------</code></pre><blockquote><p>你会发现 README.md文件出现了两次!一次算未暂存，一次算已暂存，这有点让人费解.实际上 Git 只不过暂存了你运行 git add命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来.</p></blockquote><h4 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h4><p>般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生 成的文件，像是日志或者编译过程中创建的等等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的 文件模式.如果自己并不十分确定究竟要忽略哪些文件,可以在GitHub上找到对应项目类型的.gitignore文件.当然,你也可以自己创建这个.gitignore文件:</p><pre><code># 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件build/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</code></pre><h4 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h4><p>假如再次修改 README 文件后先别暂存,然运行 status 命令，会看到:</p><pre><code>~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   README.md    new file:   learn.pngChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   README.md-------------------------------------------------------------</code></pre><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff:</p><pre><code>diff --git a/README.md b/README.mdindex 3673bf4..7cf08ef 100644--- a/README.md+++ b/README.md@@ -1,3 +1,3 @@-德玛洗牙+德玛西亚(END)</code></pre><blockquote><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内 容。请注意，单单 git diff不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。所以有 时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff –cached 命令或者(git diff –staged命令).</p></blockquote><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看 下，是不是都已暂存起来了，然后再运行提交命令:</p><pre><code>~/Desktop/gitDemo(master*) » git commit  -m &#39;我是提交注释&#39;                                          liuxingxing@liuxingxingdeMacBook-Pro[master bef8ce0] 我是提交注释 2 files changed, 3 insertions(+), 2 deletions(-) create mode 100644 learn.png---------------------------------</code></pre><blockquote><p>好，现在你已经创建了第一个提交!可以看到，提交后它会告诉你，当前是在哪个分支(master)提交的， 本次提交的完整 SHA-1 校验和是什么(bef8ce0)，以及在本次提交中，有多少文件修订过，多少行添改和删 改过。记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入 版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p></blockquote><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用 暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂 存起来一并提交，从而跳过 git add 步骤:</p><pre><code>~/Desktop/gitDemo(master) » git status                                                              liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git commit -a -m &#39;修改README文件&#39;                                      liuxingxing@liuxingxingdeMacBook-Pro[master f7c0e19] 修改README文件 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>现在,gitDemo里面有2个文件,分别是README.md和Text.md两个文件,分支已经提交.</p><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说，是从暂存区域移除)，然后提 交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪 文件清单中了。如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部 分(也就是未暂存清单)看到.</p><p>现在我们直接在目录中删除Text.md文件,然后查看项目状态:</p><pre><code>~/Desktop/gitDemo(master*) » ~/Desktop/gitDemo(master) » git status                                                              liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        deleted:    Text.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>现在,我们运行 git rm 记录此次移除文件的操作,看看和刚才有什么不同:</p><pre><code>~/Desktop/gitDemo(master*) » git rm Text.md                                                         liuxingxing@liuxingxingdeMacBook-Prorm &#39;Text.md&#39;-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    deleted:    Text.md--------------------------------------------</code></pre><blockquote><p>可以看到,原来的Text.md文件被标记为”Changes not staged for commit:”,但是执行过git rm Text.md 命令之后,Text.md文件已经被标记为”Changes to be committed”,也就是可以直接运行commit命令提交了.执行commit之后，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须 要用强制删除选项 -f(译注:即 force 的首字母)，以防误删除文件后丢失修改的内容。</p></blockquote><p>另外一种情况是，我们想把文件从 Git 仓库中删除(亦即从暂存区域移除)，但仍然希望保留在当前工作 目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库 后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可:</p><pre><code>git rm --cached README</code></pre><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数 据并不会体现出这是一次改名操作。</p><p>现在,gitDemo里面有2个文件,分别是README.md和Text.md两个文件,分支已经提交.假如现在你想将README.md改名为READ,可以这样做:</p><pre><code>~/Desktop/gitDemo(master) » git mv README.md README                                                 liuxingxing@liuxingxingdeMacBook-Pro-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    renamed:    README.md -&gt; README------------------------------------------</code></pre><blockquote><p>此时查看状态信息，也会明白无误地看到关于重命名操作的说明,此时,该README文件已经处于可以被commit的状态了.</p></blockquote><p>看到git mv命令,你可能会感到困惑,我明明只是希望给文件改个名字,怎么会执行git mv命令呢?其实，运行 git mv 就相当于运行了下面三条命令:</p><pre><code>~/Desktop/gitDemo(master) » mv README.md README ~/Desktop/gitDemo(master) » git rm README.txt~/Desktop/gitDemo(master) » git add README</code></pre><blockquote><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 git mv 轻便得多.</p></blockquote><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 git log 命令。</p><pre><code>git  log//用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新git log –p -2//--stat，仅显示简要的增改行数统计git log --stat//--pretty 选项，可以指定使用完全不同于默认格式的方式展示提交历史。//比如用 oneline 将每 个提交放在一行显示，这在提交数很大时非常有用。//另外还有 short，full 和 fuller 可以用，展示的信息或多//或少有些不同，请自己动手实践一下看看效果如何。git log --pretty=onelineit log --pretty=format:&quot;%h - %an, %ar : %s&quot;//--since 和 --until 列出所有最近两周内的提交git log --since=2.weeks</code></pre><h4 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h4><p>任何时候，你都有可能需要撤消刚才所做的某些操作。注意，有些操作并不总是可以撤消的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。</p><h5 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h5><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以 使用 –amend 选项重新提交.</p><p>比如,我们刚刚修改了README文件,为里面增加了为里面的文字增加了”111111111111”内容,然后提交了记录.但是我们突然发现,我们还需要修改一下Text.md文件,将Text.md文件里面增加内容”222222222”然后一起提交,可是我们已经提交了记录:</p><pre><code>~/Desktop/gitDemo(master) » git status                                                              liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   READMEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git commit -a -m &#39;为README问件增加内容为111111111111&#39;                  liuxingxing@liuxingxingdeMacBook-Pro[master bac98db] 为README问件增加内容为111111111111 1 file changed, 1 insertion(+)-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master) » git status                                                              liuxingxing@liuxingxingdeMacBook-ProOn branch masternothing to commit, working tree clean</code></pre><p>此时使用 –amend就可以解决这个问题.注意,如果此时文件没有改动,或者改动了并没有 add文件,是文件并没有处于可以commit状态,那么运行<code>git commit --amend</code>命令只是相当于有 机会重新编辑提交说明，而所提交的文件快照和之前的一样。</p><pre><code>~/Desktop/gitDemo(master) » git status                                                              liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   Text.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)git commit --amend</code></pre><blockquote><p>git commit –amend运行后,vim会让你重新编写提交记录,当你重新编辑提交记录后, :wq之后则意味着操作已经完成.</p></blockquote><h5 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h5><p>我们修改README文件,为里面增加了为里面的文字增加了”333333333”内容,修改一下Text.md文件,将Text.md文件里面增加内容”4444444444”然后一起提交,我们打算分开提交2个文件的记录,但是却不小心使用了git add .命令全部添加到了暂存区,现在我们使用命令<code>git reset HEAD Text.md</code>取消对Text.md的暂存:</p><pre><code>~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   README    modified:   Text.md-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git reset HEAD Text.md                                                 liuxingxing@liuxingxingdeMacBook-ProUnstaged changes after reset:M    Text.md-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   READMEChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   Text.md---------------------------------------------------------------------------------</code></pre><blockquote><p>我们通过git status 命令查看文件状态的时候就提示了该如何撤消，所以不需要死记硬背.</p></blockquote><h5 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h5><p>如果觉得刚才对 Text.md 的修改完全没有必要，该如何取消修改，回到之前的状态(也就是修改之 前的版本)呢?git status 同样提示了具体的撤消方法，接着上面的例子，现在未暂存区域看起来像这样:</p><pre><code>~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   READMEChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   Text.md------------------------------------------</code></pre><p>我们按照提示运行<code>git checkout -- Text.md</code>命令:</p><pre><code>~/Desktop/gitDemo(master*) » git checkout -- Text.md                                                liuxingxing@liuxingxingdeMacBook-Pro-----------------------------------------------------------------------------------------------------------------------------------------~/Desktop/gitDemo(master*) » git status                                                             liuxingxing@liuxingxingdeMacBook-ProOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   README----------------------------------------------</code></pre><blockquote><p>可以看到，该文件已经恢复到修改前的版本。你可能已经意识到了，这条命令有些危险，所有对文件的修改 都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用 stashing 和分支来处理，应该会更好些。记住，任何已经提交到 Git 的都可以被恢复。你可能失去的数据，仅限于没有提交过的， 对 Git 来说它们就像从未存在过一样。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在swift中使用Quartz 2D</title>
      <link href="/2017/05/21/2017-05-21-zai-swift-zhong-shi-yong-quartz-2d/"/>
      <url>/2017/05/21/2017-05-21-zai-swift-zhong-shi-yong-quartz-2d/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="在swift中使用Quartz-2D"><a href="#在swift中使用Quartz-2D" class="headerlink" title="在swift中使用Quartz 2D"></a>在swift中使用Quartz 2D</h2><p>在iOS中，绘图技术主要有UIKit、Quartz 2D、Core Animation和OpenGL ES。其中，Core Animation提供动画实现技术，OpenGL ES是针对OpenGL嵌入式设备实现的简化版本，它可以绘制高性能的2D和3D图形。UIKit是高级别的图形接口，它的API是基于Object-C和swift，它能够实现绘图、文字、动画和图像等内容。Quartz 2D是iOS和Mac OS环境下的2D绘图引擎。</p><h3 id="填充矩形"><a href="#填充矩形" class="headerlink" title="填充矩形"></a>填充矩形</h3><p>我们可以自定义一个view，并在<code>draw(_ rect: CGRect)</code>中实现：</p><pre><code>    override func draw(_ rect: CGRect) {            //为当前的图形上下文设置要填充颜色        UIColor.brown.setFill()        //填充颜色        UIRectFill(rect)    }</code></pre><p>现在，如果我们希望在该view中添加一个矩形，并且矩形已蓝色描边：</p><pre><code>    override func draw(_ rect: CGRect) {        //为当前的图形上下文设置要填充颜色        UIColor.brown.setFill()        //填充颜色        UIRectFill(rect)        // 设置矩形的frame        let frame = CGRect(x: 10, y: 10, width: 100, height: 200)        //设置边框的颜色（如果不设置，默认是黑色）        UIColor.blue.setStroke()        //绘制矩形        UIRectFrame(frame)    }</code></pre><h3 id="绘制图像和文本"><a href="#绘制图像和文本" class="headerlink" title="绘制图像和文本"></a>绘制图像和文本</h3><p>我们知道，在iOS中，我们可以通过UIImageView和UILabel两个标准控件来实现图像和文字的绘制。实际上，我们呢也可以通过Image和String来实现同样的功能。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> 图形图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS常用宏定义</title>
      <link href="/2017/05/01/2017-05-01-ios-chang-yong-hong-ding-yi/"/>
      <url>/2017/05/01/2017-05-01-ios-chang-yong-hong-ding-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="定义一个宏"><a href="#定义一个宏" class="headerlink" title="定义一个宏"></a>定义一个宏</h4><h5 id="使用两个”-“来定义一个宏"><a href="#使用两个”-“来定义一个宏" class="headerlink" title="使用两个”##“来定义一个宏"></a>使用两个”##“来定义一个宏</h5><pre><code>#define LXWeakSelf(type)  __weak typeof(type) weak##type = type;</code></pre><pre><code>- (void)viewDidLoad {    [super viewDidLoad];    LXWeakSelf(self);    [weakself test:@&quot;liuxingxing&quot;];}- (void)test: (NSString *)name {    NSLog(@&quot;%@&quot;,name);}</code></pre><blockquote><p>##是连接的作用, 即当使用上面的宏会把weak与输入的type值连接起来.</p></blockquote><h5 id="使用一个”-“来定义一个宏"><a href="#使用一个”-“来定义一个宏" class="headerlink" title="使用一个”#“来定义一个宏"></a>使用一个”#“来定义一个宏</h5><p>我们一般定义的宏是这样的：</p><pre><code>#define LXLogA(str) [NSString stringWithFormat:@&quot;%@&quot;,str]LXLogA(@&quot;你好呀&quot;);NSLog(@&quot;%@&quot;, LXLogA(@&quot;你好呀&quot;));</code></pre><p>我们呢可以通过使用一个”#“来定义宏：</p><pre><code>#define LXLogB(str) [NSString stringWithFormat:@&quot;%@&quot;,@#str]LXLogB(你好 世界 你好 中国);NSLog(@&quot;%@&quot;, LXLogB(你好 世界 你好 中国));</code></pre><blockquote><p>我们可以看到LXLogB使用时不再需要@””来包含字符串。也就是说，@#替换了@””。</p></blockquote><h4 id="iOS常用的宏总结"><a href="#iOS常用的宏总结" class="headerlink" title="iOS常用的宏总结"></a>iOS常用的宏总结</h4><h5 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h5><pre><code>#define NSLog(format, ...) do {                                               \  fprintf(stderr, &quot;&lt;%s : %d&gt; %s\n&quot;,                                           \  [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \  __LINE__, __func__);                                                        \  (NSLog)((format), ##__VA_ARGS__);                                           \  fprintf(stderr, &quot;-------\n&quot;);                                               \} while (0)</code></pre><pre><code>//自定义NSLog#ifdef DEBUG#define LXLog(...) NSLog(@&quot;%s 第%d行 \n %@\n\n&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])#else#define LXLog(...)#endif</code></pre><h5 id="打印rect相关的信息"><a href="#打印rect相关的信息" class="headerlink" title="打印rect相关的信息"></a>打印rect相关的信息</h5><pre><code>#define NSLogRect(rect) NSLog(@&quot;%s x:%.4f, y:%.4f, w:%.4f, h:%.4f&quot;,     \        #rect, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)#define NSLogSize(size) NSLog(@&quot;%s w:%.4f, h:%.4f&quot;, #size, size.width, size.height)#define NSLogPoint(point) NSLog(@&quot;%s x:%.4f, y:%.4f&quot;, #point, point.x, point.y)</code></pre><h5 id="字符串、数组、字典是否为空"><a href="#字符串、数组、字典是否为空" class="headerlink" title="字符串、数组、字典是否为空"></a>字符串、数组、字典是否为空</h5><pre><code>#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] &lt; 1 ? YES : NO )#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys.count == 0)</code></pre><h5 id="获取屏幕的宽度、高度、大小"><a href="#获取屏幕的宽度、高度、大小" class="headerlink" title="获取屏幕的宽度、高度、大小"></a>获取屏幕的宽度、高度、大小</h5><pre><code>#define SCREEN_WIDTH ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.width)#define SCREENH_HEIGHT ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.height)#define SCREEN_SIZE ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale):[UIScreen mainScreen].bounds.size)// 配合其他的宏来打印size的大小NSLogSize(SCREEN_SIZE);</code></pre><h5 id="获取状态栏的高度"><a href="#获取状态栏的高度" class="headerlink" title="获取状态栏的高度"></a>获取状态栏的高度</h5><pre><code>#define stautsBarHeight ([UIApplication sharedApplication].statusBarFrame.size.height)</code></pre><h5 id="获取APP的版本号和系统的版本号"><a href="#获取APP的版本号和系统的版本号" class="headerlink" title="获取APP的版本号和系统的版本号"></a>获取APP的版本号和系统的版本号</h5><pre><code>#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;]#define kSystemVersion [[UIDevice currentDevice] systemVersion]</code></pre><h5 id="获取当前语言"><a href="#获取当前语言" class="headerlink" title="获取当前语言"></a>获取当前语言</h5><pre><code>#define kCurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])</code></pre><h5 id="判断是否为iPhone和iPad"><a href="#判断是否为iPhone和iPad" class="headerlink" title="判断是否为iPhone和iPad"></a>判断是否为iPhone和iPad</h5><pre><code>#define kIsiPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)#define kIsiPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</code></pre><h5 id="获取沙盒相关的路径"><a href="#获取沙盒相关的路径" class="headerlink" title="获取沙盒相关的路径"></a>获取沙盒相关的路径</h5><pre><code>//获取temp#define kPathTemp NSTemporaryDirectory()//获取沙盒 Document#define kPathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]//获取沙盒 Cache#define kPathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]</code></pre><h5 id="判断是真机还是模拟器"><a href="#判断是真机还是模拟器" class="headerlink" title="判断是真机还是模拟器"></a>判断是真机还是模拟器</h5><pre><code>#if TARGET_OS_IPHONE//iPhone Device#endif#if TARGET_IPHONE_SIMULATOR//iPhone Simulator#endif</code></pre><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><pre><code>//RGB格式#define kRGBColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]//RGBA格式 （A：alpha）#define kRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]//随机色生成#define kRandomColor KRGBColor(arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0) //16进制形式#define kColorWithHex(rgbValue) \[UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16)) / 255.0 \ green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8)) / 255.0 \ blue:((float)(rgbValue &amp; 0xFF)) / 255.0 alpha:1.0]</code></pre><h5 id="GCD的宏定义"><a href="#GCD的宏定义" class="headerlink" title="GCD的宏定义"></a>GCD的宏定义</h5><pre><code>//GCD - 一次性执行#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);//GCD - 在Main线程上运行#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);//GCD - 开启异步线程#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);</code></pre><h5 id="弧度和角度之间的转换"><a href="#弧度和角度之间的转换" class="headerlink" title="弧度和角度之间的转换"></a>弧度和角度之间的转换</h5><pre><code>//由角度转换为弧度#define kDegreesToRadian(x) (M_PI * (x) / 180.0)//由弧度转换为角度#define kRadianToDegrees(radian) (radian * 180.0) / (M_PI)</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> 基础总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中View的拖拽</title>
      <link href="/2017/04/18/2017-04-18-ios-zhong-view-de-tuo-zhuai/"/>
      <url>/2017/04/18/2017-04-18-ios-zhong-view-de-tuo-zhuai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1、UITouch"><a href="#1、UITouch" class="headerlink" title="1、UITouch"></a>1、UITouch</h2><h3 id="UITouch的属性"><a href="#UITouch的属性" class="headerlink" title="UITouch的属性"></a>UITouch的属性</h3><p><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCE767181541a91b0c16c0be0c47b9bb900/21950" alt="image"></p><pre><code>//触摸产生时所处的窗口@property (nonatomic , readonly, retain) UIWindow *window;//触摸产生时所处的视图@property (nonatomic , readonly, retain)UIView *view;//短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击@property (nonatomic , readonly) NSUInteger tapCount ;//记录了触摸事件产生或变化时的时间，单位是秒@property (nonatomic, readonly) NSTimeInterval timestamp ;//当前触摸事件所处的状态@property (nonatomic, readonly) UITouchPhase phase;</code></pre><h3 id="UITouch的方法"><a href="#UITouch的方法" class="headerlink" title="UITouch的方法"></a>UITouch的方法</h3><pre><code>//返回值表示触摸在view上的位置//这里返回的位置是针对view的坐标系的(以view的左上角为原点[0, 0])//调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置- (CGPoint) locationInView: (UIView *)view;//该方法记录了前一个触摸点的位置- (CGPoint) previousLocationInView: (UIView *)view;</code></pre><pre><code>- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {    UITouch *touch = [touches anyObject];     // 获取当前点    CGPoint currentPoint = [touch locationInView:self];      //获取上一个点    CGPoint previousPoint = [touch previousLocationInView:self];    //获取XY轴偏移量    CGFloat offsetX = currentPoint.x - previousPoint.x;    CGFloat offsetY = currentPoint.y - previousPoint.y;    //修改View的位置（frame,center,transform）    //从当期位置计算偏移量    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);    //每次都是从0计算偏移量//    self.transform = CGAffineTransformMakeTranslation(offsetX, offsetY);}注意：即使用多跟手指同时拖动一个View，也只为产生一个UITouch对象，通过更改self.multipleTouchEnabled属性可以实现产生多个UITouch对象，但是不建议这么做。</code></pre><h3 id="响应者对象UIResponder"><a href="#响应者对象UIResponder" class="headerlink" title="响应者对象UIResponder"></a>响应者对象UIResponder</h3><ul><li>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象”</li><li>UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件</li></ul><pre><code>UIResponder内部提供了以下方法来处理事件触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;加速计事件- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;远程控制事件- (void)remoteControlReceivedWithEvent:(UIEvent *)event;</code></pre><h2 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h2><p><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCEb752c81227fa848ace561167cbaefdfa/21948" alt="image"></p><pre><code>每产生一个事件，就会产生一个UIEvent对象UIEvent：称为事件对象，记录事件产生的时刻和类型常见属性事件类型@property(nonatomic,readonly) UIEventType     type;@property(nonatomic,readonly) UIEventSubtype  subtype;事件产生的时间@property(nonatomic,readonly) NSTimeInterval  timestamp;UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch）</code></pre><pre><code>typedef NS_ENUM(NSInteger, UIEventType) {    UIEventTypeTouches,    UIEventTypeMotion,    UIEventTypeRemoteControl,};typedef NS_ENUM(NSInteger, UIEventSubtype) {    // available in iPhone OS 3.0    UIEventSubtypeNone                              = 0,    // for UIEventTypeMotion, available in iPhone OS 3.0    UIEventSubtypeMotionShake                       = 1,    // for UIEventTypeRemoteControl, available in iOS 4.0    UIEventSubtypeRemoteControlPlay                 = 100,    UIEventSubtypeRemoteControlPause                = 101,    UIEventSubtypeRemoteControlStop                 = 102,    UIEventSubtypeRemoteControlTogglePlayPause      = 103,    UIEventSubtypeRemoteControlNextTrack            = 104,    UIEventSubtypeRemoteControlPreviousTrack        = 105,    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,    UIEventSubtypeRemoteControlEndSeekingForward    = 109,};</code></pre><p><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCE4adb22fcd3c45e570ddd46a58de73dda/21952" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCEbf13f048ff9922786b0cc11ec40febf8/21954" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCE1af9c8c4bf0306cf6507872fed43d747/21963" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCEead1fbc959b8a5e556c8defe379a662a/21967" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCEdeb1f89afb689bf4396d3176b814823c/21969" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCE7d586013456d5a40ef84347dfe1665e6/21971" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/05b4b8f49f45c1b87225e9ee0e4d573b/xmlnote/WEBRESOURCE8f93b4858fe1b05232bb29dfd055eb30/21973" alt="image"></p><h3 id="HitTest"><a href="#HitTest" class="headerlink" title="HitTest"></a>HitTest</h3><pre><code>HitTest练习如下：// hitTest:withEvent:作用：就是用来寻找最合适的view//什么时候调用：当一个事件传递给当前View的时候调用//返回值：返回是谁，谁就是最适合的view，就会调用该view的touch方法- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{    // 当前控件上的点转换到chatView上    CGPoint chatP = [self convertPoint:point toView:self.chatView];    // 判断下点在不在chatView上    if ([self.chatView pointInside:chatP withEvent:event]) {        return self.chatView;    }else{        return [super hitTest:point withEvent:event];    }}                                                                       </code></pre><pre><code>//作用:寻找最适全的View//参数:point 当前手指的点.  event当前的事件.//什么时候调用:当一个事件传递给当前View的时候就会调用.-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{//    return [super hitTest:point withEvent:event];    //1.判断自己能否接收事件    if(self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01){        return nil;    }    //2.触摸点在不在当前的View.    if (![self pointInside:point withEvent:event]) {        return nil;    }    //3.从后往前遍历出自己的子控件.重复前两步操作,看自己子控件是不是最适合的Viwe.    int count = (int)self.subviews.count;    for (int i = count -1; i &gt;= 0; i--) {    UIView *childV = self.subviews[i];    //把当前的点转换成childV坐标系的点.    CGPoint childPoint = [self convertPoint:point toView:childV];    //判断子控件是不是最适合的View.    UIView *fitView = [childV hitTest:childPoint withEvent:event];        if (fitView) {            return fitView;        }    }    //4.如果没有符合条件的子控件,那么它自己就是这个最适合的View.    return  self;}//hitTest底层会调用pointInside.//判断当前点在不在当前的view上.//point点必须是跟当前View同一坐标系的点.-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{    return YES;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object-C </tag>
            
            <tag> 事件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发中的手势识别器</title>
      <link href="/2017/04/15/2017-04-15-ios-kai-fa-zhong-de-shou-shi-shi-bie-qi/"/>
      <url>/2017/04/15/2017-04-15-ios-kai-fa-zhong-de-shou-shi-shi-bie-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h2><pre><code>//当前手势状态typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {    //尚未识别是何种手势操作（但可能已经触发了触摸事件），默认状态    UIGestureRecognizerStatePossible,       //手势已经开始，此时已经被识别，但是这个过程中可能发生变化，手势操作尚未完成    UIGestureRecognizerStateBegan,         //手势状态发生改变    UIGestureRecognizerStateChanged,     // 手势识别操作完成（此时已经松开手指）      UIGestureRecognizerStateEnded,     //手势被取消，恢复到默认状态       UIGestureRecognizerStateCancelled,     //手势识别失败，恢复到默认状态    UIGestureRecognizerStateFailed,        //手势识别完成，同end    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded };NS_CLASS_AVAILABLE_IOS(3_2) @interface UIGestureRecognizer : NSObject//创建一个手势对象并添加触发事件- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action NS_DESIGNATED_INITIALIZER; //给一个手势对象添加监听事件- (void)addTarget:(id)target action:(SEL)action;   //移除一个手势的监听事件- (void)removeTarget:(nullable id)target action:(nullable SEL)action; //获取当前手势状态@property(nonatomic,readonly) UIGestureRecognizerState state;  //委托@property(nullable,nonatomic,weak) id &lt;UIGestureRecognizerDelegate&gt; delegate; //手势识别是否可用@property(nonatomic, getter=isEnabled) BOOL enabled;  //获取手势触摸的View视图 只读@property(nullable, nonatomic,readonly) UIView *view;         //是否取消触摸控件的响应默认为YES，这种情况下当手势识别器识别到触摸之后，会发送touchesCancelled给触摸到的控件以取消控件view对touch的响应，这个时候只有手势识别器响应touch，当设置成NO时，手势识别器识别到触摸之后不会发送touchesCancelled给控件，这个时候手势识别器和控件view均响应touch。注意：手势识别和触摸事件是同时存在的，只是因为touchesCancelled导致触摸事件失效、@property(nonatomic) BOOL cancelsTouchesInView; //是否延迟发送触摸事件给触摸到的控件默认是NO，这种情况下当发生一个触摸时，手势识别器先捕捉到到触摸，然后发给触摸到的控件，两者各自做出响应。如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将触摸发给触摸到的控件，即控件不会有任何触摸事件。只有在识别失败之后才会将触摸事件发给触摸到的控件，这种情况下控件view的响应会延迟约0.15ms。@property(nonatomic) BOOL delaysTouchesBegan;     //如果触摸识别失败是否立即结束本次手势识别的触摸事件@property(nonatomic) BOOL delaysTouchesEnded;        //指定一个手势需要另一个手势执行失败才会执行，同时触发多个手势使用其中一个手势的解决办法有时手势是相关联的，如单机和双击，点击和长按，点下去瞬间可能只会识别到单击无法识别其他，该方法可以指定某一个 手势，即便自己已经满足条件了，也不会立刻触发，会等到该指定的手势确定失败之后才触发- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;//获取当前触摸在指定视图上的点- (CGPoint)locationInView:(nullable UIView*)view;                               //获取触摸手指数- (NSUInteger)numberOfTouches;                                         //多指触摸的触摸点相对于指定视图的位置- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view; @end</code></pre><pre><code>UITapGestureRecognizer（轻触，点按）UILongPressGestureRecognizer（长按）UISwipeGestureRecognizer（轻扫手势）UIRotationGestureRecognizer（旋转手势）UIPanGestureRecognizer（拖拽手势）UIPinchGestureRecognizer（捏合手势，缩放用）</code></pre><h2 id="UIGestureRecognizerDelegate"><a href="#UIGestureRecognizerDelegate" class="headerlink" title="UIGestureRecognizerDelegate"></a>UIGestureRecognizerDelegate</h2><pre><code>@protocol UIGestureRecognizerDelegate &lt;NSObject&gt;@optional//开始进行手势识别时调用的方法，返回NO则结束识别，不再触发手势，用处：可以在控件指定的位置使用手势识别- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;//是否支持多手势触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播，默认返回NO；如果为YES，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，否则上层对象识别后则不再继续传播- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;// 这个方法返回YES，第一个手势和第二个互斥时，第一个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);//这个方法返回YES，第一个和第二个互斥时，第二个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等此方法在window对象在有触摸事件发生时，调用gesture recognizer的touchesBegan:withEvent:方法之前调用，如果返回NO,则gesture recognizer不会看到此触摸事件。(默认情况下为YES)- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;@end</code></pre><pre><code>//是否同时支持多种手势- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{  return YES;}//是否允许开始点击- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{return YES;}//设置点击的范围- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch{//获取当前的触摸点  CGPoint curp = [touch locationInView:self.imageView];  if (curp.x &lt;= self.imageView.bounds.size.width*0.5) {      return NO;  }else{      return YES;  }}</code></pre><pre><code>// 是否允许触发手势 - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer; // 是否允许同时支持多个手势，默认是不支持多个手势 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;// 手指按压屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press;</code></pre><ul><li>让左边不能点击，右边可以点击</li></ul><pre><code>// 是否允许接收手指的触摸点- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch{    // 获取当前的触摸点    CGPoint curP = [touch locationInView:self.imageView];    if (curP.x &lt; self.imageView.bounds.size.width * 0.5) {        return NO;    }else{        return YES;    }}</code></pre><h3 id="UITapGestureRecognizer和UIButton的点击事件冲突的解决办法"><a href="#UITapGestureRecognizer和UIButton的点击事件冲突的解决办法" class="headerlink" title="UITapGestureRecognizer和UIButton的点击事件冲突的解决办法"></a>UITapGestureRecognizer和UIButton的点击事件冲突的解决办法</h3><pre><code>- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch{    if ([touch.view isKindOfClass:[UIButton class]])    {        return NO;    }          return YES;}</code></pre><hr><h2 id="UITapGestureRecognizer（轻触，点按）"><a href="#UITapGestureRecognizer（轻触，点按）" class="headerlink" title="UITapGestureRecognizer（轻触，点按）"></a>UITapGestureRecognizer（轻触，点按）</h2><pre><code>NS_CLASS_AVAILABLE_IOS(3_2) @interface UITapGestureRecognizer : UIGestureRecognizer//设置能识别到手势的最少的轻触次数（默认为1）@property (nonatomic) NSUInteger  numberOfTapsRequired;     //设置能识别到手势的最少的手指的个数（默认为1） @property (nonatomic) NSUInteger  numberOfTouchesRequired;  @end// 创建一个手势对象UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction:)];// 设置能识别到手势的最少的轻触次数tap.numberOfTapsRequired = 3;// 设置能识别到手势的最少的手指的个数tap.numberOfTouchesRequired = 2;//把手势对象添加到对应的控件中[self.imgView addGestureRecognizer:tap];</code></pre><h2 id="UILongPressGestureRecognizer（长按手势）："><a href="#UILongPressGestureRecognizer（长按手势）：" class="headerlink" title="UILongPressGestureRecognizer（长按手势）："></a>UILongPressGestureRecognizer（长按手势）：</h2><pre><code>NS_CLASS_AVAILABLE_IOS(3_2) @interface UILongPressGestureRecognizer : UIGestureRecognizer//设置能识别到手势的最少的轻触次数（默认为1）@property (nonatomic) NSUInteger numberOfTapsRequired;     //设置能识别到手势的最少的手指的个数（默认为1） @property (nonatomic) NSUInteger numberOfTouchesRequired;   //设置能识别到长按手势的最短的长按时间，单位：秒，默认为0.5@property (nonatomic) CFTimeInterval minimumPressDuration; //设置长按时允许移动的最大距离，单位：像素，默认为10像素@property (nonatomic) CGFloat allowableMovement;           @endUILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction:)];// 设置能识别到长按手势的最小的长按时间longPress.minimumPressDuration = 0.5;// &quot;容错的范围&quot;longPress.allowableMovement  = 10;// 把长按手势添加到对应的控件中[self.imgView addGestureRecognizer:longPress];//长按手势默认会触发两次。可以通过设置手势状态来控制：- (void)longPress:(UILongPressGestureRecognizer *)longPress{    if (longPress.state == UIGestureRecognizerStateBegan) {        NSLog(@&quot;%s&quot;,__func__);    }}</code></pre><h2 id="UISwipeGestureRecognizer（轻扫手势）"><a href="#UISwipeGestureRecognizer（轻扫手势）" class="headerlink" title="UISwipeGestureRecognizer（轻扫手势）:"></a>UISwipeGestureRecognizer（轻扫手势）:</h2><pre><code>typedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) {    UISwipeGestureRecognizerDirectionRight = 1 &lt;&lt; 0,  //向右滑    UISwipeGestureRecognizerDirectionLeft  = 1 &lt;&lt; 1,  //向左滑    UISwipeGestureRecognizerDirectionUp    = 1 &lt;&lt; 2,  //向上滑    UISwipeGestureRecognizerDirectionDown  = 1 &lt;&lt; 3  //向下滑};NS_CLASS_AVAILABLE_IOS(3_2) @interface UISwipeGestureRecognizer : UIGestureRecognizer //最少触摸手指个数，默认为1@property(nonatomic) NSUInteger                        numberOfTouchesRequired; //设置轻扫手势支持的方向，默认为向右滑@property(nonatomic) UISwipeGestureRecognizerDirection direction;               @end</code></pre><pre><code>//默认轻扫的方向是往右,如果以后想要一个控件支持多个方向的轻扫，必须创建多个轻扫手势，一个轻扫手势只支持一个方向。    UISwipeGestureRecognizer *swipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe)];    swipe.direction = UISwipeGestureRecognizerDirectionUp;UIRotationGestureRecognizer：//默认传递的旋转的角度都是相对于最开始的位置- (void)rotation:(UIRotationGestureRecognizer *)rotation{    self.imageView.transform = CGAffineTransformRotate(self.imageView.transform, rotation.rotation);    // 复位    rotation.rotation = 0;    // 获取手势旋转的角度    NSLog(@&quot;%f&quot;,rotation.rotation);}</code></pre><h2 id="UIRotationGestureRecognizer（旋转手势）"><a href="#UIRotationGestureRecognizer（旋转手势）" class="headerlink" title="UIRotationGestureRecognizer（旋转手势）"></a>UIRotationGestureRecognizer（旋转手势）</h2><pre><code>NS_CLASS_AVAILABLE_IOS(3_2) @interface UIRotationGestureRecognizer : UIGestureRecognizer//旋转的角度@property (nonatomic)          CGFloat rotation;  //旋转速度，单位：度/秒、         @property (nonatomic,readonly) CGFloat velocity;           @end</code></pre><pre><code>//为图片框添加一个旋转手势UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotateAction:)];rotation.delegate = self;[self.imgView addGestureRecognizer:rotation];// 旋转手势的监听方法- (void)rotateAction:(UIRotationGestureRecognizer *)recognizer {// 在原来的基础上, 累加多少度recognizer.view.transform = CGAffineTransformRotate(recognizer.view.transform, recognizer.rotation);// 每次旋转完毕后将rotation的值, 恢复到0的位置.recognizer.rotation = 0;}</code></pre><h2 id="UIPinchGestureRecognizer（捏合手势，缩放用）："><a href="#UIPinchGestureRecognizer（捏合手势，缩放用）：" class="headerlink" title="UIPinchGestureRecognizer（捏合手势，缩放用）："></a>UIPinchGestureRecognizer（捏合手势，缩放用）：</h2><pre><code>NS_CLASS_AVAILABLE_IOS(3_2) @interface UIPinchGestureRecognizer : UIGestureRecognizer //设置缩放比例@property (nonatomic)          CGFloat scale;     //获取捏合速度，单位：缩放比/秒         @property (nonatomic,readonly) CGFloat velocity;            @end</code></pre><pre><code>UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchAction:)];pinch.delegate = self;[self.imgView addGestureRecognizer:pinch];// 捏合手势监听方法- (void)pinchAction:(UIPinchGestureRecognizer *)recognizer {recognizer.view.transform = CGAffineTransformScale(recognizer.view.transform, recognizer.scale, recognizer.scale);recognizer.scale = 1.0;}</code></pre><pre><code>- (void)pinch:(UIPinchGestureRecognizer *)pinch {//捏合手势    self.imageView.transform = CGAffineTransformScale(self.imageView.transform, pinch.scale, pinch.scale);    // 复位    pinch.scale = 1;}</code></pre><h2 id="UIPanGestureRecognizer（拖拽手势）："><a href="#UIPanGestureRecognizer（拖拽手势）：" class="headerlink" title="UIPanGestureRecognizer（拖拽手势）："></a>UIPanGestureRecognizer（拖拽手势）：</h2><pre><code>NS_CLASS_AVAILABLE_IOS(3_2) @interface UIPanGestureRecognizer : UIGestureRecognizer //设置触发拖拽最少手指数，默认为1@property (nonatomic)          NSUInteger minimumNumberOfTouches;   //设置触发拖拽最多手指数，默认为 UINT_MAX 无限大@property (nonatomic)          NSUInteger maximumNumberOfTouches;   //获取当前拖拽位置- (CGPoint)translationInView:(nullable UIView *)view;                        //设置当前拖拽位置- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;//设置拖拽速度，单位：像素/秒- (CGPoint)velocityInView:(nullable UIView *)view;                          @end</code></pre><pre><code>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)];[self.imgView addGestureRecognizer:pan];// 拖拽手势的监听方法- (void)panAction:(UIPanGestureRecognizer *)recognizer {// 1. 获取手指拖拽的时候, 平移的值CGPoint translation = [recognizer translationInView:recognizer.view];// 2. 让当前控件做响应的平移recognizer.view.transform = CGAffineTransformTranslate(recognizer.view.transform, translation.x, translation.y);// 3. 每次平移手势识别完毕后, 让平移的值不要累加[recognizer setTranslation:CGPointZero inView:recognizer.view];}</code></pre><pre><code>- (void)pan:(UIPanGestureRecognizer *)pan{    // 获取手势的触摸点   // CGPoint curP = [pan locationInView:self.imageView];    // 移动视图    // 获取手势的移动，也是相对于最开始的位置    CGPoint transP = [pan translationInView:self.imageView];    self.imageView.transform = CGAffineTransformTranslate(self.imageView.transform, transP.x, transP.y);    // 复位    [pan setTranslation:CGPointZero inView:self.imageView];  //  NSLog(@&quot;%@&quot;,NSStringFromCGPoint(curP));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> 手势识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift基础总结</title>
      <link href="/2017/03/15/2017-03-15-swift-ji-chu-zong-jie/"/>
      <url>/2017/03/15/2017-03-15-swift-ji-chu-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>声明常量和变量</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> maximumNumberOfLoginAttempts <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">var</span> currentLoginAttempt <span class="token operator">=</span> <span class="token number">0</span></code></pre><p>这两行代码可以被理解为:<br>“声明一个名字是 maximumNumberOfLoginAttempts 的新常量，并给它一个值 10 。然后，声明一个名字是<br>rrentLoginAttempt 的变量并将它的值初始化为 0 。”在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为<br>一个变量，因为每次尝试登录失败的时候都需要增加这个值。<br>你可以在一行中声明多个常量或者多个变量，用逗号隔开:</p><pre><code>var x = 0.0, y = 0.0, z = 0.0</code></pre><ul><li>类型标注</li><li>当你声明常量或者变量的时候可以加上类型标注(type annotation)，说明常量或者变量中要存储的值的类 型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</li></ul><pre><code>var welcomeMessage: String</code></pre><p>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为: “声明一个类型为 String ，名字为 welcomeMessage 的变量。”<br>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注:</p><pre><code>var red, green, blue: Double</code></pre><p>注意: 一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常 量或者变量的类型，请参考类型安全和类型推断 (页 0)。在上面的例子中，没有给 welcomeMessage 赋初始 值，所以变量 welcomeMessage 的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p><ul><li>整数</li><li>整数就是没有小数部分的数字，比如 42 和 -23 。整数可以是 有符号 (正、负、零)或者 无符号 (正、零)。Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无 符号整数类型是 UInt8 ，32位有符号整数类型是 Int32 。就像 Swift 的其他类型一样，整数类型采用大写命名 法。</li><li>你可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值:</li></ul><pre><code>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8</code></pre><ul><li>浮点数是有小数部分的数字，比如 3.14159 ，0.1 和 -273.15。<br>浮点类型比整数类型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有符号浮 点数类型:<br>• Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。 • Float表示32位浮点数。精度要求不高的话可以使用此类型。<br>注意:<br>Double 精确度很高，至少有15位数字，而 Float 只有6位数字。选择哪个类型取决于你的代码需要处理的值的<br>范围，在两种类型都匹配的情况下，将优先选择 Double 。</li><li>类型安全和类型推断</li><li>Swift 是一个类型安全(type safe)的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果<br>你的代码需要一个 String ，你绝对不可能不小心传进去一个 Int 。<br>由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查(type checks)，并把不匹配的类型标记 为错误。这可以让你在开发的时候尽早发现并修复错误。当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需 要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断(type inference)来选择合适的类型。有 了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。<br>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但 是大部分工作并不需要你自己来完成。</li><li>整数字面量可以被写作:<ul><li>一个十进制数，没有前缀</li><li>一个二进制数，前缀是 0b</li><li>一个八进制数，前缀是 0o</li><li>一个十六进制数，前缀是 0x</li></ul></li><li>下面的所有整数字面量的十进制值都是 17 :</li></ul><pre><code>let decimalInteger = 17let binaryInteger = 0b10001       // 17 in binary notationlet octalInteger = 0o21           // 17 in octal notationlet hexadecimalInteger = 0x11     // 17 in hexadecimal notation</code></pre><ul><li>如果一个十进制数的指数为 exp ，那这个数相当于基数和10^exp的乘积: • 1.25e2 表示 1.25 × 10^2，等于 125.0 。<br>• 1.25e-2 表示 1.25 × 10^-2，等于 0.0125 。 如果一个十六进制数的指数为 exp ，那这个数相当于基数和2^exp的乘积:<br>• 0xFp2 表示 15 × 2^2，等于 60.0 。 • 0xFp-2 表示 15 × 2^-2，等于 3.75 。</li><li>下面的这些浮点字面量都等于十进制的 12.1875 :</li></ul><pre><code>let decimalDouble = 12.1875let exponentDouble = 1.21875e1let hexadecimalDouble = 0xC.3p0</code></pre><ul><li>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影<br>响字面量:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> paddedDouble <span class="token operator">=</span> <span class="token number">000123.456</span><span class="token keyword">let</span> oneMillion <span class="token operator">=</span> <span class="token number">1_000_000</span><span class="token keyword">let</span> justOverOneMillion <span class="token operator">=</span> <span class="token number">1_000_000.000_000_1</span></code></pre><h3 id="数值型类型转换"><a href="#数值型类型转换" class="headerlink" title="数值型类型转换"></a>数值型类型转换</h3><ul><li>通常来讲，即使代码中的整数常量和变量已知非负，也请使用 Int 类型。总是使用默认的整数类型可以保证你的 整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。</li><li>只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等<br>等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。<h4 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h4></li><li>不同整数类型的变量和常量可以存储不同范围的数字。 Int8 类型的常量或者变量可以存储的数字范围是 -128 ~ 1 27 ，而 UInt8 类型的常量或者变量能存储的数字范围是 0 ~ 255 。如果数字超出了常量或者变量可存储的范 围，编译的时候会报错:</li></ul><pre><code>let cannotBeNegative: UInt8 = -1// UInt8 cannot store negative numbers, and so this will report an errorlet tooBig: Int8 = Int8.max + 1// Int8 cannot store a number larger than its maximum value,// and so this will also report an error</code></pre><ul><li>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性<br>使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</li><li>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标 类型。在下面的例子中，常量 twoThousand 是 UInt16 类型，然而常量 one 是 UInt8 类型。它们不能直接相 加，因为它们类型不同。所以要调用 UInt16(one) 来创建一个新的 UInt16 数字并用 one 的值来初始化，然后使用 这个新数字来计算:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> twoThousand<span class="token punctuation">:</span> <span class="token builtin">UInt16</span> <span class="token operator">=</span> <span class="token number">2_000</span><span class="token keyword">let</span> one<span class="token punctuation">:</span> <span class="token builtin">UInt8</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">let</span> twoThousandAndOne <span class="token operator">=</span> twoThousand <span class="token operator">+</span> <span class="token function">UInt16</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span></code></pre><ul><li>现在两个数字的类型都是 UInt16 ，可以进行相加。目标常量 twoThousandAndOne 的类型被推断为 UInt1 6 ，因为它是两个 UInt16 值的和。</li><li>SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部， UInt16 有一个 构造器，可以接受一个 UInt8 类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16 。注 意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。不过你可以扩展现有的类型来让它 可以接收其他类型的值(包括自定义类型)，请参考扩展。<h4 id="整数和浮点数转换"><a href="#整数和浮点数转换" class="headerlink" title="整数和浮点数转换"></a>整数和浮点数转换</h4></li><li>整数和浮点数的转换必须显式指定类型:</li></ul><pre><code>let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine // pi 等于 3.14159，所以被推测为 Double 类型//let pipai = three + pointOneFourOneFiveNine//errorlet pai = 3 + 0.12</code></pre><p>这个例子中，常量 three 的值被用来创建一个 Double 类型的值，所以加号两边的数类型须相同。如果不进行 转换，两者无法相加。</p><ul><li>浮点数到整数转换也必须明确。整数类型可以使用一个Double或Float类型来进行初始化：</li></ul><pre><code>let integerPi = Int(pi)// integerPi 等于 3，所以被推测为 Int 类型</code></pre><p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 4.75 会变成 4 ， -3.9 会变成 -3 。</p><ul><li>注意:<br>结合数字类常量和变量不同于结合数字类字面量。字面量 3 可以直接和字面量 0.14159 相加，因为数字字面量 本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4></li><li>类型别名(type aliases)就是给现有类型定义另一个名字。你可以使用 typealias 关键字来定义类型别名。<br>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数<br>据:</li></ul><pre><code>typealias AudioSample = UInt16</code></pre><ul><li>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名:</li></ul><pre><code>var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0</code></pre><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><ul><li>Swift 有一个基本的布尔(Boolean)类型，叫做 Bool 。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false:</li></ul><pre><code>let orangesAreOrange = truelet turnipsAreDelicious = falseif turnipsAreDelicious {    print(&quot;Mmm, tasty turnips!&quot;)} else {    print(&quot;Eww, turnips are horrible.&quot;)}// Prints &quot;Eww, turnips are horrible.&quot;</code></pre><ul><li>如果你在需要使用 Bool 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编 译时错误:</li></ul><pre><code>let i = 1if i {    // this example will not compile, and will report an error    //error: &#39;Int&#39; is not convertible to &#39;Bool&#39;}</code></pre><p>但是，下面的替代示例是有效的：</p><pre><code>let i = 1if i == 1 {    // this example will compile successfully}</code></pre><p>i == 1 的比较结果是 Bool 类型，所以第二个例子可以通过类型检查。类似 i == 1 这样的比较，请参考基 本操作符。<br>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul><li>元组(tuples)把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。<br>下面这个例子中， (404, “Not Found”) 是一个描述 HTTP 状态码(HTTP status code)的元组。HTTP 状态码是 当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个 404 Not Found 状 态码。</li></ul><pre><code>let http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</code></pre><ul><li>元组把一个int值和一个String值组合起来表示 HTTP 状态码的两个部分:一个数字 和一个人类可读的描述。这个元组可以被描述为“一个类型为(Int, String)的元组”。</li><li>你可以将一个元组的内容分解(decompose)成单独的常量和变量，然后你就可以正常使用它们了:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> http404Error <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span> <span class="token string">"Not Found"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")</span><span class="token keyword">let</span> <span class="token punctuation">(</span>statusCode<span class="token punctuation">,</span> statusMessage<span class="token punctuation">)</span> <span class="token operator">=</span> http404Error<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The status code is <span class="token interpolation"><span class="token delimiter variable">\(</span>statusCode<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "The status code is 404"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The status message is <span class="token interpolation"><span class="token delimiter variable">\(</span>statusMessage<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "The status message is Not Found"</span></code></pre><ul><li>如果只需要一些元组的值，则在分解元组时，忽略元组的下划线（_）：</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>justTheStatusCode<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> http404Error<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The status code is <span class="token interpolation"><span class="token delimiter variable">\(</span>justTheStatusCode<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "The status code is 404"</span></code></pre><ul><li>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始:</li></ul><pre><code>print(&quot;The status code is \(http404Error.0)&quot;)// Prints &quot;The status code is 404&quot;print(&quot;The status message is \(http404Error.1)&quot;)// Prints &quot;The status message is Not Found&quot;</code></pre><ul><li>你可以在定义元组的时候给单个元素命名:</li></ul><pre><code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)</code></pre><ul><li>给元组中的元素命名后，你可以通过名字来获取这些元素的值:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> http200Status <span class="token operator">=</span> <span class="token punctuation">(</span>statusCode<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> description<span class="token punctuation">:</span> <span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The status code is <span class="token interpolation"><span class="token delimiter variable">\(</span>http200Status<span class="token punctuation">.</span>statusCode<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "The status code is 200"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The status message is <span class="token interpolation"><span class="token delimiter variable">\(</span>http200Status<span class="token punctuation">.</span>description<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Prints "The status message is OK"</span></code></pre><ul><li>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 (Int, String) 元组来描述是否 获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有 用。请参考函数参数与返回值 (页 0)。</li><li>注意:<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使<br>用类或者结构体而不是元组。请参考类和结构体。<h4 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h4></li><li>使用可选类型(optionals)来处理值可能缺失的情况。</li><li>注意:<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一 个对象要不返回 nil ， nil 表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值(比如 NSNotFoun<br>d )来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让 你暗示任意类型的值缺失，并不需要一个特殊值。</li><li>来看一个例子。Swift 的 Int 类型有一种构造器，作用是将一个 String 值转换成一个 Int 值。然而，并 不是所有的字符串都可以转换成一个整数。字符串 “123” 可以被转换成数字 123 ，但是字符串 “hello, wor ld” 不行。</li><li>下面的例子使用这种构造器来尝试将一个 String 转换成 Int :</li></ul><pre><code>let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber)// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</code></pre><ul><li>你可以给可选变量赋值为 nil 来表示它没有值:</li></ul><pre><code>var serverResponseCode: Int? = 404// serverResponseCode 包含一个可选的 Int 值 404serverResponseCode = nil// serverResponseCode 现在不包含值var server = 400server = nil//nil cannot be assigned to type &#39;Int&#39;</code></pre><p>注意:<br>nil 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成<br>对应的可选类型。</p><ul><li>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil :</li></ul><pre><code>var surveyAnswer: String?// surveyAnswer 被自动设置为 nil</code></pre><p>注意:<br>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中， nil 是一个指向不存在对象的指 针。在 Swift 中， nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设 置为 nil ，不只是对象类型。</p><h4 id="if-语句以及强制解析"><a href="#if-语句以及强制解析" class="headerlink" title="if 语句以及强制解析"></a>if 语句以及强制解析</h4><ul><li>你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。你可以使用“相等”(==)或“不 等”( != )来执行比较。<br>如果可选类型有值，它将不等于 nil :</li></ul><pre><code>if convertedNumber != nil {    print(&quot;convertedNumber contains some integer value.&quot;)}// 输出 &quot;convertedNumber contains some integer value.&quot;</code></pre><ul><li>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号( ! )来获取值。这个惊叹号表 示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析(forced unwrapping):</li></ul><pre><code>if convertedNumber != nil {    print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)}// 输出 &quot;convertedNumber has an integer value of 123.&quot;</code></pre><ul><li>注意:<br>使用 ! 来获取一个不存在的可选值会导致运行时错误。使用 ! 来强制解析值之前，一定要确定可选包含一 个非 nil 的值。<h4 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h4></li><li>使用可选绑定(optional binding)来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变 量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将 可选类型中的值赋给一个常量或者变量。if 和 while 语句，请参考控制流。<br>像下面这样在 if 语句中写一个可选绑定:</li></ul><pre><code>如果 let  constantName = someOptional {    声明}</code></pre><ul><li>你可以像上面这样使用可选绑定来重写 possibleNumber:</li></ul><pre><code>if let actualNumber = Int(possibleNumber) {    print(&quot;\&#39;\(possibleNumber)\&#39; has an integer value of \(actualNumber)&quot;)} else {    print(&quot;\&#39;\(possibleNumber)\&#39; could not be converted to an integer&quot;)}// 输出 &quot;&#39;123&#39; has an integer value of 123&quot;</code></pre><p>这段代码可以被理解为:<br>“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选 包含的值赋给它。”<br>如果转换成功， actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化 过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。<br>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作 actualNumber 的值，你可以改 成 if var actualNumber ，这样可选类型包含的值就会被赋给一个变量而非常量。</p><ul><li>你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定 的值为nil，或者任意一个布尔条件为false，则整个if条件判断为false，这时你就需要使用嵌套 if 条 件语句来处理，如下所示:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> firstNumber <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">let</span> secondNumber <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"42"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> firstNumber <span class="token operator">&lt;</span> secondNumber <span class="token operator">&amp;&amp;</span> secondNumber <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>firstNumber<span class="token delimiter variable">)</span></span> &lt; <span class="token interpolation"><span class="token delimiter variable">\(</span>secondNumber<span class="token delimiter variable">)</span></span> &lt; 100"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Prints "4 &lt; 42 &lt; 100"</span><span class="token keyword">if</span> <span class="token keyword">let</span> firstNumber <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">let</span> secondNumber <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"42"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> firstNumber <span class="token operator">&lt;</span> secondNumber <span class="token operator">&amp;&amp;</span> secondNumber <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>firstNumber<span class="token delimiter variable">)</span></span> &lt; <span class="token interpolation"><span class="token delimiter variable">\(</span>secondNumber<span class="token delimiter variable">)</span></span> &lt; 100"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Prints "4 &lt; 42 &lt; 100"</span></code></pre><p>注意: 在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的句中( body )中才能获取到 值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取 到值，请参考提前退出。</p><h4 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h4><ul><li>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的 话可以通过可选绑定来解析值。<br>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解<br>析可选值是非常低效的，因为可以确定它总会有值。<br>这种类型的可选状态被定义为隐式解析可选类型(implicitly unwrapped optionals)。把想要用作可选的类型 的后面的问号( String? )改成感叹号( String! )来声明一个隐式解析可选类型。当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型 主要被用在 Swift 中类的构造过程中，请参考无主引用以及隐式解析可选属性 (页 0)。</li><li>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用 解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别:</li></ul><pre><code>let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // requires an exclamation mark(!)需要感叹号来获取值let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString // no need for an exclamation mark(!)不需要感叹号</code></pre><p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结<br>尾，而不是每次取值的可选名字的结尾。</p><ul><li>注意:<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一<br>个惊叹号一样。</li><li>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值:</li></ul><pre><code>if assumedString != nil {    print(assumedString)}// 输出 &quot;An implicitly unwrapped optional string.&quot;</code></pre><ul><li>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值:</li></ul><pre><code>if let definiteString = assumedString {    print(definiteString)}// 输出 &quot;An implicitly unwrapped optional string.&quot;</code></pre><p>注意:<br>如果一个变量之后可能变成 nil 的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否 是 nil 的话，请使用普通可选类型。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>你可以使用 错误处理(error handling) 来应对程序执行中可能会遇到的错误条件。<br>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其<br>他部分。<br>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</li></ul><pre><code>func canThrowAnError() throws {    // 这个函数有可能抛出错误}</code></pre><ul><li>一个函数可以通过在声明中添加 throws 关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式 中前置 try 关键词。</li></ul><pre><code>do {try canThrowAnError() // 没有错误消息抛出} catch {// 有一个错误消息抛出}</code></pre><ul><li>一个 do 语句创建了一个新的包含作用域,使得错误能被传播到一个或多个 catch 从句。 这里有一个错误处理如何用来应对不同错误条件的例子。</li></ul><pre><code>func makeASandwich() throws {    // ...}do {    try makeASandwich()    eatASandwich()} catch SandwichError.outOfCleanDishes {    washDishes()} catch SandwichError.missingIngredients(let ingredients) {    buyGroceries(ingredients)}</code></pre><p>在这个例子中，makeASandwich()如果没有干净的菜肴或缺少任何成分，该功能将会发出错误。因为makeASandwich()可以引发错误，函数调用被包装在一个try表达式中。通过将函数调用包含在do语句中，抛出的任何错误将被传播到提供的catch子句。</p><p>如果没有引发错误，eatASandwich()则调用该函数。如果抛出一个错误并匹配该错误SandwichError.outOfCleanDishes，那么该washDishes()函数将被调用。如果抛出一个错误，并且匹配该SandwichError.missingIngredients情况，则使用该模式捕获buyGroceries(_:)的关联[String]值调用该函数catch。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><ul><li>可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺 失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个 断言(asse rtion) 来结束代码运行并通过调试来找到值缺失的原因。</li><li>使用断言进行调试</li><li>断言会在运行时判断一个逻辑条件是否为 true 。从字面意思来说，断言“断言”一个条件是否为真。你可以使 用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为 true ，代码运行会继续进 行;如果条件判断为 false ，代码执行结束，你的应用被终止。<br>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法 的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。<br>你可以使用全局 assert(<em>:</em>:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示:</li></ul><pre><code>let age = -3assert(age &gt;= 0, &quot;A person&#39;s age cannot be less than zero&quot;) // 因为 age &lt; 0，所以断言会触发</code></pre><p> 在这个例子中，只有 age &gt;= 0 为 true 的时候，即 age 的值非负的时候，代码才会继续执行。如果age 的值是负数，就像代码中那样， age &gt;= 0 为 false ，断言被触发，终止应用。<br>如果不需要断言信息，可以省略，就像这样:</p><pre><code>assert(age &gt;= 0)</code></pre><ul><li>注意:<br>当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 bu ild 时，断言会被禁用。<h5 id="何时使用断言"><a href="#何时使用断言" class="headerlink" title="何时使用断言"></a>何时使用断言</h5></li><li>当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景:<ul><li>整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。</li><li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li><li>一个可选值现在是 nil ，但是后面的代码运行需要一个非 nil 值。</li></ul></li><li>注意:<br>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布<br>之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4></li><li>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量:</li></ul><pre><code>let (x, y) = (1, 2)// 现在 x 等于 1，y 等于 2</code></pre><ul><li>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的:</li></ul><pre><code>if x = y {// 此句错误, 因为 x = y 并不返回任何值}</code></pre><p>这个特性使你无法把( == )错写成( = )，由于 if x = y 是错误代码，Swift 能帮你避免此类错误发生。</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><ul><li>与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Sw ift 的溢出运算符来实现溢出运算(如 a &amp;+ b )。详情参见溢出运算符 (页 0)。加法运算符也可用于 String 的拼接:</li></ul><pre><code>&quot;hello, &quot; + &quot;world&quot; // 等于 &quot;hello, world&quot;</code></pre><ul><li>当元组中的值可以比较时，你也可以使用这些运算符来比较它们的大小。例如，因为 Int 和 String 类型的值 可以比较，所以类型为 (Int, String) 的元组也可以被比较。相反， Bool 不能被比较，也意味着存有布尔类 型的元组不能被比较。<br>比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这<br>一对元组我们就称它们是相等的。例如:</li></ul><pre><code>(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;)// true，因为 1 小于 2(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;)// true，因为 3 等于 3，但是 apple 小于 bird(4, &quot;dog&quot;) == (4, &quot;dog&quot;)// true，因为 4 等于 4，dog 等于 dog</code></pre><p>在上面的例子中，你可以看到，在第一行中从左到右的比较行为。因为 1 小于 2 ，所以 (1, “zebra”) 小于 (2, “apple”) ，不管元组剩下的值如何。所以 “zebra” 小于 “apple” 没有任何影响，因为元组的比较已经被第一个元 素决定了。不过，当元组的第一个元素相同时候，第二个元素将会用作比较-第二行和第三行代码就发生了这样的 比较。</p><ul><li>注意:<br>Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算 符。<h4 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符(Nil Coalescing Operator)"></a>空合运算符(Nil Coalescing Operator)</h4><ul><li>空合运算符( a ?? b )将对可选类型 a 进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认<br>值 b 。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。 空合运算符是对以下代码的简短表达方法:</li></ul></li></ul><pre><code>a != nil ? a! : b</code></pre><p>上述代码使用了三目运算符。当可选类型 a 的值不为空时，进行强制解封(a!)，访问 a 中的值;反之返 回默认值 b 。无疑空合运算符( ?? )提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以 及更具可读性。</p><ul><li>注意: 如果 a 为非空值( non-nil )，那么值 b 将不会被计算。这也就是所谓的短路求值。下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择:</li></ul><pre><code>let defaultColorName = &quot;red&quot;var userDefinedColorName: String? //默认值为 nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;</code></pre><p>userDefinedColorName 变量被定义为一个可选的 String 类型，默认值为 nil 。由于 是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为 eToUse 的变量赋予一个字符串类型初始值。 由于 userDefinedColorName 值为空，因此表达式 lorName ?? defaultColorName 返回 defaultColorName 的值，即 red 。</p><ul><li>另一种情况，分配一个非空值( non-nil )给 userDefinedColorName ，再次执行空合运算，运算结果为封包在 userDefaultColorName 中的值，而非默认值。</li></ul><pre><code>userDefinedColorName = &quot;green&quot;colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 非空，因此 colorNameToUse 的值为 &quot;green&quot;</code></pre><h4 id="区间运算符-Range-Operators"><a href="#区间运算符-Range-Operators" class="headerlink" title="区间运算符(Range Operators)"></a>区间运算符(Range Operators)</h4><ul><li>闭区间运算符</li><li>闭区间运算符( a…b )定义一个包含从 a 到 b (包括 a 和 b )的所有值的区间。 a 的值不能超过 b 。 ? 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在 for-in 循环中:</li></ul><pre><code>for index in 1...5 {    print(&quot;\(index) * 5 = \(index * 5)&quot;)}// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20// 5 * 5 = 25</code></pre><ul><li>半开区间运算符</li><li>半开区间运算符( a..&lt;b )定义一个从 a 到 b 但不包括 b 的区间。 之所以称为半开区间，是因为该区间 包含第一个值而不包括最后的值。</li><li>半开区间的实用性在于当你使用一个从 0 开始的列表(如数组)时，非常方便地从0数到列表的长度。</li></ul><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]let count = names.countfor i in 0..&lt;count {    print(&quot;第 \(i + 1) 个人叫 \(names[i])&quot;)}// 第 1 个人叫 Anna // 第 2 个人叫 Alex // 第 3 个人叫 Brian // 第 4 个人叫 Jack</code></pre><h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><h4 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h4><ul><li>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的 String 实例:</li></ul><pre><code>var emptyString = &quot;&quot; // 空字符串字面量 var anotherEmptyString = String() // 初始化方法// 两个字符串均为空并等价。</code></pre><ul><li>您可以通过检查其 Bool 类型的 isEmpty 属性来判断该字符串是否为空:</li></ul><pre><code>if emptyString.isEmpty {    print(&quot;Nothing to see here&quot;)}// 打印输出:&quot;Nothing to see here&quot;</code></pre><h4 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h4><ul><li>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改:</li></ul><pre><code>var variableString = &quot;Horse&quot;variableString += &quot; and carriage&quot;// variableString 现在为 &quot;Horse and carriage&quot;let constantString = &quot;Highlander&quot;constantString += &quot; and another Highlander&quot;// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。</code></pre><ul><li>注意:<br>在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类( NSString 和 NSMutableString )来指定字符串是 否可以被修改。<h4 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h4></li><li>Swift 的 String 类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/ 方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操 作。 值类型在 结构体和枚举是值类型 (页 0) 中进行了详细描述。<br>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您 独自拥有的。 您可以确信传递的字符串不会被修改，除非你自己去修改它。<br>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字 符串作为值类型的同时可以获得极高的性能。<h4 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h4></li><li>您可通过 for-in 循环来遍历字符串中的 characters 属性来获取每一个字符的值:</li></ul><pre><code>for character in &quot;Dog!?&quot;.characters {    print(character)}// D// o// g// !// ?</code></pre><ul><li>另外，通过标明一个 Character 类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量:</li></ul><pre><code>let exclamationMark: Character = &quot;!&quot;</code></pre><ul><li>字符串可以通过传递一个值类型为 Character 的数组作为自变量来初始化:</li></ul><pre><code>let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]let catString = String(catCharacters)print(catString)// 打印输出:&quot;Cat!?&quot;</code></pre><h4 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h4><ul><li>字符串可以通过加法运算符( + )相加在一起(或称“连接”)创建一个新的字符串:</li></ul><pre><code>let string1 = &quot;hello&quot;let string2 = &quot; there&quot;var welcome = string1 + string2 // welcome 现在等于 &quot;hello there&quot;</code></pre><ul><li>您也可以通过加法赋值运算符 ( += ) 将一个字符串添加到一个已经存在字符串变量上:</li></ul><pre><code>var instruction = &quot;look over&quot;instruction += string2// instruction 现在等于 &quot;look over there&quot;</code></pre><ul><li>您可以用 append() 方法将一个字符附加到一个字符串变量的尾部:</li></ul><pre><code>let exclamationMark: Character = &quot;!&quot;welcome.append(exclamationMark)// welcome 现在等于 &quot;hello there!&quot;</code></pre><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><ul><li>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。 您插入的字符串字面量 的每一项都在以反斜线为前缀的圆括号中:</li></ul><pre><code>let multiplier = 3let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;// message 是 &quot;3 times 2.5 is 7.5&quot;</code></pre><h4 id="字符串字面量的特殊字符"><a href="#字符串字面量的特殊字符" class="headerlink" title="字符串字面量的特殊字符"></a>字符串字面量的特殊字符</h4><ul><li>字符串字面量可以包含以下特殊字符:<br>• 转义字符 \0 (空字符)、 \ (反斜线)、 \t (水平制表符)、 \n (换行符)、 \r (回车符)、 &quot; (双引<br>号)、 &#39; (单引号)。<br>• Unicode 标量，写成 \u{n} (u为小写)，其中 n 为任意一到八位十六进制数且可用的 Unicode 位码。<br>下面的代码为各种特殊字符的使用示例。 wiseWords 常量包含了两个双引号。 dollarSign 、 blackHeart 和 rklingHeart 常量演示了三种不同格式的 Unicode 标量:</li></ul><pre><code>let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;// &quot;Imagination is more important than knowledge&quot; - Einsteinlet dollarSign = &quot;\u{24}&quot;        // $,  Unicode scalar U+0024let blackHeart = &quot;\u{2665}&quot;      // ♥,  Unicode scalar U+2665let sparklingHeart = &quot;\u{1F496}&quot; // 💖, Unicode scalar U+1F496</code></pre><h4 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h4><ul><li>如果想要获得一个字符串中 Character 值的数量，可以使用字符串的 characters 属性的 count 属性:</li></ul><pre><code>let unusualMenagerie = &quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;print(&quot;unusualMenagerie has \(unusualMenagerie.characters.count) characters&quot;)// Prints &quot;unusualMenagerie has 40 characters&quot;</code></pre><h4 id="访问和修改字符串"><a href="#访问和修改字符串" class="headerlink" title="访问和修改字符串"></a>访问和修改字符串</h4><ul><li>每个String值都有一个相关联的索引类型，String.Index它对应于每个Character字符串中的位置。</li><li>使用startIndex属性访问Charactera 的第一个位置String。该endIndex属性是最后一个字符之后的位置String。因此，该endIndex属性不是字符串下标的有效参数。如果a String是空的，startIndex并且endIndex是相等的。<ul><li>您可以使用index(before:)and index(after:)方法访问给定索引之前和之后的索引String。要访问远离给定索引的索引，可以使用该index(_:offsetBy:)方法，而不是多次调用这些方法之一。</li><li>您可以使用下标语法访问Character特定的String索引。</li></ul></li></ul><pre><code>let Mygreeting = &quot;Guten Tag!&quot;Mygreeting[Mygreeting.startIndex]// GMygreeting[Mygreeting.index(before: Mygreeting.endIndex)]// !Mygreeting[Mygreeting.index(after: Mygreeting.startIndex)]// ulet index = Mygreeting.index(Mygreeting.startIndex, offsetBy: 7)Mygreeting[index]// a</code></pre><ul><li>试图获取越界索引对应的 Character ，将引发一个运行时错误。</li></ul><pre><code>Mygreeting[Mygreeting.endIndex] // errorMygreeting.index(after: endIndex) // error</code></pre><ul><li>使用该indices属性访问字符串中各个字符的所有索引。</li></ul><pre><code>for index in Mygreeting.characters.indices {    print(&quot;\(Mygreeting[index]) &quot;, terminator: &quot;&quot;)}// Prints &quot;G u t e n   T a g ! &quot;</code></pre><ul><li>注意:<br>您可以使用 startIndex 和 endIndex 属性或者 index(before:) 、 index(after:) 和 index(_:offsetB y:) 方法在任意一个确认的并遵循 Collection 协议的类型里面，如上文所示是使用在 String 中，您也可 以使用在 Array 、 Dictionary 和 Set 中。<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4></li><li>要将单个字符插入到指定索引的字符串中，请使用该insert(_:at:)方法，并将另一个字符串的内容插入指定的索引，请使用该insert(contentsOf:at:)方法。</li></ul><pre><code>var myWelcome = &quot;hello&quot;myWelcome.insert(&quot;!&quot;, at: myWelcome.endIndex) // welcome 变量现在等于 &quot;hello!&quot;myWelcome.insert(contentsOf:&quot; there&quot;.characters, at: myWelcome.index(before: myWelcome.endIndex))// welcome 变量现在等于 &quot;hello there!&quot;</code></pre><ul><li>调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以在一 个字符串的指定索引删除一个子字符串。</li></ul><pre class=" language-swift"><code class="language-swift">myWelcome<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> myWelcome<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>before<span class="token punctuation">:</span> myWelcome<span class="token punctuation">.</span>endIndex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// welcome 现在等于 "hello there"</span><span class="token keyword">let</span> range <span class="token operator">=</span> myWelcome<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>myWelcome<span class="token punctuation">.</span>endIndex<span class="token punctuation">,</span> offsetBy<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>myWelcome<span class="token punctuation">.</span>endIndexmyWelcome<span class="token punctuation">.</span><span class="token function">removeSubrange</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// welcome 现在等于 "hello"</span></code></pre><ul><li>注意: 您可以使用 insert(<em>:at:) 、 insert(contentsOf:at:) 、 remove(at:) 和 removeSubrange(</em>:) 方法 在任意一个确认的并遵循 RangeReplaceableCollection 协议的类型里面，如上文所示是使用在 String 中，您也可以使用在 Array、Dictionary 和 Set 中。<h4 id="子字符串Substrings"><a href="#子字符串Substrings" class="headerlink" title="子字符串Substrings"></a>子字符串Substrings</h4></li><li>当您从字符串中获取子字符串时，例如，使用下标或类似方法，prefix(_:)结果是一个实例Substring，而不是另一个字符串。Swift中的子字符串具有与字符串大致相同的方法，这意味着您可以使用字符串等子字符串。与字符串不同，在对字符串执行操作时，您只需要很短的时间来使用子字符串。当您准备好将结果存储较长时间后，您可以将子字符串转换为实例String。例如：</li></ul><pre><code>let greeting = &quot;Hello, world!&quot;let index = greeting.index(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning is &quot;Hello&quot;// Convert the result to a String for long-term storage.let newString = String(beginning)</code></pre><ul><li><p>像字符串一样，每个子字符串都有一个内存区域，其中存储组成子字符串的字符。字符串和子串之间的区别在于，作为性能优化，子字符串可以重新使用用于存储原始字符串或用于存储另一个子字符串的内存的一部分的内存部分。（Strings有一个类似的优化，但是如果两个字符串共享内存，它们是相等的。）这个性能优化意味着你不必支付复制内存的性能成本，直到你修改字符串或子字符串。如上所述，子串不适合长期存储 - 因为它们重新使用原始字符串的存储，只要使用任何一个子字符串，整个原始字符串必须保存在存储器中。</p></li><li><p>在上面的例子中，greeting是一个字符串，这意味着它有一个内存区域，其中存储组成字符串的字符。因为beginning是一个子串greeting，它会重新使用所使用的内存greeting。相比之下，newString是一个字符串 - 当它从子字符串创建时，它有自己的存储。</p></li><li><p>注意：二者String和Substring符合StringProtocol协议。如果您正在编写操作字符串数据的代码，则接受一个StringProtocol值可以将该字符串数据作为一个String或多个Substring值传递。</p><h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4></li><li><p>Swift 提供了三种方式来比较文本值:字符串字符相等、前缀相等和后缀相等。</p></li><li><p>字符串/字符相等</p></li></ul><pre><code>let quotation = &quot;We&#39;re a lot alike, you and I.&quot;let sameQuotation = &quot;We&#39;re a lot alike, you and I.&quot;if quotation == sameQuotation {    print(&quot;These two strings are considered equal&quot;)}// 打印输出 &quot;These two strings are considered equal&quot;</code></pre><ul><li>前缀/后缀相等</li><li>通过调用字符串的 hasPrefix(<em>:) / hasSuffix(</em>:) 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一 个 String 类型的参数，并返回一个布尔值。<br>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置:</li></ul><pre><code>let romeoAndJuliet = [    &quot;Act 1 Scene 1: Verona, A public place&quot;,    &quot;Act 1 Scene 2: Capulet&#39;s mansion&quot;,    &quot;Act 1 Scene 3: A room in Capulet&#39;s mansion&quot;,    &quot;Act 1 Scene 4: A street outside Capulet&#39;s mansion&quot;,    &quot;Act 1 Scene 5: The Great Hall in Capulet&#39;s mansion&quot;,    &quot;Act 2 Scene 1: Outside Capulet&#39;s mansion&quot;,    &quot;Act 2 Scene 2: Capulet&#39;s orchard&quot;,    &quot;Act 2 Scene 3: Outside Friar Lawrence&#39;s cell&quot;,    &quot;Act 2 Scene 4: A street in Verona&quot;,    &quot;Act 2 Scene 5: Capulet&#39;s mansion&quot;,    &quot;Act 2 Scene 6: Friar Lawrence&#39;s cell&quot;]</code></pre><ul><li>您可以调用 hasPrefix(_:) 方法来计算话剧中第一幕的场景数:</li></ul><pre><code>var act1SceneCount = 0for scene in romeoAndJuliet {    if scene.hasPrefix(&quot;Act 1 &quot;) {        act1SceneCount += 1    } }print(&quot;There are \(act1SceneCount) scenes in Act 1&quot;) // 打印输出 &quot;There are 5 scenes in Act 1&quot;</code></pre><ul><li>相似地，您可以用 hasSuffix(_:) 方法来计算发生在不同地方的场景数:</li></ul><pre><code>var mansionCount = 0var cellCount = 0for scene in romeoAndJuliet {    if scene.hasSuffix(&quot;Capulet&#39;s mansion&quot;) {        mansionCount += 1    } else if scene.hasSuffix(&quot;Friar Lawrence&#39;s cell&quot;) {        cellCount += 1    } }print(&quot;\(mansionCount) mansion scenes; \(cellCount) cell scenes&quot;)// 打印输出 &quot;6 mansion scenes; 2 cell scenes&quot;</code></pre><hr><h2 id="集合类型-Collection-Types"><a href="#集合类型-Collection-Types" class="headerlink" title="集合类型 (Collection Types)"></a>集合类型 (Collection Types)</h2><ul><li>Swift 语言提供 Arrays 、 Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组(Arrays)是有序<br>数据的集。集合(Sets)是无序无重复数据的集。字典(Dictionaries)是无序的键值对的集。</li></ul><p>Swift 语言中的 Arrays 、 Sets 和 Dictionaries 中存储的数据值类型必须明确。这意味着我们不能把不正确的数 据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。<br>注意:<br>Swift 的 Arrays 、 Sets 和 Dictionaries 类型被实现为泛型集合。更多关于泛型类型和集合，参见 泛型章 节。</p><h4 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h4><ul><li>如果创建一个 Arrays 、 Sets 或 Dictionaries 并且把它分配成一个变量，这个集合将会是可变的。这意味着我们 可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把 Arrays 、 Sets 或 ionaries 分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。<h4 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h4></li><li>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。写 Swift 数组应该遵循像 Array<element> 这样的形式，其中 Element 是这个数组中唯一允许存在的数据类 型。我们也可以使用像 [Element] 这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而 且在本文中都会使用这种形式来使用数组。</element></li><li>创建一个空数组</li><li>我们可以使用构造语法来创建一个由特定数据类型构成的空数组:</li></ul><pre><code>var someInts = [Int]()print(&quot;someInts is of type [Int] with \(someInts.count) items.&quot;) // 打印 &quot;someInts is of type [Int] with 0 items.&quot;</code></pre><ul><li>注意，通过构造函数的类型， someInts 的值类型被推断为 [Int] 。<br>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我 们可以使用空数组语句创建一个空数组，它的写法很简单: [] (一对空方括号):</li></ul><pre><code>someInts.append(3)// someInts 现在包含一个 Int 值someInts = []// someInts 现在是空数组，但是仍然是 [Int] 类型的。</code></pre><ul><li>创建一个带有默认值的数组</li><li>Swift 中的 Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新 数组的数据项数量( count )和适当类型的初始值( repeating )传入数组构造函数:</li></ul><pre><code>var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</code></pre><ul><li>通过两个数组相加创建一个数组</li><li>我们可以使用加法操作符( + )来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类 型中推断出来:</li></ul><pre><code>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</code></pre><ul><li>访问和修改数组</li><li>我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。 可以使用数组的只读属性 count 来获取数组中的数据项数量:</li></ul><pre><code>var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]print(&quot;The shopping list contains \(shoppingList.count) items.&quot;)// 输出 &quot;The shopping list contains 2 items.&quot;(这个数组有2个项)</code></pre><ul><li>使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0 :</li></ul><pre><code>if shoppingList.isEmpty {    print(&quot;The shopping list is empty.&quot;)} else {    print(&quot;The shopping list is not empty.&quot;)}// 打印 &quot;The shopping list is not empty.&quot;(shoppinglist 不是空的)</code></pre><ul><li>也可以使用 append(_:) 方法在数组后面添加新的数据项:</li></ul><pre><code>shoppingList.append(&quot;Flour&quot;)// shoppingList 现在有3个数据项，有人在摊煎饼</code></pre><ul><li>除此之外，使用加法赋值运算符( += )也可以直接在数组后面添加一个或多个拥有相同类型的数据项:</li></ul><pre><code>shoppingList += [&quot;Baking Powder&quot;]// shoppingList 现在有四项了shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;] // shoppingList 现在有七项了</code></pre><ul><li>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号<br>中:</li></ul><pre><code>var firstItem = shoppingList[0] // 第一项是 &quot;Eggs&quot;</code></pre><ul><li>我们也可以用下标来改变某个已有索引值对应的数据值:</li></ul><pre><code>shoppingList[0] = &quot;Six eggs&quot;// 其中的第一项现在是 &quot;Six eggs&quot; 而不是 &quot;Eggs&quot;</code></pre><ul><li>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把 “Chocolate Spread” ， “Cheese” ，和 “Butter” 替换为 “Bananas” 和 “Apples” :</li></ul><pre><code>shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;] // shoppingList 现在有6项</code></pre><ul><li>注意:不可以用下标访问的形式去在数组尾部添加新项。</li><li>调用数组的 insert(_:at:) 方法来在某个具体索引值之前添加数据项:</li></ul><pre><code>shoppingList.insert(&quot;Maple Syrup&quot;, at: 0) // shoppingList 现在有7项// &quot;Maple Syrup&quot; 现在是这个列表中的第一项</code></pre><ul><li>类似的我们可以使用 remove(at:) 方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移 除并且返回这个被移除的数据项(我们不需要的时候就可以无视它):</li></ul><pre><code>let mapleSyrup = shoppingList.remove(at: 0)// 索引值为0的数据项被移除// shoppingList 现在只有6项，而且不包括 Maple Syrup// mapleSyrup 常量的值等于被移除数据项的值 &quot;Maple Syrup&quot;</code></pre><ul><li>如果我们只想把数组中的最后一项移除，可以使用 removeLast() 方法而不是 remove(at:) 方法来避免我们需要获 取数组的 count 属性。就像后者一样，前者也会返回被移除的数据项:</li></ul><pre><code>let apples = shoppingList.removeLast()// 数组的最后一项被移除了// shoppingList 现在只有5项，不包括 Apples // apples 常量的值现在等于 &quot;Apples&quot; 字符串</code></pre><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><ul><li>我们可以使用 for-in 循环来遍历所有数组中的数据项:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> item <span class="token keyword">in</span> shoppingList <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Six eggs</span><span class="token comment" spellcheck="true">// Milk</span><span class="token comment" spellcheck="true">// Flour</span><span class="token comment" spellcheck="true">// Baking Powder</span><span class="token comment" spellcheck="true">// Bananas</span></code></pre><ul><li>如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历。 enumerated() 返回 一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历:</li></ul><pre><code>for (index, value) in shoppingList.enumerated() {    print(&quot;Item \(String(index + 1)): \(value)&quot;)}// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas</code></pre><h3 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h3><ul><li>集合(Set)用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次 时可以使用集合而不是数组。<h4 id="集合类型的哈希值"><a href="#集合类型的哈希值" class="headerlink" title="集合类型的哈希值"></a>集合类型的哈希值</h4></li><li>一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希 值。一个哈希值是 Int 类型的，相等的对象哈希值必须相同，比如 a==b ,因此必须 a.hashValue == b.hashValue。<br>Swift 的所有基本类型(比如 String , Int , Double 和 Bool )默认都是可哈希化的，可以作为集合的值的类型或 者字典的键的类型。没有关联值的枚举成员值(在枚举有讲述)默认也是可哈希化的。</li><li>Swift 中的 Set 类型被写为 Set<element> ，这里的 Element 表示 Set 中允许存储的类型，和数组不同的是，  合没有等价的简化形式。</element></li><li>创建和构造一个空的集合</li></ul><pre><code>var letters = Set&lt;Character&gt;()print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;) // 打印 &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</code></pre><ul><li>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数 组字面量创建一个空的 Set :</li></ul><pre><code>letters.insert(&quot;a&quot;)// letters 现在含有1个 Character 类型的值letters = []// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型</code></pre><h4 id="用数组字面量创建集合"><a href="#用数组字面量创建集合" class="headerlink" title="用数组字面量创建集合"></a>用数组字面量创建集合</h4><ul><li>你可以使用数组字面量来构造 合，并且可以使用简化形式写一个或者多个值作为 合元素。<br>下面的例子创建一个称之为 favoriteGenres 的 合来存储 String 类型的值:</li></ul><pre><code>var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] // favoriteGenres 被构造成含有三个初始值的集合print(favoriteGenres)</code></pre><ul><li>Swift 的 Set 类型没有确定的顺序，为了按照特定顺序来遍历一个 Set 中的值可以使用 sorted() 方法，它将返<br>回一个有序数组，这个数组的元素排列顺序由操作符’&lt;’对元素进行比较的结果来确定.</li></ul><pre><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]for genre in favoriteGenres.sorted() {    print(&quot;\(genre)&quot;)}// prints &quot;Classical&quot;// prints &quot;Hip hop&quot;// prints &quot;Rock&quot;</code></pre><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><ul><li>你可以高效地完成 Set 的一些基本操作，比如把两个 合组合到一起，判断两个 合共有元素，或者判断两个  合是否全包含，部分包含或者不相交。</li><li>使用该intersection(_:)方法创建一个仅具有两个集合通用值的新集合。</li><li>使用该symmetricDifference(_:)方法创建一个新集合，其中的值可以是任一集，但不能同时使用。</li><li>使用该union(_:)方法创建一个新集合，其中包含两个集合中的所有值。</li><li>使用该subtracting(_:)方法创建一个新集合，其值不在指定的集合中。</li></ul><pre><code>let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9]</code></pre><h4 id="集合成员关系和相等"><a href="#集合成员关系和相等" class="headerlink" title="集合成员关系和相等"></a>集合成员关系和相等</h4><ul><li>使用“等于”运算符（==）来确定两个集合是否包含所有相同的值。</li><li>使用该isSubset(of:)方法确定集合的所有值是否包含在指定的集合中。</li><li>使用该isSuperset(of:)方法来确定集合是否包含指定集合中的所有值。</li><li>使用isStrictSubset(of:)或isStrictSuperset(of:)方法来确定集合是子集还是超集，但不等于指定集。</li><li>使用该isDisjoint(with:)方法来确定两个集合是否没有共同的值。</li></ul><pre><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> namesOfIntegers <span class="token operator">=</span> <span class="token builtin">Int</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token comment" spellcheck="true">// namesOfIntegers 是一个空的 [Int: String] 字典</span>namesOfIntegers<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"sixteen"</span><span class="token comment" spellcheck="true">// namesOfIntegers 现在包含一个键值对</span>namesOfIntegers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</span></code></pre><h4 id="访问和修改词典"><a href="#访问和修改词典" class="headerlink" title="访问和修改词典"></a>访问和修改词典</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> airports <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"YYZ"</span><span class="token punctuation">:</span> <span class="token string">"Toronto Pearson"</span><span class="token punctuation">,</span> <span class="token string">"DUB"</span><span class="token punctuation">:</span> <span class="token string">"Dublin"</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The dictionary of airports contains (airports.count) items."</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 打印 "The dictionary of airports contains 2 items."(这个字典有两个数据项)</span><span class="token keyword">if</span> airports<span class="token punctuation">.</span><span class="token builtin">isEmpty</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The airports dictionary is empty."</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The airports dictionary is not empty."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 打印 "The airports dictionary is not empty."</span>airports<span class="token punctuation">[</span><span class="token string">"LHR"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"London"</span><span class="token comment" spellcheck="true">// the airports dictionary now contains 3 items</span>airports<span class="token punctuation">[</span><span class="token string">"LHR"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"London Heathrow"</span><span class="token comment" spellcheck="true">// the value for "LHR" has been changed to "London Heathrow"</span></code></pre><ul><li>作为另一种下标方法，字典的 updateValue(<em>:forKey:) 方法可以设置或者更新特定键对应的值。就像上面所示的 下标示例， updateValue(</em>:forKey:) 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的 值。和上面的下标方法不同的， updateValue(<em>:forKey:) 这个方法返回更新值之前的原值。这样使得我们可以检 查更新是否成功。<br>updateValue(</em>:forKey:) 方法会返回对应值的类型的可选值。举例来说:对于存储 String 值的字典，这个函数会 返回一个 String? 或者“可选 String ”类型的值。<br>如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是 nil 。</li></ul><pre><code>if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {    print(&quot;The old value for DUB was \(oldValue).&quot;)}// 输出 &quot;The old value for DUB was Dublin.&quot;</code></pre><ul><li>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标 访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可 选值，否则将返回 nil :</li></ul><pre><code>if let airportName = airports[&quot;DUB&quot;] {    print(&quot;The name of the airport is \(airportName).&quot;)} else {    print(&quot;That airport is not in the airports dictionary.&quot;)}// Prints &quot;The name of the airport is Dublin Airport.&quot;</code></pre><ul><li>我们还可以使用下标语法来通过给某个键的对应值赋值为 nil 来从字典里移除一个键值对:</li></ul><pre><code>airports[&quot;APL&quot;] = &quot;Apple International&quot;// &quot;Apple International&quot; is not the real airport for APL, so delete itairports[&quot;APL&quot;] = nil// APL has now been removed from the dictionary</code></pre><ul><li>此外， removeValue(forKey:) 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键 值对并且返回被移除的值或者在没有值的情况下返回 nil :</li></ul><pre><code>if let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) {    print(&quot;The removed airport&#39;s name is \(removedValue).&quot;)} else {    print(&quot;The airports dictionary does not contain a value for DUB.&quot;)}// Prints &quot;The removed airport&#39;s name is Dublin Airport.&quot;</code></pre><h4 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h4><pre><code>for (airportCode, airportName) in airports {    print(&quot;\(airportCode): \(airportName)&quot;)}// YYZ: Toronto Pearson// LHR: London Heathrow</code></pre><ul><li>您还可以通过访问其属性keys和values属性来检索字典键或值的可迭代集合：</li></ul><pre><code>for airportCode in airports.keys {    print(&quot;Airport code: \(airportCode)&quot;)}// Airport code: YYZ// Airport code: LHRfor airportName in airports.values {    print(&quot;Airport name: \(airportName)&quot;)}// Airport name: Toronto Pearson// Airport name: London Heathrow</code></pre><ul><li>如果您需要使用带有Array实例的API的字典键或值，请使用keys或values属性初始化新数组：</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> airportCodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>airports<span class="token punctuation">.</span>keys<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// airportCodes is ["YYZ", "LHR"]</span><span class="token keyword">let</span> airportNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>airports<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// airportNames is ["Toronto Pearson", "London Heathrow"]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础总结 </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识swift</title>
      <link href="/2017/03/13/2017-03-13-chu-shi-swift/"/>
      <url>/2017/03/13/2017-03-13-chu-shi-swift/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="关于swift"><a href="#关于swift" class="headerlink" title="关于swift"></a>关于swift</h2><p><a href="https://developer.apple.com/" target="_blank" rel="noopener">官方文档1</a></p><p><a href="https://developer.apple.com/swift/resources/" target="_blank" rel="noopener">官方文档2</a></p><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1" target="_blank" rel="noopener">官方文档3</a></p><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" target="_blank" rel="noopener">官方文档4</a></p><ul><li>Swift 是一种新的编程语言，用于编写 iOS 和 OS X 应用。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</li><li>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈并将其标准化。Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</li><li>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</li><li>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的编程语言。它支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</li><li>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</li></ul><hr><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul><li>简单赋值</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello, playground"</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token keyword">var</span> myVariable <span class="token operator">=</span> <span class="token number">42</span>myVariable <span class="token operator">=</span> <span class="token number">50</span><span class="token keyword">let</span> myConstant <span class="token operator">=</span> <span class="token number">42</span><span class="token keyword">var</span> ab <span class="token operator">=</span> <span class="token number">90</span>ab <span class="token operator">=</span> <span class="token number">70</span></code></pre><ul><li>指定类型</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> implicitInteger <span class="token operator">=</span> <span class="token number">70</span><span class="token keyword">let</span> implicitDouble <span class="token operator">=</span> <span class="token number">70.0</span><span class="token keyword">let</span> explicitDouble <span class="token punctuation">:</span> <span class="token builtin">Double</span> <span class="token operator">=</span> <span class="token number">70</span><span class="token keyword">let</span> expicitFloat <span class="token punctuation">:</span> <span class="token builtin">Float</span> <span class="token operator">=</span> <span class="token number">4</span></code></pre><ul><li>值不会隐式转换为其他类型（Values are never implicitly converted to another type.）。如果需要将值转换为其他类型，请明确地创建所需类型的实例。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> label <span class="token operator">=</span> <span class="token string">"the label width is"</span><span class="token keyword">let</span> widhth <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">let</span> widthLabel <span class="token operator">=</span> label <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>widhth<span class="token punctuation">)</span></code></pre><ul><li>有一个更简单的方法来在字符串中包含值：将值写在括号中，并在括号\之前写入反斜杠（）。例如:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> apple <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">let</span> orange <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">let</span> appleSummary <span class="token operator">=</span> <span class="token string">"I have <span class="token interpolation"><span class="token delimiter variable">\(</span>apple<span class="token delimiter variable">)</span></span> apples"</span><span class="token keyword">let</span> fruitSummary <span class="token operator">=</span> <span class="token string">"I have <span class="token interpolation"><span class="token delimiter variable">\(</span>apple <span class="token operator">+</span> orange<span class="token delimiter variable">)</span></span> pieces of fruit."</span></code></pre><h2 id="数组与字典"><a href="#数组与字典" class="headerlink" title="数组与字典"></a>数组与字典</h2><ul><li>直接赋值</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> shoppingList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"catfish"</span><span class="token punctuation">,</span> <span class="token string">"water"</span><span class="token punctuation">,</span> <span class="token string">"tulips"</span><span class="token punctuation">,</span> <span class="token string">"blue paint"</span><span class="token punctuation">,</span>str<span class="token punctuation">]</span>shoppingList<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"bottle of water"</span><span class="token keyword">var</span> occupations <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"Malcolm"</span><span class="token punctuation">:</span> <span class="token string">"Captain"</span><span class="token punctuation">,</span>    <span class="token string">"Kaylee"</span><span class="token punctuation">:</span> <span class="token string">"Mechanic"</span><span class="token punctuation">,</span><span class="token punctuation">]</span>occupations<span class="token punctuation">[</span><span class="token string">"Jayne"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Public Relations"</span></code></pre><ul><li>要创建一个空数组或者字典，使用初始化语法。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> emptyArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> emptyDictionary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Float</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>如果类型信息可以被推断出来，你可以用 [] 和 [:] 来创建空数组和空字典——就像你声明变量或者给函数传参 数的时候一样</li></ul><pre class=" language-swift"><code class="language-swift">shoppingList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>occupations <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span></code></pre><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><ul><li>使用 if 和 switch 来进行条件操作，使用 for-in 、 for 、 while 和 repeat-while 来进行循环。包裹条件和循环 变量括号可以省略，但是语句体的大括号是必须的。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> individualScores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">87</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token keyword">var</span> teamScore <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> score <span class="token keyword">in</span> individualScores <span class="token punctuation">{</span>    <span class="token keyword">if</span> score <span class="token operator">></span> <span class="token number">50</span> <span class="token punctuation">{</span>        teamScore <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">3</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        teamScore <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>teamScore<span class="token punctuation">)</span></code></pre><p>在 if 语句中，条件必须是一个布尔表达式——这意味着像 if score { … } 这样的代码将报错，而不会隐形地 与 0 做对比。</p><ul><li>你可以一起使用 if 和 let 来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者 是 nil 以表示值缺失。在类型后面加一个问号来标记这个变量的值是可选的。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> optionalString<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token function">print</span><span class="token punctuation">(</span>optionalString <span class="token operator">==</span> <span class="token constant">nil</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>optionalString<span class="token punctuation">)</span><span class="token keyword">var</span> optionalName<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"John Appleseed"</span><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"Hello!"</span><span class="token keyword">if</span> <span class="token keyword">let</span> name <span class="token operator">=</span> optionalName <span class="token punctuation">{</span>    greeting <span class="token operator">=</span> <span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>,myName is 66666"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/*falseOptional("Hello")Hello, John Appleseed,myName is 66666*/</span></code></pre><ul><li>如果变量的可选值是nil，条件会判断为false ，大括号中的代码会被跳过。如果不是nil ，会将值解包并赋给let 后面的常量，这样代码块中就可以使用这个值了。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> optionalName<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"Hello!"</span><span class="token keyword">if</span> <span class="token keyword">let</span> name <span class="token operator">=</span> optionalName <span class="token punctuation">{</span>    greeting <span class="token operator">=</span> <span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>,myName is 66666"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Hello!</span></code></pre><ul><li>处理可选值的另一种方法是使用??运算符提供默认值。如果缺少可选值，则使用默认值。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> nickName<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span><span class="token keyword">let</span> fullName<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token string">"John Appleseed"</span><span class="token keyword">let</span> informalGreeting <span class="token operator">=</span> <span class="token string">"Hi <span class="token interpolation"><span class="token delimiter variable">\(</span>nickName <span class="token operator">?</span><span class="token operator">?</span> fullName<span class="token delimiter variable">)</span></span>"</span><span class="token function">print</span><span class="token punctuation">(</span>informalGreeting<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Hi John Appleseed</span></code></pre><ul><li>switch支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> vegetable <span class="token operator">=</span> <span class="token string">"red pepper"</span><span class="token keyword">switch</span> vegetable <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token string">"celery"</span><span class="token punctuation">:</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Add some raisins and make ants on a log."</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token string">"cucumber"</span><span class="token punctuation">,</span> <span class="token string">"watercress"</span><span class="token punctuation">:</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"That would make a good tea sandwich."</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">let</span> x <span class="token keyword">where</span> x<span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Is it a spicy <span class="token interpolation"><span class="token delimiter variable">\(</span>x<span class="token delimiter variable">)</span></span>?"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Everything tastes good in soup."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Is it a spicy red pepper?</span></code></pre><p>注意 let 在上述例子的等式中是如何使用的，它将匹配等式的值赋给常量 x 。<br>运行 switch 中匹配到的子句之后，程序会退出 switch 语句，并不会继续向下运行，所以不需要在每个子句结尾 写 break 。</p><ul><li>你可以使用 for-in 来遍历字典，需要两个变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以 任意顺序迭代结束。</li></ul><pre><code>let interestingNumbers = [    &quot;Prime&quot;: [2, 3, 5, 7, 11, 13],    &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8],    &quot;Square&quot;: [1, 4, 9, 16, 25],]print(interestingNumbers)var largest = 0for (kind, numbers) in interestingNumbers {    for number in numbers {        if number &gt; largest {            largest = number        }    }}print(largest)/*[&quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8], &quot;Square&quot;: [1, 4, 9, 16, 25], &quot;Prime&quot;: [2, 3, 5, 7, 11, 13]]25*/</code></pre><ul><li>使用 while 来重复运行一段代码直到不满足条件。循环条件也可以在结尾，保证能至少循环一次。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">while</span> n <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">{</span>    n <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">repeat</span> <span class="token punctuation">{</span>    m <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token keyword">while</span> m <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token function">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//128</span><span class="token comment" spellcheck="true">//128</span></code></pre><ul><li>你可以在循环中使用 ..&lt; 来表示范围。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token number">4</span> <span class="token punctuation">{</span>    total <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//6</span></code></pre><ul><li>使用 ..&lt; 创建的范围不包含上界，如果想包含的话需要使用 … 。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token keyword">var</span> myTotal <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4</span> <span class="token punctuation">{</span>    myTotal <span class="token operator">+</span><span class="token operator">=</span> j<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>myTotal<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10</span></code></pre><h2 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h2><ul><li>使用 func 来声明一个函数，使用名字和参数来调用函数。使用 -&gt; 来指定函数返回值的类型。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">greet</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> day<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"Hello <span class="token interpolation"><span class="token delimiter variable">\(</span>person<span class="token delimiter variable">)</span></span>, today is <span class="token interpolation"><span class="token delimiter variable">\(</span>day<span class="token delimiter variable">)</span></span>."</span><span class="token punctuation">}</span><span class="token function">greet</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> day<span class="token punctuation">:</span> <span class="token string">"Tuesday"</span><span class="token punctuation">)</span></code></pre><ul><li>默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 _ 表示不使用参数标签。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token number">_</span> person<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> on day<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"Hello <span class="token interpolation"><span class="token delimiter variable">\(</span>person<span class="token delimiter variable">)</span></span>, today is <span class="token interpolation"><span class="token delimiter variable">\(</span>day<span class="token delimiter variable">)</span></span>."</span><span class="token punctuation">}</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> on<span class="token punctuation">:</span> <span class="token string">"Wednesday"</span><span class="token punctuation">)</span></code></pre><ul><li>使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">calculateStatistics</span><span class="token punctuation">(</span>scores<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> sum<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token builtin">min</span> <span class="token operator">=</span> scores<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">var</span> <span class="token builtin">max</span> <span class="token operator">=</span> scores<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> score <span class="token keyword">in</span> scores <span class="token punctuation">{</span>        <span class="token keyword">if</span> score <span class="token operator">></span> <span class="token builtin">max</span> <span class="token punctuation">{</span>            <span class="token builtin">max</span> <span class="token operator">=</span> score        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> score <span class="token operator">&lt;</span> <span class="token builtin">min</span> <span class="token punctuation">{</span>            <span class="token builtin">min</span> <span class="token operator">=</span> score        <span class="token punctuation">}</span>        sum <span class="token operator">+</span><span class="token operator">=</span> score    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> statistics <span class="token operator">=</span> <span class="token function">calculateStatistics</span><span class="token punctuation">(</span>scores<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>statistics<span class="token punctuation">.</span>sum<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>statistics<span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><ul><li>函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式:</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">sumOf</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> number <span class="token keyword">in</span> numbers <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> number    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">sumOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">sumOf</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">597</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">sumOf</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函<br>数。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">returnFifteen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span>    <span class="token punctuation">}</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> y<span class="token punctuation">}</span><span class="token function">returnFifteen</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>函数是第一等类型，这意味着函数可以作为另一个函数的返回值。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">makeIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">func</span> <span class="token function">addOne</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> number    <span class="token punctuation">}</span>    <span class="token keyword">return</span> addOne<span class="token punctuation">}</span><span class="token keyword">var</span> increment <span class="token operator">=</span> <span class="token function">makeIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span></code></pre><ul><li>函数也可以当做参数传入另一个函数。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">hasAnyMatches</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> condition<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> list <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token function">condition</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">lessThanTen</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> number <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token function">hasAnyMatches</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> numbers<span class="token punctuation">,</span> condition<span class="token punctuation">:</span> lessThanTen<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">hasAnyMatches</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> numbers<span class="token punctuation">,</span> condition<span class="token punctuation">:</span> lessThanTen<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变 量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用 {} 来创建 一个匿名闭包。使用 in 将参数和返回值类型声明与闭包函数体进行分离。</li></ul><pre class=" language-swift"><code class="language-swift">numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token keyword">in</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> number    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li>有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型<br>和返回值。单个语句闭包会把它语句的值当做结果返回。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> mappedNumbers <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">{</span> number <span class="token keyword">in</span> <span class="token number">3</span> <span class="token operator">*</span> number <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>mappedNumbers<span class="token punctuation">)</span></code></pre><ul><li>你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后<br>一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略<br>括号。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> sortedNumbers <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token builtin">sort</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">></span> $<span class="token number">1</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>sortedNumbers<span class="token punctuation">)</span></code></pre><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><ul><li>使用 class 和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是 类。同样，方法和函数声明也一样。</li></ul><pre><code>class Shape {    var numberOfSides = 0    func simpleDescription() -&gt; String {        return &quot;A shape with \(numberOfSides) sides.&quot;    }}</code></pre><ul><li>要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> myShape <span class="token operator">=</span> <span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span>myShape<span class="token punctuation">.</span>numberOfSides <span class="token operator">=</span> <span class="token number">100</span>myShape<span class="token punctuation">.</span><span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>myShape<span class="token punctuation">.</span><span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ul><li>这个版本的 Shape 类缺少了一些重要的东西:一个构造函数来初始化类实例。使用 init 来创建一个构造器。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">NamedShape</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> numberOfSides<span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"A shape with <span class="token interpolation"><span class="token delimiter variable">\(</span>numberOfSides<span class="token delimiter variable">)</span></span> sides."</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意 self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都 需要赋值——无论是通过声明(就像 numberOfSides )还是通过构造器(就像 name )。<br>如果你需要在删除对象之前进行一些清理工作，使用 deinit 创建一个析构函数。</p><ul><li>子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所<br>以你可以忽略父类。子类如果要重写父类的方法的话，需要用 override 标记——如果没有添加 override 就重写父类方法的话编译器 会报错。编译器同样会检测 override 标记的方法是否确实在父类中。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Square</span><span class="token punctuation">:</span> <span class="token builtin">NamedShape</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> sideLength<span class="token punctuation">:</span> <span class="token builtin">Double</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>sideLength <span class="token operator">=</span> sideLength        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> name<span class="token punctuation">)</span>        numberOfSides <span class="token operator">=</span> <span class="token number">4</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sideLength <span class="token operator">*</span> sideLength    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"A square with sides of length <span class="token interpolation"><span class="token delimiter variable">\(</span>sideLength<span class="token delimiter variable">)</span></span>."</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token function">Square</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> <span class="token number">5.2</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">"my test square"</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span><span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>除了储存简单的属性之外，属性可以有 getter 和 setter 。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">EquilateralTriangle</span><span class="token punctuation">:</span> <span class="token builtin">NamedShape</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> sideLength<span class="token punctuation">:</span> <span class="token builtin">Double</span> <span class="token operator">=</span> <span class="token number">0.0</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>sideLength <span class="token operator">=</span> sideLength        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> name<span class="token punctuation">)</span>        numberOfSides <span class="token operator">=</span> <span class="token number">3</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> perimeter<span class="token punctuation">:</span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>        <span class="token keyword">get</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">3.0</span> <span class="token operator">*</span> sideLength        <span class="token punctuation">}</span>        <span class="token keyword">set</span> <span class="token punctuation">{</span>            sideLength <span class="token operator">=</span> newValue <span class="token operator">/</span> <span class="token number">3.0</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"An equilateral triangle with sides of length <span class="token interpolation"><span class="token delimiter variable">\(</span>sideLength<span class="token delimiter variable">)</span></span>."</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> triangle <span class="token operator">=</span> <span class="token function">EquilateralTriangle</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> <span class="token number">3.1</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">"a triangle"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>triangle<span class="token punctuation">.</span>perimeter<span class="token punctuation">)</span>triangle<span class="token punctuation">.</span>perimeter <span class="token operator">=</span> <span class="token number">9.9</span><span class="token function">print</span><span class="token punctuation">(</span>triangle<span class="token punctuation">.</span>sideLength<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//9.3</span><span class="token comment" spellcheck="true">//3.3</span></code></pre><p>在 perimeter 的 setter 中，新值的名字是 newValue 。你可以在 set 之后显式的设置一个名字。</p><ul><li>注意 EquilateralTriangle 类的构造器执行了三步:<ul><li>设置子类声明的属性值</li><li>调用父类的构造器</li><li>改变父类定义的属性值。其他的工作比如调用方法、getters 和 setters 也可以在这个阶段完成。</li></ul></li><li>如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用 willSet 和 didSet 。比如，下面的类确保三角形的边长总是和正方形的边长相同。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">TriangleAndSquare</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> triangle<span class="token punctuation">:</span> <span class="token builtin">EquilateralTriangle</span> <span class="token punctuation">{</span>        <span class="token keyword">willSet</span> <span class="token punctuation">{</span>            square<span class="token punctuation">.</span>sideLength <span class="token operator">=</span> newValue<span class="token punctuation">.</span>sideLength        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> square<span class="token punctuation">:</span> <span class="token builtin">Square</span> <span class="token punctuation">{</span>        <span class="token keyword">willSet</span> <span class="token punctuation">{</span>            triangle<span class="token punctuation">.</span>sideLength <span class="token operator">=</span> newValue<span class="token punctuation">.</span>sideLength        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        square <span class="token operator">=</span> <span class="token function">Square</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> size<span class="token punctuation">,</span> name<span class="token punctuation">:</span> name<span class="token punctuation">)</span>        triangle <span class="token operator">=</span> <span class="token function">EquilateralTriangle</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> size<span class="token punctuation">,</span> name<span class="token punctuation">:</span> name<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> triangleAndSquare <span class="token operator">=</span> <span class="token function">TriangleAndSquare</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">"another test shape"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>triangleAndSquare<span class="token punctuation">.</span>square<span class="token punctuation">.</span>sideLength<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>triangleAndSquare<span class="token punctuation">.</span>triangle<span class="token punctuation">.</span>sideLength<span class="token punctuation">)</span>triangleAndSquare<span class="token punctuation">.</span>square <span class="token operator">=</span> <span class="token function">Square</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">"larger square"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>triangleAndSquare<span class="token punctuation">.</span>triangle<span class="token punctuation">.</span>sideLength<span class="token punctuation">)</span></code></pre><ul><li>处理变量的可选值时，你可以在操作(比如方法、属性和子脚本)之前加 ? 。如果 ? 之前的值是 nil ， ? 后面 的东西都会被忽略，并且整个表达式返回 nil 。否则， ? 之后的东西都会被运行。在这两种情况下，整个表达式 的值也是一个可选值。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> optionalSquare<span class="token punctuation">:</span> <span class="token builtin">Square</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">Square</span><span class="token punctuation">(</span>sideLength<span class="token punctuation">:</span> <span class="token number">2.5</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">"optional square"</span><span class="token punctuation">)</span><span class="token keyword">let</span> sideLength <span class="token operator">=</span> optionalSquare<span class="token operator">?</span><span class="token punctuation">.</span>sideLength</code></pre><h2 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h2><ul><li>使用 enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Rank</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> ace <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">case</span> two<span class="token punctuation">,</span> three<span class="token punctuation">,</span> four<span class="token punctuation">,</span> five<span class="token punctuation">,</span> six<span class="token punctuation">,</span> seven<span class="token punctuation">,</span> eight<span class="token punctuation">,</span> nine<span class="token punctuation">,</span> ten    <span class="token keyword">case</span> jack<span class="token punctuation">,</span> queen<span class="token punctuation">,</span> king    <span class="token keyword">func</span> <span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>ace<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"ace"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>jack<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"jack"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>queen<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"queen"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>king<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"king"</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>rawValue<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> ace <span class="token operator">=</span> <span class="token builtin">Rank</span><span class="token punctuation">.</span>ten<span class="token keyword">let</span> aceRawValue <span class="token operator">=</span> ace<span class="token punctuation">.</span>rawValue</code></pre><p>默认情况下，Swift 按照从 0 开始每次加 1 的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在 上面的例子中， Ace 被显式赋值为 1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为 枚举的原始值。使用 rawValue 属性来访问一个枚举成员的原始值。</p><ul><li>使用 init?(rawValue:) 初始化构造器在原始值和枚举值之间进行转换。</li></ul><pre><code>if let convertedRank = Rank(rawValue: 3) {    let threeDescription = convertedRank.simpleDescription()}</code></pre><ul><li>枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要<br>提供原始值。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> spades<span class="token punctuation">,</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs    <span class="token keyword">func</span> <span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>spades<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"spades"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>hearts<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"hearts"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>diamonds<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"diamonds"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span>clubs<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"clubs"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> hearts <span class="token operator">=</span> <span class="token builtin">Suit</span><span class="token punctuation">.</span>hearts<span class="token keyword">let</span> heartsDescription <span class="token operator">=</span> hearts<span class="token punctuation">.</span><span class="token function">simpleDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>注意，有两种方式可以引用 Hearts 成员:给 hearts 常量赋值时，枚举成员 Suit.Hearts 需要用全名来引用，因 为常量没有显式指定类型。在 switch 里，枚举成员使用缩写 .Hearts 来引用，因为 self 的值已经知道是一个 suit 。已知变量类型的情况下你可以使用缩写。一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值<br>和原始值是不同的:枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。<br>例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。</p><pre><code>enum ServerResponse {    case result(String, String)    case failure(String)}let success = ServerResponse.result(&quot;6:00 am&quot;, &quot;8:09 pm&quot;)let failure = ServerResponse.failure(&quot;Out of cheese.&quot;)switch success {case let .result(sunrise, sunset):    print(&quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;)case let .failure(message):    print(&quot;Failure...  \(message)&quot;)}</code></pre><p>注意日升和日落时间是如何从 ServerResponse 中提取到并与 switch 的 case 相匹配的。</p><ul><li>使用 struct 来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就 是结构体是传值，类是传引用(One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.)。</li></ul><pre><code>struct Card {    var rank: Rank    var suit: Suit    func simpleDescription() -&gt; String {        return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;    }}let threeOfSpades = Card(rank: .three, suit: .spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription()</code></pre><h2 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h2><ul><li>使用 protocol 来声明一个协议。</li></ul><pre><code>protocol ExampleProtocol {    var simpleDescription: String { get }    mutating func adjust()}</code></pre><ul><li>类、枚举和结构体都可以实现协议。</li></ul><pre><code>class SimpleClass: ExampleProtocol {    var simpleDescription: String = &quot;A very simple class.&quot;    var anotherProperty: Int = 69105    func adjust() {        simpleDescription += &quot;  Now 100% adjusted.&quot;    }}var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionprint(aDescription)struct SimpleStructure: ExampleProtocol {    var simpleDescription: String = &quot;A simple structure&quot;    mutating func adjust() {        simpleDescription += &quot; (adjusted)&quot;    }}var b = SimpleStructure()b.adjust()let bDescription = b.simpleDescriptionprint(bDescription)</code></pre><p>注意声明 SimpleStructure 时候 mutating 关键字用来标记一个会修改结构体的方法。 SimpleClass 的声明不需要 标记任何方法，因为类中的方法通常可以修改类属性(类的性质)。</p><ul><li>使用 extension 来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是 从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。</li></ul><pre><code>extension Int: ExampleProtocol {    var simpleDescription: String {        return &quot;The number \(self)&quot;    }    mutating func adjust() {        self += 42    }}print(7.simpleDescription)</code></pre><ul><li>你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象集合。当<br>你处理类型是协议的值时，协议外定义的方法不可用。</li></ul><pre><code>let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription)// print(protocolValue.anotherProperty)  // Uncomment to see the error</code></pre><p>即使 protocolValue 变量运行时的类型是 simpleClass ，编译器会把它的类型当做 ExampleProtocol 。这表示你不 能调用类在它实现的协议之外实现的方法或者属性。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>使用采用 Error 协议的类型来表示错误。</li></ul><pre><code>enum PrinterError: Error {    case outOfPaper    case noToner    case onFire}</code></pre><ul><li>使用 throw 来抛出一个错误并使用 throws 来表示一个可以抛出错误的函数。如果在函数中抛出一个错误，这个函 数会立刻返回并且调用该函数的代码会进行错误处理。</li></ul><pre><code>func send(job: Int, toPrinter printerName: String) throws -&gt; String {    if printerName  &quot;Never Has Toner&quot; {        throw PrinterError.noToner    }    return &quot;Job sent&quot;}</code></pre><ul><li>有多种方式可以用来进行错误处理。一种方式是使用 do-catch 。在 do 代码块中，使用 try 来标记可以抛出错误 的代码。在 catch 代码块中，除非你另外命名，否则错误会自动命名为 error 。</li></ul><pre><code>do {    let printerResponse = try send(job: 1040, toPrinter: &quot;Bi Sheng&quot;)    print(printerResponse)} catch {    print(error)}</code></pre><ul><li>可以使用多个 catch 块来处理特定的错误。参照 switch 中的 case 风格来写 catch 。</li></ul><pre><code>do {    let printerResponse = try send(job: 1440, toPrinter: &quot;Gutenberg&quot;)    print(printerResponse)} catch PrinterError.onFire {    print(&quot;I&#39;ll just put this over here, with the rest of the fire.&quot;)} catch let printerError as PrinterError {    print(&quot;Printer error: \(printerError).&quot;)} catch {    print(error)}</code></pre><ul><li>另一种处理错误的方式使用 try? 将结果转换为可选的。如果函数抛出错误，该错误会被抛弃并且结果为 ni l 。否则的话，结果会是一个包含函数返回值的可选值。</li></ul><pre><code>let printerSuccess = try? send(job: 1884, toPrinter: &quot;Mergenthaler&quot;)let printerFailure = try? send(job: 1885, toPrinter: &quot;Never Has Toner&quot;)</code></pre><ul><li>使用 defer 代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执 行。使用 defer ，可以把函数调用之初就要执行的代码和函数调用结束时的扫尾代码写在一起，虽然这两者的执 行时机截然不同。</li></ul><pre><code>var fridgeIsOpen = falselet fridgeContent = [&quot;milk&quot;, &quot;eggs&quot;, &quot;leftovers&quot;]func fridgeContains(_ food: String) -&gt; Bool {    fridgeIsOpen = true    defer {        fridgeIsOpen = false    }    let result = fridgeContent.contains(food)    return result}fridgeContains(&quot;banana&quot;)print(fridgeIsOpen)</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>在尖括号里写一个名字来创建一个泛型函数或者类型。</li></ul><pre><code>func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {    var result = [Item]()    for _ in 0..&lt;numberOfTimes {        result.append(item)    }    return result}let arr = makeArray(repeating: &quot;knock&quot;, numberOfTimes: 4)print(arr)</code></pre><ul><li>你也可以创建泛型函数、方法、类、枚举和结构体。</li></ul><pre><code>// 重新实现 Swift 标准库中的可选类型 enum OptionalValue&lt;Wrapped&gt; enum OptionalValue&lt;Wrapped&gt; {    case none    case some(Wrapped)}var possibleInteger: OptionalValue&lt;Int&gt; = .nonepossibleInteger = .some(100)print(possibleInteger)//some(100)</code></pre><ul><li>在类型名后面使用 where 来指定对类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者 限定某个类必须有一个特定的父类。</li></ul><pre><code>func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool    where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element {        for lhsItem in lhs {            for rhsItem in rhs {                if lhsItem == rhsItem {                    return true                }            }        }        return false}anyCommonElements([1, 2, 3], [3])</code></pre><p>&lt;T: Equatable&gt;和<t> … where T: Equatable 是等价的。</t></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议总结</title>
      <link href="/2016/11/11/2016-11-11-http-xie-yi-zong-jie/"/>
      <url>/2016/11/11/2016-11-11-http-xie-yi-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>按层次分，TCP 位于传输层，提供可靠的字节流服务。所谓的字节流服务(Byte Stream Service)是指，为了方便传输，将大 块数据分割成以报文段(segment)为单位的数据包进行管理。而可 靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方。<br>确保数据能到达目标<br>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 (three-way handshaking)策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize) 和 ACK(acknowledgement)。<br>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 基础总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发调试Xcode总结</title>
      <link href="/2016/11/09/2016-11-09-ios-kai-fa-diao-shi-xcode-zong-jie/"/>
      <url>/2016/11/09/2016-11-09-ios-kai-fa-diao-shi-xcode-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="xcode快捷键"><a href="#xcode快捷键" class="headerlink" title="xcode快捷键"></a>xcode快捷键</h3><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>command shfit + Y</td><td>调出Debug控制台</td></tr><tr><td>command + T</td><td>新建一个选项卡</td></tr><tr><td>command shfit + 】</td><td>在选项卡之间切换</td></tr><tr><td>command option + 】</td><td>当前行代码向上移动</td></tr><tr><td>cmd + ctrl + E</td><td>先选中要替换的内容，再按 cmd + ctrl + E，便会高亮</td></tr></tbody></table><h3 id="1、废弃方法说明"><a href="#1、废弃方法说明" class="headerlink" title="1、废弃方法说明"></a>1、废弃方法说明</h3><pre><code>NS_AVAILABLE_IOS(5_0):这个方法可以在iOS5.0及以后的版本中使用。如果我们在比指定版本更老的版本中调用这个方法，就会引起崩溃。NS_DEPRECATED_IOS(2_0, 6_0):这个宏中有两个版本号。前面一个表明了这个方法被引入时的iOS版本，后面一个表明它被废弃时的iOS版本。被废弃并不是指这个方法就不存在了，只是意味着我们应当开始考虑将相关代码迁移到新的API上去了。 NS_AVAILABLE(10_8, 6_0):这里的NS_AVAILABLE宏告诉我们这方法分别随Mac OS 10.8和iOS 6.0被引入。NS_DEPRECATED(10_0, 10_6, 2_0, 4_0):这里表示这个方法随Mac OS 10.0和iOS 2.0被引入，在Mac OS 10.6和iOS 4.0后被废弃。</code></pre><h3 id="2、打印log"><a href="#2、打印log" class="headerlink" title="2、打印log"></a>2、打印log</h3><pre><code>#ifdef DEBUG#define Log(...) NSLog(__VA_ARGS__)#else#define Log(...)#endif</code></pre><pre><code>#ifdef DEBUG#define CLLog(format, ...) printf(&quot;[%s] %s [第%d行] %s\n&quot;, __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);#else#define CLLog(format, ...)#endif</code></pre><h3 id="3、-pch注意点"><a href="#3、-pch注意点" class="headerlink" title="3、 pch注意点:"></a>3、 pch注意点:</h3><ul><li>1.pch需要提前编译 </li><li>2.需要做一些判断,判断下当前有没有c文件,如果有c,就不导入OC的语法<br><strong>OBJC</strong>每个OC文件都会自动定义这个宏<pre><code>#ifdef __OBJC__</code></pre><h3 id="4、去除无用日志"><a href="#4、去除无用日志" class="headerlink" title="4、去除无用日志"></a>4、去除无用日志</h3></li></ul><pre><code>解决方法：【product】-【scheme】-【Edit Scheme】-【Run】-【Argument】-【Environment Variable】添加key:Value【OS_ACTIVITY_MODE : disable】即可。</code></pre><h3 id="5-PerformSelector-may-cause-a-leak-because-its-selector-is-unknown"><a href="#5-PerformSelector-may-cause-a-leak-because-its-selector-is-unknown" class="headerlink" title="5.PerformSelector may cause a leak because its selector is unknown"></a>5.PerformSelector may cause a leak because its selector is unknown</h3><pre><code>#pragma clang diagnostic push#pragma clang diagnostic ignored   &quot;-Warc-performSelector-leaks&quot;                    [vc performSelector:NSSelectorFromString(@&quot;reloadTableViewRightNow&quot;)];#pragma clang diagnostic pop</code></pre><h3 id="6-自定义log"><a href="#6-自定义log" class="headerlink" title="6.自定义log"></a>6.自定义log</h3><pre><code>// 宏里面的可变参数：...// 函数中可变参数: __VA_ARGS__#define AMLog(...) NSlog(___VA_ARGS__)-----------------------------------------------#ifdef DEBUG // 调试阶段#define AMLog(...)  NSLog(__VA_ARGS__)#else // 发布阶段#define AMLog(...)#endif</code></pre><p>项目有可能和 c 和 c++ 混编，解决这种情况，需要</p><pre><code>#ifdef __OBJC__// 这里放 OC 代码#endif</code></pre><h3 id="在xcode中使用-pragma"><a href="#在xcode中使用-pragma" class="headerlink" title="在xcode中使用#pragma"></a>在xcode中使用#pragma</h3><p> 在开发过程中我们可以在方法前面加上下面代码来提供类似方法注释功能,该功能在提供注释的同时也方便在代码区上方的导航条中快速定位自己的方法：</p><pre><code>#pragma mark - Message </code></pre><p> 然后在代码过程中如果有一些想要忽略的警告(注意不是致命错误!)可以在文件顶端加入：</p><pre><code>    #pragma clang diagnostic ignored &quot;-W警告名&quot; </code></pre><ul><li><p>例如针对代码中有没有使用过的变量系统会提示Unused variable ‘variable’,这是就可以使用’-Wunused’或者’-Wunused-variable’来忽略该警告!</p></li><li><p>不知道大家对于版本适配是怎么做的,我是在判断版本号之后针对不同的版本做不同的处理,但是一些过去的版本一些方法已经禁用,</p></li><li><p>这时候一些有些小洁癖的人可以加入：</p></li></ul><pre><code>    #pragma clang diagnostic ignored &quot;-Wdeprecated&quot;  </code></pre><ul><li>但是这样有些自己不知道但是已经过期的方法也会被屏蔽了,所以可以使用分段屏蔽警告：</li></ul><pre><code>#pragma clang diagnostic push  #pragma clang diagnostic ignored &quot;-Wdeprecated&quot;      [NSURLConnection connectionWithRequest:request delegate:self];  #pragma clang diagnostic pop </code></pre><p>在push的时候开启,在pop的时候结束,其中在ignored开始后忽略报警</p><p>针对于警告,其实我们一般平时练习项目中使用到的warning只是一小部分而已,在项目的building setting里面搜索warning,</p><p>我们可以看到在Apple LLVM 下针对语言类型甚至是所有语言有许多关于警告的开关,大家可以一起去了解下!</p><p>如果我们追求代码的严苛和谨慎我们可以添加一些我们平常没有使用的警告.</p><p>在这里我们可以在Other C Flags 中加入-Wall,-Wextra,-Weverything来添加警告,当然针对调试过程中不推荐!容易让人精神崩溃!</p><p>在这里需要说明的是-Wall并不是所有的警告,只是包含了警告中的大部分,如果想要开启全部警告-Weverything!</p><p>这里面的警告有许多事编译器开发人员所使用的警告,但是同时也能让我们的代码更加清晰,规范!推荐代码release的阶段最好开启其他警告!</p><p>最后我们可以在项目中加入：</p><pre><code>    #warning this is a warning  </code></pre><p>来添加一个警告,提醒我们可能还有一些注意的地方!</p><p>甚至我们可以加入一些：</p><pre><code>#error This is a error </code></pre><p>来添加一个严重警告,提醒我们还有一些比如做的事没有做完,比如在编写第三方库的时候需要添加其他库,</p><p>我们可以手动添加严重警告,这样比在注释中添加说明要醒目的多!</p><pre><code>#pragma message &quot;This is a warning&quot;#warning &quot;This is another warning&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发调试常见错误总结</title>
      <link href="/2016/10/30/2016-10-30-ios-kai-fa-diao-shi-chang-jian-cuo-wu-zong-jie/"/>
      <url>/2016/10/30/2016-10-30-ios-kai-fa-diao-shi-chang-jian-cuo-wu-zong-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1、bitcode"><a href="#1、bitcode" class="headerlink" title="1、bitcode:"></a>1、bitcode:</h2><p><img src="https://note.youdao.com/yws/public/resource/549596ec601cacbe09feb48e7d1b17c9/xmlnote/WEBRESOURCEd21db742b70be8a1e0fc13398fb92be4/531" alt="image"></p><ul><li>解决办法：<br><img src="https://note.youdao.com/yws/public/resource/549596ec601cacbe09feb48e7d1b17c9/xmlnote/WEBRESOURCEbaeb5bc7764d7bec90243bf9bded9f6e/535" alt="image"><h2 id="2、ShareSDK各社交平台申请APPkey-的网址及申请流程汇总"><a href="#2、ShareSDK各社交平台申请APPkey-的网址及申请流程汇总" class="headerlink" title="2、ShareSDK各社交平台申请APPkey 的网址及申请流程汇总"></a>2、<a href="http://bbs.mob.com/thread-275-1-1.html" target="_blank" rel="noopener">ShareSDK各社交平台申请APPkey 的网址及申请流程汇总</a></h2><h3 id="1、新浪微博登录异常"><a href="#1、新浪微博登录异常" class="headerlink" title="1、新浪微博登录异常"></a>1、新浪微博登录异常</h3>你所访问的站点在微博认证失败，请联系XXXX:</li></ul><p><img src="https://note.youdao.com/yws/public/resource/7ebe77c6f950ce29b9f742e1224ecab9/xmlnote/WEBRESOURCE9e5635d4bdb38a9223dbaa25e591dab0/483" alt="image"><br>原因很可能是sina的sso填写错误。</p><h3 id="2、登录时跳转到新浪客户端，但是就是不调回原应用，也没有授权成功的回调："><a href="#2、登录时跳转到新浪客户端，但是就是不调回原应用，也没有授权成功的回调：" class="headerlink" title="2、登录时跳转到新浪客户端，但是就是不调回原应用，也没有授权成功的回调："></a>2、登录时跳转到新浪客户端，但是就是不调回原应用，也没有授权成功的回调：</h3><p><img src="https://note.youdao.com/yws/public/resource/7ebe77c6f950ce29b9f742e1224ecab9/xmlnote/WEBRESOURCE899c756468eb0af98ff4c276acf4577e/491" alt="image"></p><p>原因很可能是sina的wb填写错误。</p><h3 id="3、授权异常"><a href="#3、授权异常" class="headerlink" title="3、授权异常"></a>3、授权异常</h3><p><img src="https://note.youdao.com/yws/public/resource/7ebe77c6f950ce29b9f742e1224ecab9/xmlnote/WEBRESOURCE6222ea9d8205db7474ad26e608b1a02a/496" alt="image"></p><p>原因很可是是去新浪申请成功后，拿到key和secret后，在URL Schemes中没有填写正确，如上方的配置。</p><h2 id="4、证书适配（如果不能选择对应的team）："><a href="#4、证书适配（如果不能选择对应的team）：" class="headerlink" title="4、证书适配（如果不能选择对应的team）："></a>4、证书适配（如果不能选择对应的team）：</h2><p><img src="https://note.youdao.com/yws/public/resource/32afaefc05ee7931967ee37760daeb44/xmlnote/WEBRESOURCE676cb6374a07131769468dfb1ff21660/274" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/32afaefc05ee7931967ee37760daeb44/xmlnote/WEBRESOURCEaec88baf9feb8f18f4086eaf605fdc78/975" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIImage的简单封装</title>
      <link href="/2016/09/22/2016-09-22-uiimage-de-jian-dan-feng-zhuang/"/>
      <url>/2016/09/22/2016-09-22-uiimage-de-jian-dan-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="1、颜色转图片"><a href="#1、颜色转图片" class="headerlink" title="1、颜色转图片"></a>1、颜色转图片</h2><pre class=" language-objc"><code class="language-objc">+ (UIImage *)imageWithColor:(UIColor *)color {    CGRect rect = CGRectMake(0, 0, 1, 1);    UIGraphicsBeginImageContext(rect.size);    CGContextRef context = UIGraphicsGetCurrentContext();    CGContextSetFillColorWithColor(context, color.CGColor);    CGContextFillRect(context, rect);    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return image;}</code></pre><h2 id="2、裁剪"><a href="#2、裁剪" class="headerlink" title="2、裁剪"></a>2、裁剪</h2><pre class=" language-objc"><code class="language-objc">#import <UIKit/UIKit.h>@interface UIImage (Image)+ (UIImage *)imageWithClipImage:(UIImage *)image borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)color;@end</code></pre><pre class=" language-objc"><code class="language-objc">#import "UIImage+Image.h"@implementation UIImage (Image)+ (UIImage *)imageWithClipImage:(UIImage *)image borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)color {    // 图片的宽度和高度    CGFloat imageWH = image.size.width;    // 设置圆环的宽度    CGFloat border = borderWidth;    // 圆形的宽度和高度    CGFloat ovalWH = imageWH + 2 * border;    // 1.开启上下文    UIGraphicsBeginImageContextWithOptions(CGSizeMake(ovalWH, ovalWH), NO, 0);    // 2.画大圆    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, ovalWH, ovalWH)];    [color set];    [path fill];    // 3.设置裁剪区域    UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(border, border, imageWH, imageWH)];    [clipPath addClip];    // 4.绘制图片    [image drawAtPoint:CGPointMake(border, border)];    // 5.获取图片    UIImage *clipImage = UIGraphicsGetImageFromCurrentImageContext();    // 6.关闭上下文    UIGraphicsEndImageContext();    return clipImage;}@end</code></pre><h2 id="3、截屏"><a href="#3、截屏" class="headerlink" title="3、截屏"></a>3、截屏</h2><pre class=" language-objc"><code class="language-objc">//.h// 控件截屏+ (UIImage *)imageWithCaputureView:(UIView *)view;</code></pre><pre class=" language-objc"><code class="language-objc">+ (UIImage *)imageWithCaputureView:(UIView *)view{    // 开启位图上下文    UIGraphicsBeginImageContextWithOptions(view.bounds.size, NO, 0);    // 获取上下文    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 把控件上的图层渲染到上下文,layer只能渲染    [view.layer renderInContext:ctx];    // 生成一张图片    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();    // 关闭上下文    UIGraphicsEndImageContext();    return image;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> UIImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object-C的限定符的解惑总结</title>
      <link href="/2016/08/07/2016-08-07-xian-ding-fu/"/>
      <url>/2016/08/07/2016-08-07-xian-ding-fu/</url>
      
        <content type="html"><![CDATA[<h3 id="变量限定符"><a href="#变量限定符" class="headerlink" title="变量限定符"></a>变量限定符</h3><h4 id="ARC-为变量供了四种生命周期限定符。"><a href="#ARC-为变量供了四种生命周期限定符。" class="headerlink" title="ARC 为变量供了四种生命周期限定符。"></a>ARC 为变量供了四种生命周期限定符。</h4><h5 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h5><p>这是默认的限定符，无需显示引入。只要有强引用指向，对象就会长时间驻留在内存 中。可以将 __strong 理解为 retain 调用的 ARC 版本。</p><h5 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h5><p>这表明引用不会保持被引用对象的存活。当没有强引用指向对象时，弱引用会被置为 nil。可将 <strong>weak 看作是 assign 操作符的 ARC 版本，只是对象被回收时，</strong>weak 具有 安全性——指针将自动被设置为 nil。</p><h5 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h5><p>与 <strong>weak 类似，只是当没有强引用指向对象时，</strong>unsafe_unretained 不会被置为 nil。 可将其看作 assign 操作符的 ARC 版本。</p><h5 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h5><p>__autoreleasing用于由引用使用id *传递的消息参数。它预期了autorelease方法会 在传递参数的方法中被调用。</p><pre><code>//创建对象后引用计数为 1，并且对象在 p1 引用期间不会被回收。Person * __strong p1 = [[Person alloc] init]; //创建对象后引用计数为 0，对象会被立即释放，且 p2 将被设置为 nil。Person * __weak p2 = [[Person alloc] init]; //创建对象后引用计数为 1，对象会被立即释放，但 p3 不会被设置为 nil。Person * __unsafe_unretained p3 = [[Person alloc] init]; //创建对象后引用计数为 1，当方法返回时对象会被立即释放。Person * __autoreleasing p4 = [[Person alloc] init]; </code></pre><h3 id="属性限定符"><a href="#属性限定符" class="headerlink" title="属性限定符"></a>属性限定符</h3><p>属性声明有两个新的持有关系限定符:strong 和 weak。此外，assign 限定符的语义也被更新了。一言以蔽之，现在共有六个限定符。</p><h5 id="strong-1"><a href="#strong-1" class="headerlink" title="strong"></a>strong</h5><p>默认符，指定了 __strong 关系。</p><h5 id="weak-1"><a href="#weak-1" class="headerlink" title="weak"></a>weak</h5><p>指定了 __weak 关系。</p><h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>这不是新的限定符，但其含义发生了改变。在 ARC 之前，assign 是默认的持有关系限 定符。在启用 ARC 之后，assign 表示了 __unsafe_unretained 关系。</p><h5 id="copy"><a href="#copy" class="headerlink" title="[copy]"></a>[copy]</h5><p>暗指了 __strong 关系。此外，它还暗示了 setter 中的复制语义的常规行为。</p><h5 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h5><p>指定了 __strong 关系。</p><h5 id="unsafe-unretained-1"><a href="#unsafe-unretained-1" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h5><p>指定了 __unsafe_unretained 关系。</p><blockquote><p>因为 assign 和 unsafe_unretained 只进行值复制而没有任何 实质性的检查，所以它们只应该用于值类型(BOOL、NSInteger、NSUInteger，等等)。应避 免将它们用于引用类型，尤其是指针类型，如 NSString * 和 UIView *。</p></blockquote><pre><code>@property (nonatomic, strong) IBOutlet UILabel *titleView;@property (nonatomic, weak) id&lt;UIApplicationDelegate&gt; appDelegate;//错误地将 assign 用于指针。@property (nonatomic, assign) UIView *danglingReference;//对值类型正确地使用了 assign 限定符@property (nonatomic, assign) BOOL selected; @property (nonatomic, copy) NSString *name;//retain 是 ARC 纪元之前的老古董，现代的代码已经鲜有使用。在这里添加它只是为了完整性。@property (nonatomic, retain) HPPhoto *photo; @property (nonatomic, unsafe_unretained) UIView *danglingReference;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> 基础理论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
